Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    CONSTANT_RESOLUTION
    POWER_EQUALS
    PLUS_AT
    undef
    POWER
    LOGICAL_AND_EQUALS
    STRING2
    WORD_OR
    rescue
    COMPLEMENT
    not
    MAP
    yield
    SYMBOL_NOT
    module
    AT_THE_RATE
    ELEMENT_REFERENCE
    BEGIN
    retry
    COLON
    END
    REGEXP
    super
    CLOSE_FLOWER
    ensure
    or
    DOUBLE_QUOTE
    OPEN_FLOWER
    ELEMENT_SET
    next
    redo
    WORD_AND
    QUESTION_MARK
    HEREDOC
    BANG_TILDE
    and
    defined
    MINUS_AT
    WORD_NOT
    LOGICAL_OR_EQUALS
    begin
    unless
    DOLLAR
    FLOAT
    alias
    TRIPLE_EQUALS

Grammar

Rule 0     S' -> compstmt
Rule 1     compstmt -> multcompstmt
Rule 2     multcompstmt -> newline stmt1 multcompstmt
Rule 3     multcompstmt -> stmt1 multcompstmt
Rule 4     multcompstmt -> newline
Rule 5     stmt1 -> stmt
Rule 6     stmt -> keydef argdecl newline multstmt keyend
Rule 7     stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET
Rule 8     stmt -> print OPEN_BRACKET primary CLOSE_BRACKET
Rule 9     stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
Rule 10    stmt -> keyclass IDENTIFIER newline multstmt keyend
Rule 11    stmt -> break
Rule 12    stmt -> expr
Rule 13    keyclass -> class
Rule 14    keydef -> def IDENTIFIER
Rule 15    keyend -> end
Rule 16    multstmt -> stmt newline multstmt
Rule 17    multstmt -> empty
Rule 18    expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
Rule 19    expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1
Rule 20    expr -> if expr1 pthen M_1 multstmt end M_1
Rule 21    expr -> while M_1 expr1 pdo M_1 multstmt end M_1
Rule 22    expr -> until M_1 expr1 pdo M_1 multstmt end M_1
Rule 23    expr -> case expr1 newline multcase end M_1
Rule 24    expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
Rule 25    expr -> expr1
Rule 26    M_1 -> empty
Rule 27    expr1 -> return term2
Rule 28    expr1 -> return
Rule 29    expr1 -> expr2
Rule 30    expr2 -> arg
Rule 31    expr2 -> call
Rule 32    call -> function
Rule 33    function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
Rule 34    function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
Rule 35    arg -> term0
Rule 36    term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
Rule 37    term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
Rule 38    term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
Rule 39    term0 -> term1
Rule 40    term1 -> mlhs EQUALS mrhs
Rule 41    term1 -> mlhs opasgn mrhs
Rule 42    term1 -> term2
Rule 43    term2 -> term3 INCL_RANGE term3
Rule 44    term2 -> term3 EXCL_RANGE term3
Rule 45    term2 -> term3
Rule 46    term3 -> term3 LOGICAL_OR term4
Rule 47    term3 -> term3 LOGICAL_AND term4
Rule 48    term3 -> term4
Rule 49    term4 -> term5 DOUBLE_EQUALS term5
Rule 50    term4 -> term5 NOT_EQUALS term5
Rule 51    term4 -> term5 EQUAL_TILDE term5
Rule 52    term4 -> term5 COMPARISON term5
Rule 53    term4 -> term5
Rule 54    term5 -> term5 LESS term6
Rule 55    term5 -> term5 LESS_EQUALS term6
Rule 56    term5 -> term5 GREATER term6
Rule 57    term5 -> term5 GREATER_EQUALS term6
Rule 58    term5 -> term6
Rule 59    term6 -> term6 BIT_XOR term7
Rule 60    term6 -> term6 BIT_OR term7
Rule 61    term6 -> term7
Rule 62    term7 -> term7 BIT_AND term8
Rule 63    term7 -> term8
Rule 64    term8 -> term8 LEFT_SHIFT term9
Rule 65    term8 -> term8 RIGHT_SHIFT term9
Rule 66    term8 -> term9
Rule 67    term9 -> term9 PLUS term10
Rule 68    term9 -> term9 MINUS term10
Rule 69    term9 -> term10
Rule 70    term10 -> term10 MULTIPLY term11
Rule 71    term10 -> term10 DIVIDE term11
Rule 72    term10 -> term10 MODULO term11
Rule 73    term10 -> term11
Rule 74    term11 -> MINUS term11
Rule 75    term11 -> term12
Rule 76    term12 -> PLUS term12
Rule 77    term12 -> term13
Rule 78    term13 -> primary
Rule 79    primary -> OPEN_BRACKET expr2 CLOSE_BRACKET
Rule 80    primary -> arrayd
Rule 81    primary -> arraya
Rule 82    primary -> classvar
Rule 83    primary -> literal
Rule 84    primary -> varname
Rule 85    classvar -> IDENTIFIER DOT IDENTIFIER
Rule 86    arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET
Rule 87    array_size -> term2 COMMA array_size
Rule 88    array_size -> term2
Rule 89    arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE
Rule 90    arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE
Rule 91    array_args -> primary COMMA array_args
Rule 92    array_args -> primary
Rule 93    multcase -> when whenargs pthen M_1 multstmt M_1 multcase
Rule 94    multcase -> when whenargs pthen M_1 multstmt M_1
Rule 95    multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1
Rule 96    multelsif -> else newline multstmt
Rule 97    multelsif -> empty
Rule 98    literal -> NUMBER
Rule 99    literal -> true
Rule 100   literal -> false
Rule 101   whenargs -> arg
Rule 102   mlhs -> mlhsitem
Rule 103   mlhsitem -> IDENTIFIER
Rule 104   mlhsitem -> arrayal
Rule 105   mlhsitem -> classvar
Rule 106   mrhs -> term2
Rule 107   callargs -> callarglist
Rule 108   callarglist -> term2 callmultarglist
Rule 109   callarglist -> empty
Rule 110   callmultarglist -> COMMA term2 callmultarglist
Rule 111   callmultarglist -> empty
Rule 112   argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET
Rule 113   arglist -> IDENTIFIER multarglist
Rule 114   arglist -> empty
Rule 115   multarglist -> COMMA IDENTIFIER multarglist
Rule 116   multarglist -> empty
Rule 117   variable -> varname
Rule 118   variable -> nil
Rule 119   variable -> self
Rule 120   pthen -> newline
Rule 121   pthen -> then
Rule 122   pthen -> newline then
Rule 123   pdo -> newline
Rule 124   pdo -> do newline
Rule 125   pdo -> newline do
Rule 126   opasgn -> MODULO_EQUALS
Rule 127   opasgn -> DIVIDE_EQUALS
Rule 128   opasgn -> MINUS_EQUALS
Rule 129   opasgn -> PLUS_EQUALS
Rule 130   opasgn -> OR_EQUALS
Rule 131   opasgn -> AND_EQUALS
Rule 132   opasgn -> XOR_EQUALS
Rule 133   opasgn -> RIGHT_SHIFT_EQUALS
Rule 134   opasgn -> LEFT_SHIFT_EQUALS
Rule 135   opasgn -> MULTIPLY_EQUALS
Rule 136   varname -> GLOBAL
Rule 137   varname -> IDENTIFIER
Rule 138   newline -> SEMI_COLON
Rule 139   newline -> NEWLINE
Rule 140   newline -> empty
Rule 141   empty -> <empty>

Terminals, with rules where they appear

AND_EQUALS           : 131
AT_THE_RATE          : 
Array                : 86
BANG_TILDE           : 
BEGIN                : 
BIT_AND              : 62
BIT_OR               : 60
BIT_XOR              : 59
CLOSE_BRACKET        : 7 8 9 33 34 36 37 38 79 86 112
CLOSE_FLOWER         : 
CLOSE_SQUARE         : 89 90
COLON                : 
COMMA                : 87 91 110 115
COMPARISON           : 52
COMPLEMENT           : 
CONSTANT_RESOLUTION  : 
DIVIDE               : 71
DIVIDE_EQUALS        : 127
DOLLAR               : 
DOT                  : 38 85
DOUBLE_EQUALS        : 49
DOUBLE_QUOTE         : 
ELEMENT_REFERENCE    : 
ELEMENT_SET          : 
END                  : 
EQUALS               : 36 37 38 40
EQUAL_TILDE          : 51
EXCL_RANGE           : 44
FLOAT                : 
GLOBAL               : 136
GREATER              : 56
GREATER_EQUALS       : 57
HEREDOC              : 
IDENTIFIER           : 9 10 14 33 34 36 37 38 85 85 103 113 115 137
INCL_RANGE           : 43
LEFT_SHIFT           : 64
LEFT_SHIFT_EQUALS    : 134
LESS                 : 54
LESS_EQUALS          : 55
LOGICAL_AND          : 47
LOGICAL_AND_EQUALS   : 
LOGICAL_OR           : 46
LOGICAL_OR_EQUALS    : 
MAP                  : 
MINUS                : 68 74
MINUS_AT             : 
MINUS_EQUALS         : 128
MODULO               : 72
MODULO_EQUALS        : 126
MULTIPLY             : 70
MULTIPLY_EQUALS      : 135
NEWLINE              : 139
NOT_EQUALS           : 50
NUMBER               : 98
OPEN_BRACKET         : 7 8 9 33 34 36 37 38 79 86 112
OPEN_FLOWER          : 
OPEN_SQUARE          : 89 90
OR_EQUALS            : 130
PLUS                 : 67 76
PLUS_AT              : 
PLUS_EQUALS          : 129
POWER                : 
POWER_EQUALS         : 
QUESTION_MARK        : 
REGEXP               : 
RIGHT_SHIFT          : 65
RIGHT_SHIFT_EQUALS   : 133
SEMI_COLON           : 138
STRING               : 7
STRING2              : 
SYMBOL_NOT           : 
TRIPLE_EQUALS        : 
WORD_AND             : 
WORD_NOT             : 
WORD_OR              : 
XOR_EQUALS           : 132
alias                : 
and                  : 
begin                : 
break                : 11
case                 : 23
class                : 13
def                  : 14
defined              : 
do                   : 124 125
else                 : 18 96
elsif                : 95
end                  : 15 18 19 20 21 22 23 24
ensure               : 
error                : 
false                : 100
for                  : 24
gets                 : 9
if                   : 18 19 20
in                   : 24
module               : 
new                  : 38
next                 : 
nil                  : 118
not                  : 
or                   : 
print                : 8
puts                 : 7
redo                 : 
rescue               : 
retry                : 
return               : 27 28
self                 : 119
super                : 
then                 : 121 122
true                 : 99
undef                : 
unless               : 
until                : 22
when                 : 93 94
while                : 21
yield                : 

Nonterminals, with rules where they appear

M_1                  : 18 18 18 19 19 19 20 20 21 21 21 22 22 22 23 24 24 24 93 93 94 94 95 95 95
arg                  : 30 101
argdecl              : 6
arglist              : 112
array_args           : 89 90 91
array_size           : 86 87
arraya               : 81
arrayal              : 104
arrayd               : 80
call                 : 31
callarglist          : 107
callargs             : 33 37
callmultarglist      : 108 110
classvar             : 82 105
compstmt             : 0
empty                : 17 26 97 109 111 114 116 140
expr                 : 12 95
expr1                : 18 19 20 21 22 23 24 25
expr2                : 29 79
function             : 32
keyclass             : 10
keydef               : 6
keyend               : 6 10
literal              : 83
mlhs                 : 24 36 37 38 40 41
mlhsitem             : 102
mrhs                 : 40 41
multarglist          : 113 115
multcase             : 23 93
multcompstmt         : 1 2 3
multelsif            : 19 95
multstmt             : 6 10 16 18 18 19 20 21 22 24 93 94 95 96
newline              : 2 4 6 10 16 18 23 96 120 122 123 124 125
opasgn               : 41
pdo                  : 21 22 24
primary              : 8 78 91 92
pthen                : 18 19 20 93 94 95
stmt                 : 5 16
stmt1                : 2 3
term0                : 35
term1                : 39
term10               : 67 68 69 70 71 72
term11               : 70 71 72 73 74
term12               : 75 76
term13               : 77
term2                : 27 42 87 88 106 108 110
term3                : 43 43 44 44 45 46 47
term4                : 46 47 48
term5                : 49 49 50 50 51 51 52 52 53 54 55 56 57
term6                : 54 55 56 57 58 59 60
term7                : 59 60 61 62
term8                : 62 63 64 65
term9                : 64 65 66 67 68
variable             : 89 90
varname              : 84 117
whenargs             : 93 94

Parsing method: LALR

state 0

    (0) S' -> . compstmt
    (1) compstmt -> . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (5) stmt1 -> . stmt
    (141) empty -> .
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

  ! shift/reduce conflict for puts resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for gets resolved as shift
  ! shift/reduce conflict for break resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for while resolved as shift
  ! shift/reduce conflict for until resolved as shift
  ! shift/reduce conflict for case resolved as shift
  ! shift/reduce conflict for for resolved as shift
  ! shift/reduce conflict for return resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for nil resolved as shift
  ! shift/reduce conflict for self resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
  ! shift/reduce conflict for Array resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for true resolved as shift
  ! shift/reduce conflict for false resolved as shift
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    $end            reduce using rule 141 (empty -> .)
    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

  ! puts            [ reduce using rule 141 (empty -> .) ]
  ! print           [ reduce using rule 141 (empty -> .) ]
  ! gets            [ reduce using rule 141 (empty -> .) ]
  ! break           [ reduce using rule 141 (empty -> .) ]
  ! def             [ reduce using rule 141 (empty -> .) ]
  ! class           [ reduce using rule 141 (empty -> .) ]
  ! if              [ reduce using rule 141 (empty -> .) ]
  ! while           [ reduce using rule 141 (empty -> .) ]
  ! until           [ reduce using rule 141 (empty -> .) ]
  ! case            [ reduce using rule 141 (empty -> .) ]
  ! for             [ reduce using rule 141 (empty -> .) ]
  ! return          [ reduce using rule 141 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 141 (empty -> .) ]
  ! nil             [ reduce using rule 141 (empty -> .) ]
  ! self            [ reduce using rule 141 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 141 (empty -> .) ]
  ! MINUS           [ reduce using rule 141 (empty -> .) ]
  ! PLUS            [ reduce using rule 141 (empty -> .) ]
  ! OPEN_BRACKET    [ reduce using rule 141 (empty -> .) ]
  ! Array           [ reduce using rule 141 (empty -> .) ]
  ! NUMBER          [ reduce using rule 141 (empty -> .) ]
  ! true            [ reduce using rule 141 (empty -> .) ]
  ! false           [ reduce using rule 141 (empty -> .) ]

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 41
    function                       shift and go to state 42
    newline                        shift and go to state 59
    multcompstmt                   shift and go to state 7
    stmt                           shift and go to state 28
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    compstmt                       shift and go to state 29
    expr                           shift and go to state 46
    stmt1                          shift and go to state 31
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 1

    (36) term0 -> mlhs . EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> mlhs . EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> mlhs . EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (40) term1 -> mlhs . EQUALS mrhs
    (41) term1 -> mlhs . opasgn mrhs
    (126) opasgn -> . MODULO_EQUALS
    (127) opasgn -> . DIVIDE_EQUALS
    (128) opasgn -> . MINUS_EQUALS
    (129) opasgn -> . PLUS_EQUALS
    (130) opasgn -> . OR_EQUALS
    (131) opasgn -> . AND_EQUALS
    (132) opasgn -> . XOR_EQUALS
    (133) opasgn -> . RIGHT_SHIFT_EQUALS
    (134) opasgn -> . LEFT_SHIFT_EQUALS
    (135) opasgn -> . MULTIPLY_EQUALS

    EQUALS          shift and go to state 71
    MODULO_EQUALS   shift and go to state 75
    DIVIDE_EQUALS   shift and go to state 69
    MINUS_EQUALS    shift and go to state 64
    PLUS_EQUALS     shift and go to state 65
    OR_EQUALS       shift and go to state 72
    AND_EQUALS      shift and go to state 68
    XOR_EQUALS      shift and go to state 66
    RIGHT_SHIFT_EQUALS shift and go to state 70
    LEFT_SHIFT_EQUALS shift and go to state 67
    MULTIPLY_EQUALS shift and go to state 74

    opasgn                         shift and go to state 73

state 2

    (74) term11 -> MINUS . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 80
    arrayd                         shift and go to state 50

state 3

    (139) newline -> NEWLINE .

    puts            reduce using rule 139 (newline -> NEWLINE .)
    print           reduce using rule 139 (newline -> NEWLINE .)
    gets            reduce using rule 139 (newline -> NEWLINE .)
    break           reduce using rule 139 (newline -> NEWLINE .)
    def             reduce using rule 139 (newline -> NEWLINE .)
    class           reduce using rule 139 (newline -> NEWLINE .)
    if              reduce using rule 139 (newline -> NEWLINE .)
    while           reduce using rule 139 (newline -> NEWLINE .)
    until           reduce using rule 139 (newline -> NEWLINE .)
    case            reduce using rule 139 (newline -> NEWLINE .)
    for             reduce using rule 139 (newline -> NEWLINE .)
    return          reduce using rule 139 (newline -> NEWLINE .)
    IDENTIFIER      reduce using rule 139 (newline -> NEWLINE .)
    nil             reduce using rule 139 (newline -> NEWLINE .)
    self            reduce using rule 139 (newline -> NEWLINE .)
    GLOBAL          reduce using rule 139 (newline -> NEWLINE .)
    MINUS           reduce using rule 139 (newline -> NEWLINE .)
    PLUS            reduce using rule 139 (newline -> NEWLINE .)
    OPEN_BRACKET    reduce using rule 139 (newline -> NEWLINE .)
    Array           reduce using rule 139 (newline -> NEWLINE .)
    NUMBER          reduce using rule 139 (newline -> NEWLINE .)
    true            reduce using rule 139 (newline -> NEWLINE .)
    false           reduce using rule 139 (newline -> NEWLINE .)
    $end            reduce using rule 139 (newline -> NEWLINE .)
    then            reduce using rule 139 (newline -> NEWLINE .)
    when            reduce using rule 139 (newline -> NEWLINE .)
    end             reduce using rule 139 (newline -> NEWLINE .)
    do              reduce using rule 139 (newline -> NEWLINE .)
    else            reduce using rule 139 (newline -> NEWLINE .)
    elsif           reduce using rule 139 (newline -> NEWLINE .)


state 4

    (79) primary -> OPEN_BRACKET . expr2 CLOSE_BRACKET
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 81
    literal                        shift and go to state 37
    call                           shift and go to state 38
    function                       shift and go to state 42
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    varname                        shift and go to state 30
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 5

    (76) term12 -> PLUS . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    term13                         shift and go to state 10
    term12                         shift and go to state 82
    arrayd                         shift and go to state 50

state 6

    (27) expr1 -> return . term2
    (28) expr1 -> return .
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
  ! shift/reduce conflict for Array resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for true resolved as shift
  ! shift/reduce conflict for false resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for nil resolved as shift
  ! shift/reduce conflict for self resolved as shift
    SEMI_COLON      reduce using rule 28 (expr1 -> return .)
    NEWLINE         reduce using rule 28 (expr1 -> return .)
    puts            reduce using rule 28 (expr1 -> return .)
    print           reduce using rule 28 (expr1 -> return .)
    gets            reduce using rule 28 (expr1 -> return .)
    break           reduce using rule 28 (expr1 -> return .)
    def             reduce using rule 28 (expr1 -> return .)
    class           reduce using rule 28 (expr1 -> return .)
    if              reduce using rule 28 (expr1 -> return .)
    while           reduce using rule 28 (expr1 -> return .)
    until           reduce using rule 28 (expr1 -> return .)
    case            reduce using rule 28 (expr1 -> return .)
    for             reduce using rule 28 (expr1 -> return .)
    return          reduce using rule 28 (expr1 -> return .)
    $end            reduce using rule 28 (expr1 -> return .)
    end             reduce using rule 28 (expr1 -> return .)
    then            reduce using rule 28 (expr1 -> return .)
    elsif           reduce using rule 28 (expr1 -> return .)
    else            reduce using rule 28 (expr1 -> return .)
    when            reduce using rule 28 (expr1 -> return .)
    do              reduce using rule 28 (expr1 -> return .)
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

  ! IDENTIFIER      [ reduce using rule 28 (expr1 -> return .) ]
  ! nil             [ reduce using rule 28 (expr1 -> return .) ]
  ! self            [ reduce using rule 28 (expr1 -> return .) ]
  ! GLOBAL          [ reduce using rule 28 (expr1 -> return .) ]
  ! MINUS           [ reduce using rule 28 (expr1 -> return .) ]
  ! PLUS            [ reduce using rule 28 (expr1 -> return .) ]
  ! OPEN_BRACKET    [ reduce using rule 28 (expr1 -> return .) ]
  ! Array           [ reduce using rule 28 (expr1 -> return .) ]
  ! NUMBER          [ reduce using rule 28 (expr1 -> return .) ]
  ! true            [ reduce using rule 28 (expr1 -> return .) ]
  ! false           [ reduce using rule 28 (expr1 -> return .) ]

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 83
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 7

    (1) compstmt -> multcompstmt .

    $end            reduce using rule 1 (compstmt -> multcompstmt .)


state 8

    (11) stmt -> break .

    SEMI_COLON      reduce using rule 11 (stmt -> break .)
    NEWLINE         reduce using rule 11 (stmt -> break .)
    puts            reduce using rule 11 (stmt -> break .)
    print           reduce using rule 11 (stmt -> break .)
    gets            reduce using rule 11 (stmt -> break .)
    break           reduce using rule 11 (stmt -> break .)
    def             reduce using rule 11 (stmt -> break .)
    class           reduce using rule 11 (stmt -> break .)
    if              reduce using rule 11 (stmt -> break .)
    while           reduce using rule 11 (stmt -> break .)
    until           reduce using rule 11 (stmt -> break .)
    case            reduce using rule 11 (stmt -> break .)
    for             reduce using rule 11 (stmt -> break .)
    return          reduce using rule 11 (stmt -> break .)
    IDENTIFIER      reduce using rule 11 (stmt -> break .)
    nil             reduce using rule 11 (stmt -> break .)
    self            reduce using rule 11 (stmt -> break .)
    GLOBAL          reduce using rule 11 (stmt -> break .)
    MINUS           reduce using rule 11 (stmt -> break .)
    PLUS            reduce using rule 11 (stmt -> break .)
    OPEN_BRACKET    reduce using rule 11 (stmt -> break .)
    Array           reduce using rule 11 (stmt -> break .)
    NUMBER          reduce using rule 11 (stmt -> break .)
    true            reduce using rule 11 (stmt -> break .)
    false           reduce using rule 11 (stmt -> break .)
    end             reduce using rule 11 (stmt -> break .)
    $end            reduce using rule 11 (stmt -> break .)
    when            reduce using rule 11 (stmt -> break .)
    else            reduce using rule 11 (stmt -> break .)
    elsif           reduce using rule 11 (stmt -> break .)


state 9

    (105) mlhsitem -> classvar .
    (82) primary -> classvar .

    EQUALS          reduce using rule 105 (mlhsitem -> classvar .)
    MODULO_EQUALS   reduce using rule 105 (mlhsitem -> classvar .)
    DIVIDE_EQUALS   reduce using rule 105 (mlhsitem -> classvar .)
    MINUS_EQUALS    reduce using rule 105 (mlhsitem -> classvar .)
    PLUS_EQUALS     reduce using rule 105 (mlhsitem -> classvar .)
    OR_EQUALS       reduce using rule 105 (mlhsitem -> classvar .)
    AND_EQUALS      reduce using rule 105 (mlhsitem -> classvar .)
    XOR_EQUALS      reduce using rule 105 (mlhsitem -> classvar .)
    RIGHT_SHIFT_EQUALS reduce using rule 105 (mlhsitem -> classvar .)
    LEFT_SHIFT_EQUALS reduce using rule 105 (mlhsitem -> classvar .)
    MULTIPLY_EQUALS reduce using rule 105 (mlhsitem -> classvar .)
    MULTIPLY        reduce using rule 82 (primary -> classvar .)
    DIVIDE          reduce using rule 82 (primary -> classvar .)
    MODULO          reduce using rule 82 (primary -> classvar .)
    PLUS            reduce using rule 82 (primary -> classvar .)
    MINUS           reduce using rule 82 (primary -> classvar .)
    LEFT_SHIFT      reduce using rule 82 (primary -> classvar .)
    RIGHT_SHIFT     reduce using rule 82 (primary -> classvar .)
    BIT_AND         reduce using rule 82 (primary -> classvar .)
    BIT_XOR         reduce using rule 82 (primary -> classvar .)
    BIT_OR          reduce using rule 82 (primary -> classvar .)
    DOUBLE_EQUALS   reduce using rule 82 (primary -> classvar .)
    NOT_EQUALS      reduce using rule 82 (primary -> classvar .)
    EQUAL_TILDE     reduce using rule 82 (primary -> classvar .)
    COMPARISON      reduce using rule 82 (primary -> classvar .)
    LESS            reduce using rule 82 (primary -> classvar .)
    LESS_EQUALS     reduce using rule 82 (primary -> classvar .)
    GREATER         reduce using rule 82 (primary -> classvar .)
    GREATER_EQUALS  reduce using rule 82 (primary -> classvar .)
    INCL_RANGE      reduce using rule 82 (primary -> classvar .)
    EXCL_RANGE      reduce using rule 82 (primary -> classvar .)
    LOGICAL_OR      reduce using rule 82 (primary -> classvar .)
    LOGICAL_AND     reduce using rule 82 (primary -> classvar .)
    do              reduce using rule 82 (primary -> classvar .)
    SEMI_COLON      reduce using rule 82 (primary -> classvar .)
    NEWLINE         reduce using rule 82 (primary -> classvar .)
    puts            reduce using rule 82 (primary -> classvar .)
    print           reduce using rule 82 (primary -> classvar .)
    gets            reduce using rule 82 (primary -> classvar .)
    break           reduce using rule 82 (primary -> classvar .)
    def             reduce using rule 82 (primary -> classvar .)
    class           reduce using rule 82 (primary -> classvar .)
    if              reduce using rule 82 (primary -> classvar .)
    while           reduce using rule 82 (primary -> classvar .)
    until           reduce using rule 82 (primary -> classvar .)
    case            reduce using rule 82 (primary -> classvar .)
    for             reduce using rule 82 (primary -> classvar .)
    return          reduce using rule 82 (primary -> classvar .)
    IDENTIFIER      reduce using rule 82 (primary -> classvar .)
    nil             reduce using rule 82 (primary -> classvar .)
    self            reduce using rule 82 (primary -> classvar .)
    GLOBAL          reduce using rule 82 (primary -> classvar .)
    OPEN_BRACKET    reduce using rule 82 (primary -> classvar .)
    Array           reduce using rule 82 (primary -> classvar .)
    NUMBER          reduce using rule 82 (primary -> classvar .)
    true            reduce using rule 82 (primary -> classvar .)
    false           reduce using rule 82 (primary -> classvar .)
    end             reduce using rule 82 (primary -> classvar .)
    CLOSE_BRACKET   reduce using rule 82 (primary -> classvar .)
    when            reduce using rule 82 (primary -> classvar .)
    then            reduce using rule 82 (primary -> classvar .)
    else            reduce using rule 82 (primary -> classvar .)
    elsif           reduce using rule 82 (primary -> classvar .)
    $end            reduce using rule 82 (primary -> classvar .)


state 10

    (77) term12 -> term13 .

    MULTIPLY        reduce using rule 77 (term12 -> term13 .)
    DIVIDE          reduce using rule 77 (term12 -> term13 .)
    MODULO          reduce using rule 77 (term12 -> term13 .)
    PLUS            reduce using rule 77 (term12 -> term13 .)
    MINUS           reduce using rule 77 (term12 -> term13 .)
    LEFT_SHIFT      reduce using rule 77 (term12 -> term13 .)
    RIGHT_SHIFT     reduce using rule 77 (term12 -> term13 .)
    BIT_AND         reduce using rule 77 (term12 -> term13 .)
    BIT_XOR         reduce using rule 77 (term12 -> term13 .)
    BIT_OR          reduce using rule 77 (term12 -> term13 .)
    DOUBLE_EQUALS   reduce using rule 77 (term12 -> term13 .)
    NOT_EQUALS      reduce using rule 77 (term12 -> term13 .)
    EQUAL_TILDE     reduce using rule 77 (term12 -> term13 .)
    COMPARISON      reduce using rule 77 (term12 -> term13 .)
    LESS            reduce using rule 77 (term12 -> term13 .)
    LESS_EQUALS     reduce using rule 77 (term12 -> term13 .)
    GREATER         reduce using rule 77 (term12 -> term13 .)
    GREATER_EQUALS  reduce using rule 77 (term12 -> term13 .)
    INCL_RANGE      reduce using rule 77 (term12 -> term13 .)
    EXCL_RANGE      reduce using rule 77 (term12 -> term13 .)
    LOGICAL_OR      reduce using rule 77 (term12 -> term13 .)
    LOGICAL_AND     reduce using rule 77 (term12 -> term13 .)
    SEMI_COLON      reduce using rule 77 (term12 -> term13 .)
    NEWLINE         reduce using rule 77 (term12 -> term13 .)
    puts            reduce using rule 77 (term12 -> term13 .)
    print           reduce using rule 77 (term12 -> term13 .)
    gets            reduce using rule 77 (term12 -> term13 .)
    break           reduce using rule 77 (term12 -> term13 .)
    def             reduce using rule 77 (term12 -> term13 .)
    class           reduce using rule 77 (term12 -> term13 .)
    if              reduce using rule 77 (term12 -> term13 .)
    while           reduce using rule 77 (term12 -> term13 .)
    until           reduce using rule 77 (term12 -> term13 .)
    case            reduce using rule 77 (term12 -> term13 .)
    for             reduce using rule 77 (term12 -> term13 .)
    return          reduce using rule 77 (term12 -> term13 .)
    IDENTIFIER      reduce using rule 77 (term12 -> term13 .)
    nil             reduce using rule 77 (term12 -> term13 .)
    self            reduce using rule 77 (term12 -> term13 .)
    GLOBAL          reduce using rule 77 (term12 -> term13 .)
    OPEN_BRACKET    reduce using rule 77 (term12 -> term13 .)
    Array           reduce using rule 77 (term12 -> term13 .)
    NUMBER          reduce using rule 77 (term12 -> term13 .)
    true            reduce using rule 77 (term12 -> term13 .)
    false           reduce using rule 77 (term12 -> term13 .)
    $end            reduce using rule 77 (term12 -> term13 .)
    CLOSE_BRACKET   reduce using rule 77 (term12 -> term13 .)
    when            reduce using rule 77 (term12 -> term13 .)
    then            reduce using rule 77 (term12 -> term13 .)
    else            reduce using rule 77 (term12 -> term13 .)
    end             reduce using rule 77 (term12 -> term13 .)
    elsif           reduce using rule 77 (term12 -> term13 .)
    do              reduce using rule 77 (term12 -> term13 .)
    COMMA           reduce using rule 77 (term12 -> term13 .)


state 11

    (75) term11 -> term12 .

    MULTIPLY        reduce using rule 75 (term11 -> term12 .)
    DIVIDE          reduce using rule 75 (term11 -> term12 .)
    MODULO          reduce using rule 75 (term11 -> term12 .)
    PLUS            reduce using rule 75 (term11 -> term12 .)
    MINUS           reduce using rule 75 (term11 -> term12 .)
    LEFT_SHIFT      reduce using rule 75 (term11 -> term12 .)
    RIGHT_SHIFT     reduce using rule 75 (term11 -> term12 .)
    BIT_AND         reduce using rule 75 (term11 -> term12 .)
    BIT_XOR         reduce using rule 75 (term11 -> term12 .)
    BIT_OR          reduce using rule 75 (term11 -> term12 .)
    DOUBLE_EQUALS   reduce using rule 75 (term11 -> term12 .)
    NOT_EQUALS      reduce using rule 75 (term11 -> term12 .)
    EQUAL_TILDE     reduce using rule 75 (term11 -> term12 .)
    COMPARISON      reduce using rule 75 (term11 -> term12 .)
    LESS            reduce using rule 75 (term11 -> term12 .)
    LESS_EQUALS     reduce using rule 75 (term11 -> term12 .)
    GREATER         reduce using rule 75 (term11 -> term12 .)
    GREATER_EQUALS  reduce using rule 75 (term11 -> term12 .)
    INCL_RANGE      reduce using rule 75 (term11 -> term12 .)
    EXCL_RANGE      reduce using rule 75 (term11 -> term12 .)
    LOGICAL_OR      reduce using rule 75 (term11 -> term12 .)
    LOGICAL_AND     reduce using rule 75 (term11 -> term12 .)
    SEMI_COLON      reduce using rule 75 (term11 -> term12 .)
    NEWLINE         reduce using rule 75 (term11 -> term12 .)
    puts            reduce using rule 75 (term11 -> term12 .)
    print           reduce using rule 75 (term11 -> term12 .)
    gets            reduce using rule 75 (term11 -> term12 .)
    break           reduce using rule 75 (term11 -> term12 .)
    def             reduce using rule 75 (term11 -> term12 .)
    class           reduce using rule 75 (term11 -> term12 .)
    if              reduce using rule 75 (term11 -> term12 .)
    while           reduce using rule 75 (term11 -> term12 .)
    until           reduce using rule 75 (term11 -> term12 .)
    case            reduce using rule 75 (term11 -> term12 .)
    for             reduce using rule 75 (term11 -> term12 .)
    return          reduce using rule 75 (term11 -> term12 .)
    IDENTIFIER      reduce using rule 75 (term11 -> term12 .)
    nil             reduce using rule 75 (term11 -> term12 .)
    self            reduce using rule 75 (term11 -> term12 .)
    GLOBAL          reduce using rule 75 (term11 -> term12 .)
    OPEN_BRACKET    reduce using rule 75 (term11 -> term12 .)
    Array           reduce using rule 75 (term11 -> term12 .)
    NUMBER          reduce using rule 75 (term11 -> term12 .)
    true            reduce using rule 75 (term11 -> term12 .)
    false           reduce using rule 75 (term11 -> term12 .)
    when            reduce using rule 75 (term11 -> term12 .)
    end             reduce using rule 75 (term11 -> term12 .)
    $end            reduce using rule 75 (term11 -> term12 .)
    CLOSE_BRACKET   reduce using rule 75 (term11 -> term12 .)
    then            reduce using rule 75 (term11 -> term12 .)
    else            reduce using rule 75 (term11 -> term12 .)
    elsif           reduce using rule 75 (term11 -> term12 .)
    do              reduce using rule 75 (term11 -> term12 .)
    COMMA           reduce using rule 75 (term11 -> term12 .)


state 12

    (73) term10 -> term11 .

    MULTIPLY        reduce using rule 73 (term10 -> term11 .)
    DIVIDE          reduce using rule 73 (term10 -> term11 .)
    MODULO          reduce using rule 73 (term10 -> term11 .)
    PLUS            reduce using rule 73 (term10 -> term11 .)
    MINUS           reduce using rule 73 (term10 -> term11 .)
    LEFT_SHIFT      reduce using rule 73 (term10 -> term11 .)
    RIGHT_SHIFT     reduce using rule 73 (term10 -> term11 .)
    BIT_AND         reduce using rule 73 (term10 -> term11 .)
    BIT_XOR         reduce using rule 73 (term10 -> term11 .)
    BIT_OR          reduce using rule 73 (term10 -> term11 .)
    DOUBLE_EQUALS   reduce using rule 73 (term10 -> term11 .)
    NOT_EQUALS      reduce using rule 73 (term10 -> term11 .)
    EQUAL_TILDE     reduce using rule 73 (term10 -> term11 .)
    COMPARISON      reduce using rule 73 (term10 -> term11 .)
    LESS            reduce using rule 73 (term10 -> term11 .)
    LESS_EQUALS     reduce using rule 73 (term10 -> term11 .)
    GREATER         reduce using rule 73 (term10 -> term11 .)
    GREATER_EQUALS  reduce using rule 73 (term10 -> term11 .)
    INCL_RANGE      reduce using rule 73 (term10 -> term11 .)
    EXCL_RANGE      reduce using rule 73 (term10 -> term11 .)
    LOGICAL_OR      reduce using rule 73 (term10 -> term11 .)
    LOGICAL_AND     reduce using rule 73 (term10 -> term11 .)
    SEMI_COLON      reduce using rule 73 (term10 -> term11 .)
    NEWLINE         reduce using rule 73 (term10 -> term11 .)
    puts            reduce using rule 73 (term10 -> term11 .)
    print           reduce using rule 73 (term10 -> term11 .)
    gets            reduce using rule 73 (term10 -> term11 .)
    break           reduce using rule 73 (term10 -> term11 .)
    def             reduce using rule 73 (term10 -> term11 .)
    class           reduce using rule 73 (term10 -> term11 .)
    if              reduce using rule 73 (term10 -> term11 .)
    while           reduce using rule 73 (term10 -> term11 .)
    until           reduce using rule 73 (term10 -> term11 .)
    case            reduce using rule 73 (term10 -> term11 .)
    for             reduce using rule 73 (term10 -> term11 .)
    return          reduce using rule 73 (term10 -> term11 .)
    IDENTIFIER      reduce using rule 73 (term10 -> term11 .)
    nil             reduce using rule 73 (term10 -> term11 .)
    self            reduce using rule 73 (term10 -> term11 .)
    GLOBAL          reduce using rule 73 (term10 -> term11 .)
    OPEN_BRACKET    reduce using rule 73 (term10 -> term11 .)
    Array           reduce using rule 73 (term10 -> term11 .)
    NUMBER          reduce using rule 73 (term10 -> term11 .)
    true            reduce using rule 73 (term10 -> term11 .)
    false           reduce using rule 73 (term10 -> term11 .)
    $end            reduce using rule 73 (term10 -> term11 .)
    CLOSE_BRACKET   reduce using rule 73 (term10 -> term11 .)
    when            reduce using rule 73 (term10 -> term11 .)
    then            reduce using rule 73 (term10 -> term11 .)
    else            reduce using rule 73 (term10 -> term11 .)
    end             reduce using rule 73 (term10 -> term11 .)
    elsif           reduce using rule 73 (term10 -> term11 .)
    do              reduce using rule 73 (term10 -> term11 .)
    COMMA           reduce using rule 73 (term10 -> term11 .)


state 13

    (69) term9 -> term10 .
    (70) term10 -> term10 . MULTIPLY term11
    (71) term10 -> term10 . DIVIDE term11
    (72) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 69 (term9 -> term10 .)
    MINUS           reduce using rule 69 (term9 -> term10 .)
    LEFT_SHIFT      reduce using rule 69 (term9 -> term10 .)
    RIGHT_SHIFT     reduce using rule 69 (term9 -> term10 .)
    BIT_AND         reduce using rule 69 (term9 -> term10 .)
    BIT_XOR         reduce using rule 69 (term9 -> term10 .)
    BIT_OR          reduce using rule 69 (term9 -> term10 .)
    LESS            reduce using rule 69 (term9 -> term10 .)
    LESS_EQUALS     reduce using rule 69 (term9 -> term10 .)
    GREATER         reduce using rule 69 (term9 -> term10 .)
    GREATER_EQUALS  reduce using rule 69 (term9 -> term10 .)
    INCL_RANGE      reduce using rule 69 (term9 -> term10 .)
    EXCL_RANGE      reduce using rule 69 (term9 -> term10 .)
    LOGICAL_OR      reduce using rule 69 (term9 -> term10 .)
    LOGICAL_AND     reduce using rule 69 (term9 -> term10 .)
    SEMI_COLON      reduce using rule 69 (term9 -> term10 .)
    NEWLINE         reduce using rule 69 (term9 -> term10 .)
    puts            reduce using rule 69 (term9 -> term10 .)
    print           reduce using rule 69 (term9 -> term10 .)
    gets            reduce using rule 69 (term9 -> term10 .)
    break           reduce using rule 69 (term9 -> term10 .)
    def             reduce using rule 69 (term9 -> term10 .)
    class           reduce using rule 69 (term9 -> term10 .)
    if              reduce using rule 69 (term9 -> term10 .)
    while           reduce using rule 69 (term9 -> term10 .)
    until           reduce using rule 69 (term9 -> term10 .)
    case            reduce using rule 69 (term9 -> term10 .)
    for             reduce using rule 69 (term9 -> term10 .)
    return          reduce using rule 69 (term9 -> term10 .)
    IDENTIFIER      reduce using rule 69 (term9 -> term10 .)
    nil             reduce using rule 69 (term9 -> term10 .)
    self            reduce using rule 69 (term9 -> term10 .)
    GLOBAL          reduce using rule 69 (term9 -> term10 .)
    OPEN_BRACKET    reduce using rule 69 (term9 -> term10 .)
    Array           reduce using rule 69 (term9 -> term10 .)
    NUMBER          reduce using rule 69 (term9 -> term10 .)
    true            reduce using rule 69 (term9 -> term10 .)
    false           reduce using rule 69 (term9 -> term10 .)
    $end            reduce using rule 69 (term9 -> term10 .)
    CLOSE_BRACKET   reduce using rule 69 (term9 -> term10 .)
    when            reduce using rule 69 (term9 -> term10 .)
    then            reduce using rule 69 (term9 -> term10 .)
    else            reduce using rule 69 (term9 -> term10 .)
    end             reduce using rule 69 (term9 -> term10 .)
    elsif           reduce using rule 69 (term9 -> term10 .)
    do              reduce using rule 69 (term9 -> term10 .)
    COMMA           reduce using rule 69 (term9 -> term10 .)
    DOUBLE_EQUALS   reduce using rule 69 (term9 -> term10 .)
    NOT_EQUALS      reduce using rule 69 (term9 -> term10 .)
    EQUAL_TILDE     reduce using rule 69 (term9 -> term10 .)
    COMPARISON      reduce using rule 69 (term9 -> term10 .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 86
    MODULO          shift and go to state 85


state 14

    (61) term6 -> term7 .
    (62) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 61 (term6 -> term7 .)
    BIT_OR          reduce using rule 61 (term6 -> term7 .)
    DOUBLE_EQUALS   reduce using rule 61 (term6 -> term7 .)
    NOT_EQUALS      reduce using rule 61 (term6 -> term7 .)
    EQUAL_TILDE     reduce using rule 61 (term6 -> term7 .)
    COMPARISON      reduce using rule 61 (term6 -> term7 .)
    LESS            reduce using rule 61 (term6 -> term7 .)
    LESS_EQUALS     reduce using rule 61 (term6 -> term7 .)
    GREATER         reduce using rule 61 (term6 -> term7 .)
    GREATER_EQUALS  reduce using rule 61 (term6 -> term7 .)
    INCL_RANGE      reduce using rule 61 (term6 -> term7 .)
    EXCL_RANGE      reduce using rule 61 (term6 -> term7 .)
    LOGICAL_OR      reduce using rule 61 (term6 -> term7 .)
    LOGICAL_AND     reduce using rule 61 (term6 -> term7 .)
    COMMA           reduce using rule 61 (term6 -> term7 .)
    CLOSE_BRACKET   reduce using rule 61 (term6 -> term7 .)
    SEMI_COLON      reduce using rule 61 (term6 -> term7 .)
    NEWLINE         reduce using rule 61 (term6 -> term7 .)
    puts            reduce using rule 61 (term6 -> term7 .)
    print           reduce using rule 61 (term6 -> term7 .)
    gets            reduce using rule 61 (term6 -> term7 .)
    break           reduce using rule 61 (term6 -> term7 .)
    def             reduce using rule 61 (term6 -> term7 .)
    class           reduce using rule 61 (term6 -> term7 .)
    if              reduce using rule 61 (term6 -> term7 .)
    while           reduce using rule 61 (term6 -> term7 .)
    until           reduce using rule 61 (term6 -> term7 .)
    case            reduce using rule 61 (term6 -> term7 .)
    for             reduce using rule 61 (term6 -> term7 .)
    return          reduce using rule 61 (term6 -> term7 .)
    IDENTIFIER      reduce using rule 61 (term6 -> term7 .)
    nil             reduce using rule 61 (term6 -> term7 .)
    self            reduce using rule 61 (term6 -> term7 .)
    GLOBAL          reduce using rule 61 (term6 -> term7 .)
    MINUS           reduce using rule 61 (term6 -> term7 .)
    PLUS            reduce using rule 61 (term6 -> term7 .)
    OPEN_BRACKET    reduce using rule 61 (term6 -> term7 .)
    Array           reduce using rule 61 (term6 -> term7 .)
    NUMBER          reduce using rule 61 (term6 -> term7 .)
    true            reduce using rule 61 (term6 -> term7 .)
    false           reduce using rule 61 (term6 -> term7 .)
    end             reduce using rule 61 (term6 -> term7 .)
    $end            reduce using rule 61 (term6 -> term7 .)
    when            reduce using rule 61 (term6 -> term7 .)
    then            reduce using rule 61 (term6 -> term7 .)
    else            reduce using rule 61 (term6 -> term7 .)
    elsif           reduce using rule 61 (term6 -> term7 .)
    do              reduce using rule 61 (term6 -> term7 .)
    BIT_AND         shift and go to state 87


state 15

    (58) term5 -> term6 .
    (59) term6 -> term6 . BIT_XOR term7
    (60) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 58 (term5 -> term6 .)
    NOT_EQUALS      reduce using rule 58 (term5 -> term6 .)
    EQUAL_TILDE     reduce using rule 58 (term5 -> term6 .)
    COMPARISON      reduce using rule 58 (term5 -> term6 .)
    LESS            reduce using rule 58 (term5 -> term6 .)
    LESS_EQUALS     reduce using rule 58 (term5 -> term6 .)
    GREATER         reduce using rule 58 (term5 -> term6 .)
    GREATER_EQUALS  reduce using rule 58 (term5 -> term6 .)
    INCL_RANGE      reduce using rule 58 (term5 -> term6 .)
    EXCL_RANGE      reduce using rule 58 (term5 -> term6 .)
    LOGICAL_OR      reduce using rule 58 (term5 -> term6 .)
    LOGICAL_AND     reduce using rule 58 (term5 -> term6 .)
    SEMI_COLON      reduce using rule 58 (term5 -> term6 .)
    NEWLINE         reduce using rule 58 (term5 -> term6 .)
    puts            reduce using rule 58 (term5 -> term6 .)
    print           reduce using rule 58 (term5 -> term6 .)
    gets            reduce using rule 58 (term5 -> term6 .)
    break           reduce using rule 58 (term5 -> term6 .)
    def             reduce using rule 58 (term5 -> term6 .)
    class           reduce using rule 58 (term5 -> term6 .)
    if              reduce using rule 58 (term5 -> term6 .)
    while           reduce using rule 58 (term5 -> term6 .)
    until           reduce using rule 58 (term5 -> term6 .)
    case            reduce using rule 58 (term5 -> term6 .)
    for             reduce using rule 58 (term5 -> term6 .)
    return          reduce using rule 58 (term5 -> term6 .)
    IDENTIFIER      reduce using rule 58 (term5 -> term6 .)
    nil             reduce using rule 58 (term5 -> term6 .)
    self            reduce using rule 58 (term5 -> term6 .)
    GLOBAL          reduce using rule 58 (term5 -> term6 .)
    MINUS           reduce using rule 58 (term5 -> term6 .)
    PLUS            reduce using rule 58 (term5 -> term6 .)
    OPEN_BRACKET    reduce using rule 58 (term5 -> term6 .)
    Array           reduce using rule 58 (term5 -> term6 .)
    NUMBER          reduce using rule 58 (term5 -> term6 .)
    true            reduce using rule 58 (term5 -> term6 .)
    false           reduce using rule 58 (term5 -> term6 .)
    end             reduce using rule 58 (term5 -> term6 .)
    else            reduce using rule 58 (term5 -> term6 .)
    elsif           reduce using rule 58 (term5 -> term6 .)
    when            reduce using rule 58 (term5 -> term6 .)
    COMMA           reduce using rule 58 (term5 -> term6 .)
    CLOSE_BRACKET   reduce using rule 58 (term5 -> term6 .)
    $end            reduce using rule 58 (term5 -> term6 .)
    do              reduce using rule 58 (term5 -> term6 .)
    then            reduce using rule 58 (term5 -> term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 16

    (49) term4 -> term5 . DOUBLE_EQUALS term5
    (50) term4 -> term5 . NOT_EQUALS term5
    (51) term4 -> term5 . EQUAL_TILDE term5
    (52) term4 -> term5 . COMPARISON term5
    (53) term4 -> term5 .
    (54) term5 -> term5 . LESS term6
    (55) term5 -> term5 . LESS_EQUALS term6
    (56) term5 -> term5 . GREATER term6
    (57) term5 -> term5 . GREATER_EQUALS term6

    DOUBLE_EQUALS   shift and go to state 91
    NOT_EQUALS      shift and go to state 94
    EQUAL_TILDE     shift and go to state 96
    COMPARISON      shift and go to state 90
    INCL_RANGE      reduce using rule 53 (term4 -> term5 .)
    EXCL_RANGE      reduce using rule 53 (term4 -> term5 .)
    LOGICAL_OR      reduce using rule 53 (term4 -> term5 .)
    LOGICAL_AND     reduce using rule 53 (term4 -> term5 .)
    SEMI_COLON      reduce using rule 53 (term4 -> term5 .)
    NEWLINE         reduce using rule 53 (term4 -> term5 .)
    puts            reduce using rule 53 (term4 -> term5 .)
    print           reduce using rule 53 (term4 -> term5 .)
    gets            reduce using rule 53 (term4 -> term5 .)
    break           reduce using rule 53 (term4 -> term5 .)
    def             reduce using rule 53 (term4 -> term5 .)
    class           reduce using rule 53 (term4 -> term5 .)
    if              reduce using rule 53 (term4 -> term5 .)
    while           reduce using rule 53 (term4 -> term5 .)
    until           reduce using rule 53 (term4 -> term5 .)
    case            reduce using rule 53 (term4 -> term5 .)
    for             reduce using rule 53 (term4 -> term5 .)
    return          reduce using rule 53 (term4 -> term5 .)
    IDENTIFIER      reduce using rule 53 (term4 -> term5 .)
    nil             reduce using rule 53 (term4 -> term5 .)
    self            reduce using rule 53 (term4 -> term5 .)
    GLOBAL          reduce using rule 53 (term4 -> term5 .)
    MINUS           reduce using rule 53 (term4 -> term5 .)
    PLUS            reduce using rule 53 (term4 -> term5 .)
    OPEN_BRACKET    reduce using rule 53 (term4 -> term5 .)
    Array           reduce using rule 53 (term4 -> term5 .)
    NUMBER          reduce using rule 53 (term4 -> term5 .)
    true            reduce using rule 53 (term4 -> term5 .)
    false           reduce using rule 53 (term4 -> term5 .)
    elsif           reduce using rule 53 (term4 -> term5 .)
    else            reduce using rule 53 (term4 -> term5 .)
    end             reduce using rule 53 (term4 -> term5 .)
    do              reduce using rule 53 (term4 -> term5 .)
    $end            reduce using rule 53 (term4 -> term5 .)
    CLOSE_BRACKET   reduce using rule 53 (term4 -> term5 .)
    when            reduce using rule 53 (term4 -> term5 .)
    then            reduce using rule 53 (term4 -> term5 .)
    COMMA           reduce using rule 53 (term4 -> term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 17

    (10) stmt -> keyclass . IDENTIFIER newline multstmt keyend

    IDENTIFIER      shift and go to state 98


state 18

    (43) term2 -> term3 . INCL_RANGE term3
    (44) term2 -> term3 . EXCL_RANGE term3
    (45) term2 -> term3 .
    (46) term3 -> term3 . LOGICAL_OR term4
    (47) term3 -> term3 . LOGICAL_AND term4

    INCL_RANGE      shift and go to state 100
    EXCL_RANGE      shift and go to state 99
    COMMA           reduce using rule 45 (term2 -> term3 .)
    CLOSE_BRACKET   reduce using rule 45 (term2 -> term3 .)
    SEMI_COLON      reduce using rule 45 (term2 -> term3 .)
    NEWLINE         reduce using rule 45 (term2 -> term3 .)
    puts            reduce using rule 45 (term2 -> term3 .)
    print           reduce using rule 45 (term2 -> term3 .)
    gets            reduce using rule 45 (term2 -> term3 .)
    break           reduce using rule 45 (term2 -> term3 .)
    def             reduce using rule 45 (term2 -> term3 .)
    class           reduce using rule 45 (term2 -> term3 .)
    if              reduce using rule 45 (term2 -> term3 .)
    while           reduce using rule 45 (term2 -> term3 .)
    until           reduce using rule 45 (term2 -> term3 .)
    case            reduce using rule 45 (term2 -> term3 .)
    for             reduce using rule 45 (term2 -> term3 .)
    return          reduce using rule 45 (term2 -> term3 .)
    IDENTIFIER      reduce using rule 45 (term2 -> term3 .)
    nil             reduce using rule 45 (term2 -> term3 .)
    self            reduce using rule 45 (term2 -> term3 .)
    GLOBAL          reduce using rule 45 (term2 -> term3 .)
    MINUS           reduce using rule 45 (term2 -> term3 .)
    PLUS            reduce using rule 45 (term2 -> term3 .)
    OPEN_BRACKET    reduce using rule 45 (term2 -> term3 .)
    Array           reduce using rule 45 (term2 -> term3 .)
    NUMBER          reduce using rule 45 (term2 -> term3 .)
    true            reduce using rule 45 (term2 -> term3 .)
    false           reduce using rule 45 (term2 -> term3 .)
    $end            reduce using rule 45 (term2 -> term3 .)
    elsif           reduce using rule 45 (term2 -> term3 .)
    else            reduce using rule 45 (term2 -> term3 .)
    end             reduce using rule 45 (term2 -> term3 .)
    when            reduce using rule 45 (term2 -> term3 .)
    do              reduce using rule 45 (term2 -> term3 .)
    then            reduce using rule 45 (term2 -> term3 .)
    LOGICAL_OR      shift and go to state 101
    LOGICAL_AND     shift and go to state 102


state 19

    (42) term1 -> term2 .

    SEMI_COLON      reduce using rule 42 (term1 -> term2 .)
    NEWLINE         reduce using rule 42 (term1 -> term2 .)
    when            reduce using rule 42 (term1 -> term2 .)
    puts            reduce using rule 42 (term1 -> term2 .)
    print           reduce using rule 42 (term1 -> term2 .)
    gets            reduce using rule 42 (term1 -> term2 .)
    break           reduce using rule 42 (term1 -> term2 .)
    def             reduce using rule 42 (term1 -> term2 .)
    class           reduce using rule 42 (term1 -> term2 .)
    if              reduce using rule 42 (term1 -> term2 .)
    while           reduce using rule 42 (term1 -> term2 .)
    until           reduce using rule 42 (term1 -> term2 .)
    case            reduce using rule 42 (term1 -> term2 .)
    for             reduce using rule 42 (term1 -> term2 .)
    return          reduce using rule 42 (term1 -> term2 .)
    IDENTIFIER      reduce using rule 42 (term1 -> term2 .)
    nil             reduce using rule 42 (term1 -> term2 .)
    self            reduce using rule 42 (term1 -> term2 .)
    GLOBAL          reduce using rule 42 (term1 -> term2 .)
    MINUS           reduce using rule 42 (term1 -> term2 .)
    PLUS            reduce using rule 42 (term1 -> term2 .)
    OPEN_BRACKET    reduce using rule 42 (term1 -> term2 .)
    Array           reduce using rule 42 (term1 -> term2 .)
    NUMBER          reduce using rule 42 (term1 -> term2 .)
    true            reduce using rule 42 (term1 -> term2 .)
    false           reduce using rule 42 (term1 -> term2 .)
    end             reduce using rule 42 (term1 -> term2 .)
    $end            reduce using rule 42 (term1 -> term2 .)
    then            reduce using rule 42 (term1 -> term2 .)
    elsif           reduce using rule 42 (term1 -> term2 .)
    else            reduce using rule 42 (term1 -> term2 .)
    do              reduce using rule 42 (term1 -> term2 .)
    CLOSE_BRACKET   reduce using rule 42 (term1 -> term2 .)


state 20

    (39) term0 -> term1 .

    SEMI_COLON      reduce using rule 39 (term0 -> term1 .)
    NEWLINE         reduce using rule 39 (term0 -> term1 .)
    puts            reduce using rule 39 (term0 -> term1 .)
    print           reduce using rule 39 (term0 -> term1 .)
    gets            reduce using rule 39 (term0 -> term1 .)
    break           reduce using rule 39 (term0 -> term1 .)
    def             reduce using rule 39 (term0 -> term1 .)
    class           reduce using rule 39 (term0 -> term1 .)
    if              reduce using rule 39 (term0 -> term1 .)
    while           reduce using rule 39 (term0 -> term1 .)
    until           reduce using rule 39 (term0 -> term1 .)
    case            reduce using rule 39 (term0 -> term1 .)
    for             reduce using rule 39 (term0 -> term1 .)
    return          reduce using rule 39 (term0 -> term1 .)
    IDENTIFIER      reduce using rule 39 (term0 -> term1 .)
    nil             reduce using rule 39 (term0 -> term1 .)
    self            reduce using rule 39 (term0 -> term1 .)
    GLOBAL          reduce using rule 39 (term0 -> term1 .)
    MINUS           reduce using rule 39 (term0 -> term1 .)
    PLUS            reduce using rule 39 (term0 -> term1 .)
    OPEN_BRACKET    reduce using rule 39 (term0 -> term1 .)
    Array           reduce using rule 39 (term0 -> term1 .)
    NUMBER          reduce using rule 39 (term0 -> term1 .)
    true            reduce using rule 39 (term0 -> term1 .)
    false           reduce using rule 39 (term0 -> term1 .)
    $end            reduce using rule 39 (term0 -> term1 .)
    do              reduce using rule 39 (term0 -> term1 .)
    end             reduce using rule 39 (term0 -> term1 .)
    then            reduce using rule 39 (term0 -> term1 .)
    else            reduce using rule 39 (term0 -> term1 .)
    elsif           reduce using rule 39 (term0 -> term1 .)
    when            reduce using rule 39 (term0 -> term1 .)
    CLOSE_BRACKET   reduce using rule 39 (term0 -> term1 .)


state 21

    (35) arg -> term0 .

    SEMI_COLON      reduce using rule 35 (arg -> term0 .)
    NEWLINE         reduce using rule 35 (arg -> term0 .)
    puts            reduce using rule 35 (arg -> term0 .)
    print           reduce using rule 35 (arg -> term0 .)
    gets            reduce using rule 35 (arg -> term0 .)
    break           reduce using rule 35 (arg -> term0 .)
    def             reduce using rule 35 (arg -> term0 .)
    class           reduce using rule 35 (arg -> term0 .)
    if              reduce using rule 35 (arg -> term0 .)
    while           reduce using rule 35 (arg -> term0 .)
    until           reduce using rule 35 (arg -> term0 .)
    case            reduce using rule 35 (arg -> term0 .)
    for             reduce using rule 35 (arg -> term0 .)
    return          reduce using rule 35 (arg -> term0 .)
    IDENTIFIER      reduce using rule 35 (arg -> term0 .)
    nil             reduce using rule 35 (arg -> term0 .)
    self            reduce using rule 35 (arg -> term0 .)
    GLOBAL          reduce using rule 35 (arg -> term0 .)
    MINUS           reduce using rule 35 (arg -> term0 .)
    PLUS            reduce using rule 35 (arg -> term0 .)
    OPEN_BRACKET    reduce using rule 35 (arg -> term0 .)
    Array           reduce using rule 35 (arg -> term0 .)
    NUMBER          reduce using rule 35 (arg -> term0 .)
    true            reduce using rule 35 (arg -> term0 .)
    false           reduce using rule 35 (arg -> term0 .)
    $end            reduce using rule 35 (arg -> term0 .)
    when            reduce using rule 35 (arg -> term0 .)
    do              reduce using rule 35 (arg -> term0 .)
    end             reduce using rule 35 (arg -> term0 .)
    elsif           reduce using rule 35 (arg -> term0 .)
    else            reduce using rule 35 (arg -> term0 .)
    CLOSE_BRACKET   reduce using rule 35 (arg -> term0 .)
    then            reduce using rule 35 (arg -> term0 .)


state 22

    (66) term8 -> term9 .
    (67) term9 -> term9 . PLUS term10
    (68) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 66 (term8 -> term9 .)
    RIGHT_SHIFT     reduce using rule 66 (term8 -> term9 .)
    BIT_AND         reduce using rule 66 (term8 -> term9 .)
    BIT_XOR         reduce using rule 66 (term8 -> term9 .)
    BIT_OR          reduce using rule 66 (term8 -> term9 .)
    DOUBLE_EQUALS   reduce using rule 66 (term8 -> term9 .)
    NOT_EQUALS      reduce using rule 66 (term8 -> term9 .)
    EQUAL_TILDE     reduce using rule 66 (term8 -> term9 .)
    COMPARISON      reduce using rule 66 (term8 -> term9 .)
    LESS            reduce using rule 66 (term8 -> term9 .)
    LESS_EQUALS     reduce using rule 66 (term8 -> term9 .)
    GREATER         reduce using rule 66 (term8 -> term9 .)
    GREATER_EQUALS  reduce using rule 66 (term8 -> term9 .)
    LOGICAL_OR      reduce using rule 66 (term8 -> term9 .)
    LOGICAL_AND     reduce using rule 66 (term8 -> term9 .)
    SEMI_COLON      reduce using rule 66 (term8 -> term9 .)
    NEWLINE         reduce using rule 66 (term8 -> term9 .)
    puts            reduce using rule 66 (term8 -> term9 .)
    print           reduce using rule 66 (term8 -> term9 .)
    gets            reduce using rule 66 (term8 -> term9 .)
    break           reduce using rule 66 (term8 -> term9 .)
    def             reduce using rule 66 (term8 -> term9 .)
    class           reduce using rule 66 (term8 -> term9 .)
    if              reduce using rule 66 (term8 -> term9 .)
    while           reduce using rule 66 (term8 -> term9 .)
    until           reduce using rule 66 (term8 -> term9 .)
    case            reduce using rule 66 (term8 -> term9 .)
    for             reduce using rule 66 (term8 -> term9 .)
    return          reduce using rule 66 (term8 -> term9 .)
    IDENTIFIER      reduce using rule 66 (term8 -> term9 .)
    nil             reduce using rule 66 (term8 -> term9 .)
    self            reduce using rule 66 (term8 -> term9 .)
    GLOBAL          reduce using rule 66 (term8 -> term9 .)
    OPEN_BRACKET    reduce using rule 66 (term8 -> term9 .)
    Array           reduce using rule 66 (term8 -> term9 .)
    NUMBER          reduce using rule 66 (term8 -> term9 .)
    true            reduce using rule 66 (term8 -> term9 .)
    false           reduce using rule 66 (term8 -> term9 .)
    $end            reduce using rule 66 (term8 -> term9 .)
    CLOSE_BRACKET   reduce using rule 66 (term8 -> term9 .)
    when            reduce using rule 66 (term8 -> term9 .)
    then            reduce using rule 66 (term8 -> term9 .)
    else            reduce using rule 66 (term8 -> term9 .)
    end             reduce using rule 66 (term8 -> term9 .)
    elsif           reduce using rule 66 (term8 -> term9 .)
    do              reduce using rule 66 (term8 -> term9 .)
    COMMA           reduce using rule 66 (term8 -> term9 .)
    INCL_RANGE      reduce using rule 66 (term8 -> term9 .)
    EXCL_RANGE      reduce using rule 66 (term8 -> term9 .)
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104

  ! MINUS           [ reduce using rule 66 (term8 -> term9 .) ]
  ! PLUS            [ reduce using rule 66 (term8 -> term9 .) ]


state 23

    (63) term7 -> term8 .
    (64) term8 -> term8 . LEFT_SHIFT term9
    (65) term8 -> term8 . RIGHT_SHIFT term9

    BIT_AND         reduce using rule 63 (term7 -> term8 .)
    BIT_XOR         reduce using rule 63 (term7 -> term8 .)
    BIT_OR          reduce using rule 63 (term7 -> term8 .)
    DOUBLE_EQUALS   reduce using rule 63 (term7 -> term8 .)
    NOT_EQUALS      reduce using rule 63 (term7 -> term8 .)
    EQUAL_TILDE     reduce using rule 63 (term7 -> term8 .)
    COMPARISON      reduce using rule 63 (term7 -> term8 .)
    LESS            reduce using rule 63 (term7 -> term8 .)
    LESS_EQUALS     reduce using rule 63 (term7 -> term8 .)
    GREATER         reduce using rule 63 (term7 -> term8 .)
    GREATER_EQUALS  reduce using rule 63 (term7 -> term8 .)
    INCL_RANGE      reduce using rule 63 (term7 -> term8 .)
    EXCL_RANGE      reduce using rule 63 (term7 -> term8 .)
    LOGICAL_OR      reduce using rule 63 (term7 -> term8 .)
    LOGICAL_AND     reduce using rule 63 (term7 -> term8 .)
    SEMI_COLON      reduce using rule 63 (term7 -> term8 .)
    NEWLINE         reduce using rule 63 (term7 -> term8 .)
    puts            reduce using rule 63 (term7 -> term8 .)
    print           reduce using rule 63 (term7 -> term8 .)
    gets            reduce using rule 63 (term7 -> term8 .)
    break           reduce using rule 63 (term7 -> term8 .)
    def             reduce using rule 63 (term7 -> term8 .)
    class           reduce using rule 63 (term7 -> term8 .)
    if              reduce using rule 63 (term7 -> term8 .)
    while           reduce using rule 63 (term7 -> term8 .)
    until           reduce using rule 63 (term7 -> term8 .)
    case            reduce using rule 63 (term7 -> term8 .)
    for             reduce using rule 63 (term7 -> term8 .)
    return          reduce using rule 63 (term7 -> term8 .)
    IDENTIFIER      reduce using rule 63 (term7 -> term8 .)
    nil             reduce using rule 63 (term7 -> term8 .)
    self            reduce using rule 63 (term7 -> term8 .)
    GLOBAL          reduce using rule 63 (term7 -> term8 .)
    MINUS           reduce using rule 63 (term7 -> term8 .)
    PLUS            reduce using rule 63 (term7 -> term8 .)
    OPEN_BRACKET    reduce using rule 63 (term7 -> term8 .)
    Array           reduce using rule 63 (term7 -> term8 .)
    NUMBER          reduce using rule 63 (term7 -> term8 .)
    true            reduce using rule 63 (term7 -> term8 .)
    false           reduce using rule 63 (term7 -> term8 .)
    $end            reduce using rule 63 (term7 -> term8 .)
    when            reduce using rule 63 (term7 -> term8 .)
    then            reduce using rule 63 (term7 -> term8 .)
    else            reduce using rule 63 (term7 -> term8 .)
    end             reduce using rule 63 (term7 -> term8 .)
    elsif           reduce using rule 63 (term7 -> term8 .)
    do              reduce using rule 63 (term7 -> term8 .)
    CLOSE_BRACKET   reduce using rule 63 (term7 -> term8 .)
    COMMA           reduce using rule 63 (term7 -> term8 .)
    LEFT_SHIFT      shift and go to state 106
    RIGHT_SHIFT     shift and go to state 105


state 24

    (138) newline -> SEMI_COLON .

    puts            reduce using rule 138 (newline -> SEMI_COLON .)
    print           reduce using rule 138 (newline -> SEMI_COLON .)
    gets            reduce using rule 138 (newline -> SEMI_COLON .)
    break           reduce using rule 138 (newline -> SEMI_COLON .)
    def             reduce using rule 138 (newline -> SEMI_COLON .)
    class           reduce using rule 138 (newline -> SEMI_COLON .)
    if              reduce using rule 138 (newline -> SEMI_COLON .)
    while           reduce using rule 138 (newline -> SEMI_COLON .)
    until           reduce using rule 138 (newline -> SEMI_COLON .)
    case            reduce using rule 138 (newline -> SEMI_COLON .)
    for             reduce using rule 138 (newline -> SEMI_COLON .)
    return          reduce using rule 138 (newline -> SEMI_COLON .)
    IDENTIFIER      reduce using rule 138 (newline -> SEMI_COLON .)
    nil             reduce using rule 138 (newline -> SEMI_COLON .)
    self            reduce using rule 138 (newline -> SEMI_COLON .)
    GLOBAL          reduce using rule 138 (newline -> SEMI_COLON .)
    MINUS           reduce using rule 138 (newline -> SEMI_COLON .)
    PLUS            reduce using rule 138 (newline -> SEMI_COLON .)
    OPEN_BRACKET    reduce using rule 138 (newline -> SEMI_COLON .)
    Array           reduce using rule 138 (newline -> SEMI_COLON .)
    NUMBER          reduce using rule 138 (newline -> SEMI_COLON .)
    true            reduce using rule 138 (newline -> SEMI_COLON .)
    false           reduce using rule 138 (newline -> SEMI_COLON .)
    $end            reduce using rule 138 (newline -> SEMI_COLON .)
    then            reduce using rule 138 (newline -> SEMI_COLON .)
    when            reduce using rule 138 (newline -> SEMI_COLON .)
    end             reduce using rule 138 (newline -> SEMI_COLON .)
    do              reduce using rule 138 (newline -> SEMI_COLON .)
    else            reduce using rule 138 (newline -> SEMI_COLON .)
    elsif           reduce using rule 138 (newline -> SEMI_COLON .)


state 25

    (30) expr2 -> arg .

    do              reduce using rule 30 (expr2 -> arg .)
    SEMI_COLON      reduce using rule 30 (expr2 -> arg .)
    NEWLINE         reduce using rule 30 (expr2 -> arg .)
    puts            reduce using rule 30 (expr2 -> arg .)
    print           reduce using rule 30 (expr2 -> arg .)
    gets            reduce using rule 30 (expr2 -> arg .)
    break           reduce using rule 30 (expr2 -> arg .)
    def             reduce using rule 30 (expr2 -> arg .)
    class           reduce using rule 30 (expr2 -> arg .)
    if              reduce using rule 30 (expr2 -> arg .)
    while           reduce using rule 30 (expr2 -> arg .)
    until           reduce using rule 30 (expr2 -> arg .)
    case            reduce using rule 30 (expr2 -> arg .)
    for             reduce using rule 30 (expr2 -> arg .)
    return          reduce using rule 30 (expr2 -> arg .)
    IDENTIFIER      reduce using rule 30 (expr2 -> arg .)
    nil             reduce using rule 30 (expr2 -> arg .)
    self            reduce using rule 30 (expr2 -> arg .)
    GLOBAL          reduce using rule 30 (expr2 -> arg .)
    MINUS           reduce using rule 30 (expr2 -> arg .)
    PLUS            reduce using rule 30 (expr2 -> arg .)
    OPEN_BRACKET    reduce using rule 30 (expr2 -> arg .)
    Array           reduce using rule 30 (expr2 -> arg .)
    NUMBER          reduce using rule 30 (expr2 -> arg .)
    true            reduce using rule 30 (expr2 -> arg .)
    false           reduce using rule 30 (expr2 -> arg .)
    end             reduce using rule 30 (expr2 -> arg .)
    then            reduce using rule 30 (expr2 -> arg .)
    elsif           reduce using rule 30 (expr2 -> arg .)
    else            reduce using rule 30 (expr2 -> arg .)
    when            reduce using rule 30 (expr2 -> arg .)
    $end            reduce using rule 30 (expr2 -> arg .)
    CLOSE_BRACKET   reduce using rule 30 (expr2 -> arg .)


state 26

    (24) expr -> for . M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 107
    empty                          shift and go to state 108

state 27

    (8) stmt -> print . OPEN_BRACKET primary CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 109


state 28

    (5) stmt1 -> stmt .

    SEMI_COLON      reduce using rule 5 (stmt1 -> stmt .)
    NEWLINE         reduce using rule 5 (stmt1 -> stmt .)
    puts            reduce using rule 5 (stmt1 -> stmt .)
    print           reduce using rule 5 (stmt1 -> stmt .)
    gets            reduce using rule 5 (stmt1 -> stmt .)
    break           reduce using rule 5 (stmt1 -> stmt .)
    def             reduce using rule 5 (stmt1 -> stmt .)
    class           reduce using rule 5 (stmt1 -> stmt .)
    if              reduce using rule 5 (stmt1 -> stmt .)
    while           reduce using rule 5 (stmt1 -> stmt .)
    until           reduce using rule 5 (stmt1 -> stmt .)
    case            reduce using rule 5 (stmt1 -> stmt .)
    for             reduce using rule 5 (stmt1 -> stmt .)
    return          reduce using rule 5 (stmt1 -> stmt .)
    IDENTIFIER      reduce using rule 5 (stmt1 -> stmt .)
    nil             reduce using rule 5 (stmt1 -> stmt .)
    self            reduce using rule 5 (stmt1 -> stmt .)
    GLOBAL          reduce using rule 5 (stmt1 -> stmt .)
    MINUS           reduce using rule 5 (stmt1 -> stmt .)
    PLUS            reduce using rule 5 (stmt1 -> stmt .)
    OPEN_BRACKET    reduce using rule 5 (stmt1 -> stmt .)
    Array           reduce using rule 5 (stmt1 -> stmt .)
    NUMBER          reduce using rule 5 (stmt1 -> stmt .)
    true            reduce using rule 5 (stmt1 -> stmt .)
    false           reduce using rule 5 (stmt1 -> stmt .)
    $end            reduce using rule 5 (stmt1 -> stmt .)


state 29

    (0) S' -> compstmt .



state 30

    (117) variable -> varname .
    (84) primary -> varname .

    OPEN_SQUARE     reduce using rule 117 (variable -> varname .)
    MULTIPLY        reduce using rule 84 (primary -> varname .)
    DIVIDE          reduce using rule 84 (primary -> varname .)
    MODULO          reduce using rule 84 (primary -> varname .)
    PLUS            reduce using rule 84 (primary -> varname .)
    MINUS           reduce using rule 84 (primary -> varname .)
    LEFT_SHIFT      reduce using rule 84 (primary -> varname .)
    RIGHT_SHIFT     reduce using rule 84 (primary -> varname .)
    BIT_AND         reduce using rule 84 (primary -> varname .)
    BIT_XOR         reduce using rule 84 (primary -> varname .)
    BIT_OR          reduce using rule 84 (primary -> varname .)
    DOUBLE_EQUALS   reduce using rule 84 (primary -> varname .)
    NOT_EQUALS      reduce using rule 84 (primary -> varname .)
    EQUAL_TILDE     reduce using rule 84 (primary -> varname .)
    COMPARISON      reduce using rule 84 (primary -> varname .)
    LESS            reduce using rule 84 (primary -> varname .)
    LESS_EQUALS     reduce using rule 84 (primary -> varname .)
    GREATER         reduce using rule 84 (primary -> varname .)
    GREATER_EQUALS  reduce using rule 84 (primary -> varname .)
    INCL_RANGE      reduce using rule 84 (primary -> varname .)
    EXCL_RANGE      reduce using rule 84 (primary -> varname .)
    LOGICAL_OR      reduce using rule 84 (primary -> varname .)
    LOGICAL_AND     reduce using rule 84 (primary -> varname .)
    do              reduce using rule 84 (primary -> varname .)
    SEMI_COLON      reduce using rule 84 (primary -> varname .)
    NEWLINE         reduce using rule 84 (primary -> varname .)
    puts            reduce using rule 84 (primary -> varname .)
    print           reduce using rule 84 (primary -> varname .)
    gets            reduce using rule 84 (primary -> varname .)
    break           reduce using rule 84 (primary -> varname .)
    def             reduce using rule 84 (primary -> varname .)
    class           reduce using rule 84 (primary -> varname .)
    if              reduce using rule 84 (primary -> varname .)
    while           reduce using rule 84 (primary -> varname .)
    until           reduce using rule 84 (primary -> varname .)
    case            reduce using rule 84 (primary -> varname .)
    for             reduce using rule 84 (primary -> varname .)
    return          reduce using rule 84 (primary -> varname .)
    IDENTIFIER      reduce using rule 84 (primary -> varname .)
    nil             reduce using rule 84 (primary -> varname .)
    self            reduce using rule 84 (primary -> varname .)
    GLOBAL          reduce using rule 84 (primary -> varname .)
    OPEN_BRACKET    reduce using rule 84 (primary -> varname .)
    Array           reduce using rule 84 (primary -> varname .)
    NUMBER          reduce using rule 84 (primary -> varname .)
    true            reduce using rule 84 (primary -> varname .)
    false           reduce using rule 84 (primary -> varname .)
    end             reduce using rule 84 (primary -> varname .)
    CLOSE_BRACKET   reduce using rule 84 (primary -> varname .)
    when            reduce using rule 84 (primary -> varname .)
    then            reduce using rule 84 (primary -> varname .)
    else            reduce using rule 84 (primary -> varname .)
    elsif           reduce using rule 84 (primary -> varname .)
    $end            reduce using rule 84 (primary -> varname .)


state 31

    (3) multcompstmt -> stmt1 . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (5) stmt1 -> . stmt
    (141) empty -> .
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

  ! shift/reduce conflict for puts resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for gets resolved as shift
  ! shift/reduce conflict for break resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for while resolved as shift
  ! shift/reduce conflict for until resolved as shift
  ! shift/reduce conflict for case resolved as shift
  ! shift/reduce conflict for for resolved as shift
  ! shift/reduce conflict for return resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for nil resolved as shift
  ! shift/reduce conflict for self resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
  ! shift/reduce conflict for Array resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for true resolved as shift
  ! shift/reduce conflict for false resolved as shift
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    $end            reduce using rule 141 (empty -> .)
    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

  ! puts            [ reduce using rule 141 (empty -> .) ]
  ! print           [ reduce using rule 141 (empty -> .) ]
  ! gets            [ reduce using rule 141 (empty -> .) ]
  ! break           [ reduce using rule 141 (empty -> .) ]
  ! def             [ reduce using rule 141 (empty -> .) ]
  ! class           [ reduce using rule 141 (empty -> .) ]
  ! if              [ reduce using rule 141 (empty -> .) ]
  ! while           [ reduce using rule 141 (empty -> .) ]
  ! until           [ reduce using rule 141 (empty -> .) ]
  ! case            [ reduce using rule 141 (empty -> .) ]
  ! for             [ reduce using rule 141 (empty -> .) ]
  ! return          [ reduce using rule 141 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 141 (empty -> .) ]
  ! nil             [ reduce using rule 141 (empty -> .) ]
  ! self            [ reduce using rule 141 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 141 (empty -> .) ]
  ! MINUS           [ reduce using rule 141 (empty -> .) ]
  ! PLUS            [ reduce using rule 141 (empty -> .) ]
  ! OPEN_BRACKET    [ reduce using rule 141 (empty -> .) ]
  ! Array           [ reduce using rule 141 (empty -> .) ]
  ! NUMBER          [ reduce using rule 141 (empty -> .) ]
  ! true            [ reduce using rule 141 (empty -> .) ]
  ! false           [ reduce using rule 141 (empty -> .) ]

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 41
    function                       shift and go to state 42
    newline                        shift and go to state 59
    multcompstmt                   shift and go to state 110
    stmt                           shift and go to state 28
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    stmt1                          shift and go to state 31
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 32

    (136) varname -> GLOBAL .

    OPEN_SQUARE     reduce using rule 136 (varname -> GLOBAL .)
    MULTIPLY        reduce using rule 136 (varname -> GLOBAL .)
    DIVIDE          reduce using rule 136 (varname -> GLOBAL .)
    MODULO          reduce using rule 136 (varname -> GLOBAL .)
    PLUS            reduce using rule 136 (varname -> GLOBAL .)
    MINUS           reduce using rule 136 (varname -> GLOBAL .)
    LEFT_SHIFT      reduce using rule 136 (varname -> GLOBAL .)
    RIGHT_SHIFT     reduce using rule 136 (varname -> GLOBAL .)
    BIT_AND         reduce using rule 136 (varname -> GLOBAL .)
    BIT_XOR         reduce using rule 136 (varname -> GLOBAL .)
    BIT_OR          reduce using rule 136 (varname -> GLOBAL .)
    DOUBLE_EQUALS   reduce using rule 136 (varname -> GLOBAL .)
    NOT_EQUALS      reduce using rule 136 (varname -> GLOBAL .)
    EQUAL_TILDE     reduce using rule 136 (varname -> GLOBAL .)
    COMPARISON      reduce using rule 136 (varname -> GLOBAL .)
    LESS            reduce using rule 136 (varname -> GLOBAL .)
    LESS_EQUALS     reduce using rule 136 (varname -> GLOBAL .)
    GREATER         reduce using rule 136 (varname -> GLOBAL .)
    GREATER_EQUALS  reduce using rule 136 (varname -> GLOBAL .)
    INCL_RANGE      reduce using rule 136 (varname -> GLOBAL .)
    EXCL_RANGE      reduce using rule 136 (varname -> GLOBAL .)
    LOGICAL_OR      reduce using rule 136 (varname -> GLOBAL .)
    LOGICAL_AND     reduce using rule 136 (varname -> GLOBAL .)
    SEMI_COLON      reduce using rule 136 (varname -> GLOBAL .)
    NEWLINE         reduce using rule 136 (varname -> GLOBAL .)
    puts            reduce using rule 136 (varname -> GLOBAL .)
    print           reduce using rule 136 (varname -> GLOBAL .)
    gets            reduce using rule 136 (varname -> GLOBAL .)
    break           reduce using rule 136 (varname -> GLOBAL .)
    def             reduce using rule 136 (varname -> GLOBAL .)
    class           reduce using rule 136 (varname -> GLOBAL .)
    if              reduce using rule 136 (varname -> GLOBAL .)
    while           reduce using rule 136 (varname -> GLOBAL .)
    until           reduce using rule 136 (varname -> GLOBAL .)
    case            reduce using rule 136 (varname -> GLOBAL .)
    for             reduce using rule 136 (varname -> GLOBAL .)
    return          reduce using rule 136 (varname -> GLOBAL .)
    IDENTIFIER      reduce using rule 136 (varname -> GLOBAL .)
    nil             reduce using rule 136 (varname -> GLOBAL .)
    self            reduce using rule 136 (varname -> GLOBAL .)
    GLOBAL          reduce using rule 136 (varname -> GLOBAL .)
    OPEN_BRACKET    reduce using rule 136 (varname -> GLOBAL .)
    Array           reduce using rule 136 (varname -> GLOBAL .)
    NUMBER          reduce using rule 136 (varname -> GLOBAL .)
    true            reduce using rule 136 (varname -> GLOBAL .)
    false           reduce using rule 136 (varname -> GLOBAL .)
    end             reduce using rule 136 (varname -> GLOBAL .)
    $end            reduce using rule 136 (varname -> GLOBAL .)
    CLOSE_BRACKET   reduce using rule 136 (varname -> GLOBAL .)
    when            reduce using rule 136 (varname -> GLOBAL .)
    then            reduce using rule 136 (varname -> GLOBAL .)
    else            reduce using rule 136 (varname -> GLOBAL .)
    elsif           reduce using rule 136 (varname -> GLOBAL .)
    do              reduce using rule 136 (varname -> GLOBAL .)
    COMMA           reduce using rule 136 (varname -> GLOBAL .)
    CLOSE_SQUARE    reduce using rule 136 (varname -> GLOBAL .)


state 33

    (78) term13 -> primary .

    MULTIPLY        reduce using rule 78 (term13 -> primary .)
    DIVIDE          reduce using rule 78 (term13 -> primary .)
    MODULO          reduce using rule 78 (term13 -> primary .)
    PLUS            reduce using rule 78 (term13 -> primary .)
    MINUS           reduce using rule 78 (term13 -> primary .)
    LEFT_SHIFT      reduce using rule 78 (term13 -> primary .)
    RIGHT_SHIFT     reduce using rule 78 (term13 -> primary .)
    BIT_AND         reduce using rule 78 (term13 -> primary .)
    BIT_XOR         reduce using rule 78 (term13 -> primary .)
    BIT_OR          reduce using rule 78 (term13 -> primary .)
    DOUBLE_EQUALS   reduce using rule 78 (term13 -> primary .)
    NOT_EQUALS      reduce using rule 78 (term13 -> primary .)
    EQUAL_TILDE     reduce using rule 78 (term13 -> primary .)
    COMPARISON      reduce using rule 78 (term13 -> primary .)
    LESS            reduce using rule 78 (term13 -> primary .)
    LESS_EQUALS     reduce using rule 78 (term13 -> primary .)
    GREATER         reduce using rule 78 (term13 -> primary .)
    GREATER_EQUALS  reduce using rule 78 (term13 -> primary .)
    INCL_RANGE      reduce using rule 78 (term13 -> primary .)
    EXCL_RANGE      reduce using rule 78 (term13 -> primary .)
    LOGICAL_OR      reduce using rule 78 (term13 -> primary .)
    LOGICAL_AND     reduce using rule 78 (term13 -> primary .)
    SEMI_COLON      reduce using rule 78 (term13 -> primary .)
    NEWLINE         reduce using rule 78 (term13 -> primary .)
    puts            reduce using rule 78 (term13 -> primary .)
    print           reduce using rule 78 (term13 -> primary .)
    gets            reduce using rule 78 (term13 -> primary .)
    break           reduce using rule 78 (term13 -> primary .)
    def             reduce using rule 78 (term13 -> primary .)
    class           reduce using rule 78 (term13 -> primary .)
    if              reduce using rule 78 (term13 -> primary .)
    while           reduce using rule 78 (term13 -> primary .)
    until           reduce using rule 78 (term13 -> primary .)
    case            reduce using rule 78 (term13 -> primary .)
    for             reduce using rule 78 (term13 -> primary .)
    return          reduce using rule 78 (term13 -> primary .)
    IDENTIFIER      reduce using rule 78 (term13 -> primary .)
    nil             reduce using rule 78 (term13 -> primary .)
    self            reduce using rule 78 (term13 -> primary .)
    GLOBAL          reduce using rule 78 (term13 -> primary .)
    OPEN_BRACKET    reduce using rule 78 (term13 -> primary .)
    Array           reduce using rule 78 (term13 -> primary .)
    NUMBER          reduce using rule 78 (term13 -> primary .)
    true            reduce using rule 78 (term13 -> primary .)
    false           reduce using rule 78 (term13 -> primary .)
    $end            reduce using rule 78 (term13 -> primary .)
    end             reduce using rule 78 (term13 -> primary .)
    else            reduce using rule 78 (term13 -> primary .)
    elsif           reduce using rule 78 (term13 -> primary .)
    when            reduce using rule 78 (term13 -> primary .)
    CLOSE_BRACKET   reduce using rule 78 (term13 -> primary .)
    then            reduce using rule 78 (term13 -> primary .)
    do              reduce using rule 78 (term13 -> primary .)
    COMMA           reduce using rule 78 (term13 -> primary .)


state 34

    (48) term3 -> term4 .

    INCL_RANGE      reduce using rule 48 (term3 -> term4 .)
    EXCL_RANGE      reduce using rule 48 (term3 -> term4 .)
    LOGICAL_OR      reduce using rule 48 (term3 -> term4 .)
    LOGICAL_AND     reduce using rule 48 (term3 -> term4 .)
    do              reduce using rule 48 (term3 -> term4 .)
    SEMI_COLON      reduce using rule 48 (term3 -> term4 .)
    NEWLINE         reduce using rule 48 (term3 -> term4 .)
    puts            reduce using rule 48 (term3 -> term4 .)
    print           reduce using rule 48 (term3 -> term4 .)
    gets            reduce using rule 48 (term3 -> term4 .)
    break           reduce using rule 48 (term3 -> term4 .)
    def             reduce using rule 48 (term3 -> term4 .)
    class           reduce using rule 48 (term3 -> term4 .)
    if              reduce using rule 48 (term3 -> term4 .)
    while           reduce using rule 48 (term3 -> term4 .)
    until           reduce using rule 48 (term3 -> term4 .)
    case            reduce using rule 48 (term3 -> term4 .)
    for             reduce using rule 48 (term3 -> term4 .)
    return          reduce using rule 48 (term3 -> term4 .)
    IDENTIFIER      reduce using rule 48 (term3 -> term4 .)
    nil             reduce using rule 48 (term3 -> term4 .)
    self            reduce using rule 48 (term3 -> term4 .)
    GLOBAL          reduce using rule 48 (term3 -> term4 .)
    MINUS           reduce using rule 48 (term3 -> term4 .)
    PLUS            reduce using rule 48 (term3 -> term4 .)
    OPEN_BRACKET    reduce using rule 48 (term3 -> term4 .)
    Array           reduce using rule 48 (term3 -> term4 .)
    NUMBER          reduce using rule 48 (term3 -> term4 .)
    true            reduce using rule 48 (term3 -> term4 .)
    false           reduce using rule 48 (term3 -> term4 .)
    end             reduce using rule 48 (term3 -> term4 .)
    COMMA           reduce using rule 48 (term3 -> term4 .)
    CLOSE_BRACKET   reduce using rule 48 (term3 -> term4 .)
    $end            reduce using rule 48 (term3 -> term4 .)
    then            reduce using rule 48 (term3 -> term4 .)
    elsif           reduce using rule 48 (term3 -> term4 .)
    else            reduce using rule 48 (term3 -> term4 .)
    when            reduce using rule 48 (term3 -> term4 .)


state 35

    (104) mlhsitem -> arrayal .

    in              reduce using rule 104 (mlhsitem -> arrayal .)
    EQUALS          reduce using rule 104 (mlhsitem -> arrayal .)
    MODULO_EQUALS   reduce using rule 104 (mlhsitem -> arrayal .)
    DIVIDE_EQUALS   reduce using rule 104 (mlhsitem -> arrayal .)
    MINUS_EQUALS    reduce using rule 104 (mlhsitem -> arrayal .)
    PLUS_EQUALS     reduce using rule 104 (mlhsitem -> arrayal .)
    OR_EQUALS       reduce using rule 104 (mlhsitem -> arrayal .)
    AND_EQUALS      reduce using rule 104 (mlhsitem -> arrayal .)
    XOR_EQUALS      reduce using rule 104 (mlhsitem -> arrayal .)
    RIGHT_SHIFT_EQUALS reduce using rule 104 (mlhsitem -> arrayal .)
    LEFT_SHIFT_EQUALS reduce using rule 104 (mlhsitem -> arrayal .)
    MULTIPLY_EQUALS reduce using rule 104 (mlhsitem -> arrayal .)


state 36

    (7) stmt -> puts . OPEN_BRACKET STRING CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 111


state 37

    (83) primary -> literal .

    MULTIPLY        reduce using rule 83 (primary -> literal .)
    DIVIDE          reduce using rule 83 (primary -> literal .)
    MODULO          reduce using rule 83 (primary -> literal .)
    PLUS            reduce using rule 83 (primary -> literal .)
    MINUS           reduce using rule 83 (primary -> literal .)
    LEFT_SHIFT      reduce using rule 83 (primary -> literal .)
    RIGHT_SHIFT     reduce using rule 83 (primary -> literal .)
    BIT_AND         reduce using rule 83 (primary -> literal .)
    BIT_XOR         reduce using rule 83 (primary -> literal .)
    BIT_OR          reduce using rule 83 (primary -> literal .)
    DOUBLE_EQUALS   reduce using rule 83 (primary -> literal .)
    NOT_EQUALS      reduce using rule 83 (primary -> literal .)
    EQUAL_TILDE     reduce using rule 83 (primary -> literal .)
    COMPARISON      reduce using rule 83 (primary -> literal .)
    LESS            reduce using rule 83 (primary -> literal .)
    LESS_EQUALS     reduce using rule 83 (primary -> literal .)
    GREATER         reduce using rule 83 (primary -> literal .)
    GREATER_EQUALS  reduce using rule 83 (primary -> literal .)
    INCL_RANGE      reduce using rule 83 (primary -> literal .)
    EXCL_RANGE      reduce using rule 83 (primary -> literal .)
    LOGICAL_OR      reduce using rule 83 (primary -> literal .)
    LOGICAL_AND     reduce using rule 83 (primary -> literal .)
    do              reduce using rule 83 (primary -> literal .)
    SEMI_COLON      reduce using rule 83 (primary -> literal .)
    NEWLINE         reduce using rule 83 (primary -> literal .)
    puts            reduce using rule 83 (primary -> literal .)
    print           reduce using rule 83 (primary -> literal .)
    gets            reduce using rule 83 (primary -> literal .)
    break           reduce using rule 83 (primary -> literal .)
    def             reduce using rule 83 (primary -> literal .)
    class           reduce using rule 83 (primary -> literal .)
    if              reduce using rule 83 (primary -> literal .)
    while           reduce using rule 83 (primary -> literal .)
    until           reduce using rule 83 (primary -> literal .)
    case            reduce using rule 83 (primary -> literal .)
    for             reduce using rule 83 (primary -> literal .)
    return          reduce using rule 83 (primary -> literal .)
    IDENTIFIER      reduce using rule 83 (primary -> literal .)
    nil             reduce using rule 83 (primary -> literal .)
    self            reduce using rule 83 (primary -> literal .)
    GLOBAL          reduce using rule 83 (primary -> literal .)
    OPEN_BRACKET    reduce using rule 83 (primary -> literal .)
    Array           reduce using rule 83 (primary -> literal .)
    NUMBER          reduce using rule 83 (primary -> literal .)
    true            reduce using rule 83 (primary -> literal .)
    false           reduce using rule 83 (primary -> literal .)
    end             reduce using rule 83 (primary -> literal .)
    CLOSE_BRACKET   reduce using rule 83 (primary -> literal .)
    when            reduce using rule 83 (primary -> literal .)
    $end            reduce using rule 83 (primary -> literal .)
    then            reduce using rule 83 (primary -> literal .)
    else            reduce using rule 83 (primary -> literal .)
    elsif           reduce using rule 83 (primary -> literal .)
    COMMA           reduce using rule 83 (primary -> literal .)
    CLOSE_SQUARE    reduce using rule 83 (primary -> literal .)


state 38

    (31) expr2 -> call .

    do              reduce using rule 31 (expr2 -> call .)
    SEMI_COLON      reduce using rule 31 (expr2 -> call .)
    NEWLINE         reduce using rule 31 (expr2 -> call .)
    puts            reduce using rule 31 (expr2 -> call .)
    print           reduce using rule 31 (expr2 -> call .)
    gets            reduce using rule 31 (expr2 -> call .)
    break           reduce using rule 31 (expr2 -> call .)
    def             reduce using rule 31 (expr2 -> call .)
    class           reduce using rule 31 (expr2 -> call .)
    if              reduce using rule 31 (expr2 -> call .)
    while           reduce using rule 31 (expr2 -> call .)
    until           reduce using rule 31 (expr2 -> call .)
    case            reduce using rule 31 (expr2 -> call .)
    for             reduce using rule 31 (expr2 -> call .)
    return          reduce using rule 31 (expr2 -> call .)
    IDENTIFIER      reduce using rule 31 (expr2 -> call .)
    nil             reduce using rule 31 (expr2 -> call .)
    self            reduce using rule 31 (expr2 -> call .)
    GLOBAL          reduce using rule 31 (expr2 -> call .)
    MINUS           reduce using rule 31 (expr2 -> call .)
    PLUS            reduce using rule 31 (expr2 -> call .)
    OPEN_BRACKET    reduce using rule 31 (expr2 -> call .)
    Array           reduce using rule 31 (expr2 -> call .)
    NUMBER          reduce using rule 31 (expr2 -> call .)
    true            reduce using rule 31 (expr2 -> call .)
    false           reduce using rule 31 (expr2 -> call .)
    end             reduce using rule 31 (expr2 -> call .)
    then            reduce using rule 31 (expr2 -> call .)
    elsif           reduce using rule 31 (expr2 -> call .)
    else            reduce using rule 31 (expr2 -> call .)
    when            reduce using rule 31 (expr2 -> call .)
    $end            reduce using rule 31 (expr2 -> call .)
    CLOSE_BRACKET   reduce using rule 31 (expr2 -> call .)


state 39

    (33) function -> IDENTIFIER . OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> IDENTIFIER . OPEN_BRACKET CLOSE_BRACKET
    (103) mlhsitem -> IDENTIFIER .
    (85) classvar -> IDENTIFIER . DOT IDENTIFIER
    (137) varname -> IDENTIFIER .

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    OPEN_BRACKET    shift and go to state 112
    EQUALS          reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    OR_EQUALS       reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    AND_EQUALS      reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    XOR_EQUALS      reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    DOT             shift and go to state 113
    OPEN_SQUARE     reduce using rule 137 (varname -> IDENTIFIER .)
    MULTIPLY        reduce using rule 137 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 137 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 137 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 137 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 137 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 137 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 137 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 137 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 137 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 137 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 137 (varname -> IDENTIFIER .)
    LESS            reduce using rule 137 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 137 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 137 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 137 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 137 (varname -> IDENTIFIER .)
    puts            reduce using rule 137 (varname -> IDENTIFIER .)
    print           reduce using rule 137 (varname -> IDENTIFIER .)
    gets            reduce using rule 137 (varname -> IDENTIFIER .)
    break           reduce using rule 137 (varname -> IDENTIFIER .)
    def             reduce using rule 137 (varname -> IDENTIFIER .)
    class           reduce using rule 137 (varname -> IDENTIFIER .)
    if              reduce using rule 137 (varname -> IDENTIFIER .)
    while           reduce using rule 137 (varname -> IDENTIFIER .)
    until           reduce using rule 137 (varname -> IDENTIFIER .)
    case            reduce using rule 137 (varname -> IDENTIFIER .)
    for             reduce using rule 137 (varname -> IDENTIFIER .)
    return          reduce using rule 137 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 137 (varname -> IDENTIFIER .)
    nil             reduce using rule 137 (varname -> IDENTIFIER .)
    self            reduce using rule 137 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 137 (varname -> IDENTIFIER .)
    Array           reduce using rule 137 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 137 (varname -> IDENTIFIER .)
    true            reduce using rule 137 (varname -> IDENTIFIER .)
    false           reduce using rule 137 (varname -> IDENTIFIER .)
    end             reduce using rule 137 (varname -> IDENTIFIER .)
    $end            reduce using rule 137 (varname -> IDENTIFIER .)
    do              reduce using rule 137 (varname -> IDENTIFIER .)
    else            reduce using rule 137 (varname -> IDENTIFIER .)
    elsif           reduce using rule 137 (varname -> IDENTIFIER .)
    when            reduce using rule 137 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 137 (varname -> IDENTIFIER .)
    then            reduce using rule 137 (varname -> IDENTIFIER .)

  ! OPEN_BRACKET    [ reduce using rule 137 (varname -> IDENTIFIER .) ]


state 40

    (22) expr -> until . M_1 expr1 pdo M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 114
    empty                          shift and go to state 108

state 41

    (140) newline -> empty .

    puts            reduce using rule 140 (newline -> empty .)
    print           reduce using rule 140 (newline -> empty .)
    gets            reduce using rule 140 (newline -> empty .)
    break           reduce using rule 140 (newline -> empty .)
    def             reduce using rule 140 (newline -> empty .)
    class           reduce using rule 140 (newline -> empty .)
    if              reduce using rule 140 (newline -> empty .)
    while           reduce using rule 140 (newline -> empty .)
    until           reduce using rule 140 (newline -> empty .)
    case            reduce using rule 140 (newline -> empty .)
    for             reduce using rule 140 (newline -> empty .)
    return          reduce using rule 140 (newline -> empty .)
    IDENTIFIER      reduce using rule 140 (newline -> empty .)
    nil             reduce using rule 140 (newline -> empty .)
    self            reduce using rule 140 (newline -> empty .)
    GLOBAL          reduce using rule 140 (newline -> empty .)
    MINUS           reduce using rule 140 (newline -> empty .)
    PLUS            reduce using rule 140 (newline -> empty .)
    OPEN_BRACKET    reduce using rule 140 (newline -> empty .)
    Array           reduce using rule 140 (newline -> empty .)
    NUMBER          reduce using rule 140 (newline -> empty .)
    true            reduce using rule 140 (newline -> empty .)
    false           reduce using rule 140 (newline -> empty .)
    $end            reduce using rule 140 (newline -> empty .)
    then            reduce using rule 140 (newline -> empty .)
    when            reduce using rule 140 (newline -> empty .)
    end             reduce using rule 140 (newline -> empty .)
    do              reduce using rule 140 (newline -> empty .)
    else            reduce using rule 140 (newline -> empty .)
    elsif           reduce using rule 140 (newline -> empty .)


state 42

    (32) call -> function .

    SEMI_COLON      reduce using rule 32 (call -> function .)
    NEWLINE         reduce using rule 32 (call -> function .)
    puts            reduce using rule 32 (call -> function .)
    print           reduce using rule 32 (call -> function .)
    gets            reduce using rule 32 (call -> function .)
    break           reduce using rule 32 (call -> function .)
    def             reduce using rule 32 (call -> function .)
    class           reduce using rule 32 (call -> function .)
    if              reduce using rule 32 (call -> function .)
    while           reduce using rule 32 (call -> function .)
    until           reduce using rule 32 (call -> function .)
    case            reduce using rule 32 (call -> function .)
    for             reduce using rule 32 (call -> function .)
    return          reduce using rule 32 (call -> function .)
    IDENTIFIER      reduce using rule 32 (call -> function .)
    nil             reduce using rule 32 (call -> function .)
    self            reduce using rule 32 (call -> function .)
    GLOBAL          reduce using rule 32 (call -> function .)
    MINUS           reduce using rule 32 (call -> function .)
    PLUS            reduce using rule 32 (call -> function .)
    OPEN_BRACKET    reduce using rule 32 (call -> function .)
    Array           reduce using rule 32 (call -> function .)
    NUMBER          reduce using rule 32 (call -> function .)
    true            reduce using rule 32 (call -> function .)
    false           reduce using rule 32 (call -> function .)
    elsif           reduce using rule 32 (call -> function .)
    else            reduce using rule 32 (call -> function .)
    end             reduce using rule 32 (call -> function .)
    then            reduce using rule 32 (call -> function .)
    do              reduce using rule 32 (call -> function .)
    $end            reduce using rule 32 (call -> function .)
    when            reduce using rule 32 (call -> function .)
    CLOSE_BRACKET   reduce using rule 32 (call -> function .)


state 43

    (102) mlhs -> mlhsitem .

    EQUALS          reduce using rule 102 (mlhs -> mlhsitem .)
    MODULO_EQUALS   reduce using rule 102 (mlhs -> mlhsitem .)
    DIVIDE_EQUALS   reduce using rule 102 (mlhs -> mlhsitem .)
    MINUS_EQUALS    reduce using rule 102 (mlhs -> mlhsitem .)
    PLUS_EQUALS     reduce using rule 102 (mlhs -> mlhsitem .)
    OR_EQUALS       reduce using rule 102 (mlhs -> mlhsitem .)
    AND_EQUALS      reduce using rule 102 (mlhs -> mlhsitem .)
    XOR_EQUALS      reduce using rule 102 (mlhs -> mlhsitem .)
    RIGHT_SHIFT_EQUALS reduce using rule 102 (mlhs -> mlhsitem .)
    LEFT_SHIFT_EQUALS reduce using rule 102 (mlhs -> mlhsitem .)
    MULTIPLY_EQUALS reduce using rule 102 (mlhs -> mlhsitem .)
    in              reduce using rule 102 (mlhs -> mlhsitem .)


state 44

    (99) literal -> true .

    MULTIPLY        reduce using rule 99 (literal -> true .)
    DIVIDE          reduce using rule 99 (literal -> true .)
    MODULO          reduce using rule 99 (literal -> true .)
    PLUS            reduce using rule 99 (literal -> true .)
    MINUS           reduce using rule 99 (literal -> true .)
    LEFT_SHIFT      reduce using rule 99 (literal -> true .)
    RIGHT_SHIFT     reduce using rule 99 (literal -> true .)
    BIT_AND         reduce using rule 99 (literal -> true .)
    BIT_XOR         reduce using rule 99 (literal -> true .)
    BIT_OR          reduce using rule 99 (literal -> true .)
    LESS            reduce using rule 99 (literal -> true .)
    LESS_EQUALS     reduce using rule 99 (literal -> true .)
    GREATER         reduce using rule 99 (literal -> true .)
    GREATER_EQUALS  reduce using rule 99 (literal -> true .)
    INCL_RANGE      reduce using rule 99 (literal -> true .)
    EXCL_RANGE      reduce using rule 99 (literal -> true .)
    LOGICAL_OR      reduce using rule 99 (literal -> true .)
    LOGICAL_AND     reduce using rule 99 (literal -> true .)
    SEMI_COLON      reduce using rule 99 (literal -> true .)
    NEWLINE         reduce using rule 99 (literal -> true .)
    puts            reduce using rule 99 (literal -> true .)
    print           reduce using rule 99 (literal -> true .)
    gets            reduce using rule 99 (literal -> true .)
    break           reduce using rule 99 (literal -> true .)
    def             reduce using rule 99 (literal -> true .)
    class           reduce using rule 99 (literal -> true .)
    if              reduce using rule 99 (literal -> true .)
    while           reduce using rule 99 (literal -> true .)
    until           reduce using rule 99 (literal -> true .)
    case            reduce using rule 99 (literal -> true .)
    for             reduce using rule 99 (literal -> true .)
    return          reduce using rule 99 (literal -> true .)
    IDENTIFIER      reduce using rule 99 (literal -> true .)
    nil             reduce using rule 99 (literal -> true .)
    self            reduce using rule 99 (literal -> true .)
    GLOBAL          reduce using rule 99 (literal -> true .)
    OPEN_BRACKET    reduce using rule 99 (literal -> true .)
    Array           reduce using rule 99 (literal -> true .)
    NUMBER          reduce using rule 99 (literal -> true .)
    true            reduce using rule 99 (literal -> true .)
    false           reduce using rule 99 (literal -> true .)
    $end            reduce using rule 99 (literal -> true .)
    CLOSE_BRACKET   reduce using rule 99 (literal -> true .)
    when            reduce using rule 99 (literal -> true .)
    then            reduce using rule 99 (literal -> true .)
    else            reduce using rule 99 (literal -> true .)
    end             reduce using rule 99 (literal -> true .)
    elsif           reduce using rule 99 (literal -> true .)
    do              reduce using rule 99 (literal -> true .)
    COMMA           reduce using rule 99 (literal -> true .)
    DOUBLE_EQUALS   reduce using rule 99 (literal -> true .)
    NOT_EQUALS      reduce using rule 99 (literal -> true .)
    EQUAL_TILDE     reduce using rule 99 (literal -> true .)
    COMPARISON      reduce using rule 99 (literal -> true .)
    CLOSE_SQUARE    reduce using rule 99 (literal -> true .)


state 45

    (23) expr -> case . expr1 newline multcase end M_1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    literal                        shift and go to state 37
    expr1                          shift and go to state 115
    call                           shift and go to state 38
    function                       shift and go to state 42
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    varname                        shift and go to state 30
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 46

    (12) stmt -> expr .

    SEMI_COLON      reduce using rule 12 (stmt -> expr .)
    NEWLINE         reduce using rule 12 (stmt -> expr .)
    puts            reduce using rule 12 (stmt -> expr .)
    print           reduce using rule 12 (stmt -> expr .)
    gets            reduce using rule 12 (stmt -> expr .)
    break           reduce using rule 12 (stmt -> expr .)
    def             reduce using rule 12 (stmt -> expr .)
    class           reduce using rule 12 (stmt -> expr .)
    if              reduce using rule 12 (stmt -> expr .)
    while           reduce using rule 12 (stmt -> expr .)
    until           reduce using rule 12 (stmt -> expr .)
    case            reduce using rule 12 (stmt -> expr .)
    for             reduce using rule 12 (stmt -> expr .)
    return          reduce using rule 12 (stmt -> expr .)
    IDENTIFIER      reduce using rule 12 (stmt -> expr .)
    nil             reduce using rule 12 (stmt -> expr .)
    self            reduce using rule 12 (stmt -> expr .)
    GLOBAL          reduce using rule 12 (stmt -> expr .)
    MINUS           reduce using rule 12 (stmt -> expr .)
    PLUS            reduce using rule 12 (stmt -> expr .)
    OPEN_BRACKET    reduce using rule 12 (stmt -> expr .)
    Array           reduce using rule 12 (stmt -> expr .)
    NUMBER          reduce using rule 12 (stmt -> expr .)
    true            reduce using rule 12 (stmt -> expr .)
    false           reduce using rule 12 (stmt -> expr .)
    end             reduce using rule 12 (stmt -> expr .)
    $end            reduce using rule 12 (stmt -> expr .)
    when            reduce using rule 12 (stmt -> expr .)
    else            reduce using rule 12 (stmt -> expr .)
    elsif           reduce using rule 12 (stmt -> expr .)


state 47

    (21) expr -> while . M_1 expr1 pdo M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 116
    empty                          shift and go to state 108

state 48

    (81) primary -> arraya .

    MULTIPLY        reduce using rule 81 (primary -> arraya .)
    DIVIDE          reduce using rule 81 (primary -> arraya .)
    MODULO          reduce using rule 81 (primary -> arraya .)
    PLUS            reduce using rule 81 (primary -> arraya .)
    MINUS           reduce using rule 81 (primary -> arraya .)
    LEFT_SHIFT      reduce using rule 81 (primary -> arraya .)
    RIGHT_SHIFT     reduce using rule 81 (primary -> arraya .)
    BIT_AND         reduce using rule 81 (primary -> arraya .)
    BIT_XOR         reduce using rule 81 (primary -> arraya .)
    BIT_OR          reduce using rule 81 (primary -> arraya .)
    DOUBLE_EQUALS   reduce using rule 81 (primary -> arraya .)
    NOT_EQUALS      reduce using rule 81 (primary -> arraya .)
    EQUAL_TILDE     reduce using rule 81 (primary -> arraya .)
    COMPARISON      reduce using rule 81 (primary -> arraya .)
    LESS            reduce using rule 81 (primary -> arraya .)
    LESS_EQUALS     reduce using rule 81 (primary -> arraya .)
    GREATER         reduce using rule 81 (primary -> arraya .)
    GREATER_EQUALS  reduce using rule 81 (primary -> arraya .)
    INCL_RANGE      reduce using rule 81 (primary -> arraya .)
    EXCL_RANGE      reduce using rule 81 (primary -> arraya .)
    LOGICAL_OR      reduce using rule 81 (primary -> arraya .)
    LOGICAL_AND     reduce using rule 81 (primary -> arraya .)
    do              reduce using rule 81 (primary -> arraya .)
    SEMI_COLON      reduce using rule 81 (primary -> arraya .)
    NEWLINE         reduce using rule 81 (primary -> arraya .)
    puts            reduce using rule 81 (primary -> arraya .)
    print           reduce using rule 81 (primary -> arraya .)
    gets            reduce using rule 81 (primary -> arraya .)
    break           reduce using rule 81 (primary -> arraya .)
    def             reduce using rule 81 (primary -> arraya .)
    class           reduce using rule 81 (primary -> arraya .)
    if              reduce using rule 81 (primary -> arraya .)
    while           reduce using rule 81 (primary -> arraya .)
    until           reduce using rule 81 (primary -> arraya .)
    case            reduce using rule 81 (primary -> arraya .)
    for             reduce using rule 81 (primary -> arraya .)
    return          reduce using rule 81 (primary -> arraya .)
    IDENTIFIER      reduce using rule 81 (primary -> arraya .)
    nil             reduce using rule 81 (primary -> arraya .)
    self            reduce using rule 81 (primary -> arraya .)
    GLOBAL          reduce using rule 81 (primary -> arraya .)
    OPEN_BRACKET    reduce using rule 81 (primary -> arraya .)
    Array           reduce using rule 81 (primary -> arraya .)
    NUMBER          reduce using rule 81 (primary -> arraya .)
    true            reduce using rule 81 (primary -> arraya .)
    false           reduce using rule 81 (primary -> arraya .)
    end             reduce using rule 81 (primary -> arraya .)
    CLOSE_BRACKET   reduce using rule 81 (primary -> arraya .)
    when            reduce using rule 81 (primary -> arraya .)
    $end            reduce using rule 81 (primary -> arraya .)
    then            reduce using rule 81 (primary -> arraya .)
    else            reduce using rule 81 (primary -> arraya .)
    elsif           reduce using rule 81 (primary -> arraya .)
    COMMA           reduce using rule 81 (primary -> arraya .)
    CLOSE_SQUARE    reduce using rule 81 (primary -> arraya .)


state 49

    (14) keydef -> def . IDENTIFIER

    IDENTIFIER      shift and go to state 117


state 50

    (80) primary -> arrayd .

    MULTIPLY        reduce using rule 80 (primary -> arrayd .)
    DIVIDE          reduce using rule 80 (primary -> arrayd .)
    MODULO          reduce using rule 80 (primary -> arrayd .)
    PLUS            reduce using rule 80 (primary -> arrayd .)
    MINUS           reduce using rule 80 (primary -> arrayd .)
    LEFT_SHIFT      reduce using rule 80 (primary -> arrayd .)
    RIGHT_SHIFT     reduce using rule 80 (primary -> arrayd .)
    BIT_AND         reduce using rule 80 (primary -> arrayd .)
    BIT_XOR         reduce using rule 80 (primary -> arrayd .)
    BIT_OR          reduce using rule 80 (primary -> arrayd .)
    DOUBLE_EQUALS   reduce using rule 80 (primary -> arrayd .)
    NOT_EQUALS      reduce using rule 80 (primary -> arrayd .)
    EQUAL_TILDE     reduce using rule 80 (primary -> arrayd .)
    COMPARISON      reduce using rule 80 (primary -> arrayd .)
    LESS            reduce using rule 80 (primary -> arrayd .)
    LESS_EQUALS     reduce using rule 80 (primary -> arrayd .)
    GREATER         reduce using rule 80 (primary -> arrayd .)
    GREATER_EQUALS  reduce using rule 80 (primary -> arrayd .)
    INCL_RANGE      reduce using rule 80 (primary -> arrayd .)
    EXCL_RANGE      reduce using rule 80 (primary -> arrayd .)
    LOGICAL_OR      reduce using rule 80 (primary -> arrayd .)
    LOGICAL_AND     reduce using rule 80 (primary -> arrayd .)
    do              reduce using rule 80 (primary -> arrayd .)
    SEMI_COLON      reduce using rule 80 (primary -> arrayd .)
    NEWLINE         reduce using rule 80 (primary -> arrayd .)
    puts            reduce using rule 80 (primary -> arrayd .)
    print           reduce using rule 80 (primary -> arrayd .)
    gets            reduce using rule 80 (primary -> arrayd .)
    break           reduce using rule 80 (primary -> arrayd .)
    def             reduce using rule 80 (primary -> arrayd .)
    class           reduce using rule 80 (primary -> arrayd .)
    if              reduce using rule 80 (primary -> arrayd .)
    while           reduce using rule 80 (primary -> arrayd .)
    until           reduce using rule 80 (primary -> arrayd .)
    case            reduce using rule 80 (primary -> arrayd .)
    for             reduce using rule 80 (primary -> arrayd .)
    return          reduce using rule 80 (primary -> arrayd .)
    IDENTIFIER      reduce using rule 80 (primary -> arrayd .)
    nil             reduce using rule 80 (primary -> arrayd .)
    self            reduce using rule 80 (primary -> arrayd .)
    GLOBAL          reduce using rule 80 (primary -> arrayd .)
    OPEN_BRACKET    reduce using rule 80 (primary -> arrayd .)
    Array           reduce using rule 80 (primary -> arrayd .)
    NUMBER          reduce using rule 80 (primary -> arrayd .)
    true            reduce using rule 80 (primary -> arrayd .)
    false           reduce using rule 80 (primary -> arrayd .)
    end             reduce using rule 80 (primary -> arrayd .)
    CLOSE_BRACKET   reduce using rule 80 (primary -> arrayd .)
    when            reduce using rule 80 (primary -> arrayd .)
    $end            reduce using rule 80 (primary -> arrayd .)
    then            reduce using rule 80 (primary -> arrayd .)
    else            reduce using rule 80 (primary -> arrayd .)
    elsif           reduce using rule 80 (primary -> arrayd .)
    COMMA           reduce using rule 80 (primary -> arrayd .)
    CLOSE_SQUARE    reduce using rule 80 (primary -> arrayd .)


state 51

    (100) literal -> false .

    MULTIPLY        reduce using rule 100 (literal -> false .)
    DIVIDE          reduce using rule 100 (literal -> false .)
    MODULO          reduce using rule 100 (literal -> false .)
    PLUS            reduce using rule 100 (literal -> false .)
    MINUS           reduce using rule 100 (literal -> false .)
    LEFT_SHIFT      reduce using rule 100 (literal -> false .)
    RIGHT_SHIFT     reduce using rule 100 (literal -> false .)
    BIT_AND         reduce using rule 100 (literal -> false .)
    BIT_XOR         reduce using rule 100 (literal -> false .)
    BIT_OR          reduce using rule 100 (literal -> false .)
    LESS            reduce using rule 100 (literal -> false .)
    LESS_EQUALS     reduce using rule 100 (literal -> false .)
    GREATER         reduce using rule 100 (literal -> false .)
    GREATER_EQUALS  reduce using rule 100 (literal -> false .)
    INCL_RANGE      reduce using rule 100 (literal -> false .)
    EXCL_RANGE      reduce using rule 100 (literal -> false .)
    LOGICAL_OR      reduce using rule 100 (literal -> false .)
    LOGICAL_AND     reduce using rule 100 (literal -> false .)
    SEMI_COLON      reduce using rule 100 (literal -> false .)
    NEWLINE         reduce using rule 100 (literal -> false .)
    puts            reduce using rule 100 (literal -> false .)
    print           reduce using rule 100 (literal -> false .)
    gets            reduce using rule 100 (literal -> false .)
    break           reduce using rule 100 (literal -> false .)
    def             reduce using rule 100 (literal -> false .)
    class           reduce using rule 100 (literal -> false .)
    if              reduce using rule 100 (literal -> false .)
    while           reduce using rule 100 (literal -> false .)
    until           reduce using rule 100 (literal -> false .)
    case            reduce using rule 100 (literal -> false .)
    for             reduce using rule 100 (literal -> false .)
    return          reduce using rule 100 (literal -> false .)
    IDENTIFIER      reduce using rule 100 (literal -> false .)
    nil             reduce using rule 100 (literal -> false .)
    self            reduce using rule 100 (literal -> false .)
    GLOBAL          reduce using rule 100 (literal -> false .)
    OPEN_BRACKET    reduce using rule 100 (literal -> false .)
    Array           reduce using rule 100 (literal -> false .)
    NUMBER          reduce using rule 100 (literal -> false .)
    true            reduce using rule 100 (literal -> false .)
    false           reduce using rule 100 (literal -> false .)
    $end            reduce using rule 100 (literal -> false .)
    CLOSE_BRACKET   reduce using rule 100 (literal -> false .)
    when            reduce using rule 100 (literal -> false .)
    then            reduce using rule 100 (literal -> false .)
    else            reduce using rule 100 (literal -> false .)
    end             reduce using rule 100 (literal -> false .)
    elsif           reduce using rule 100 (literal -> false .)
    do              reduce using rule 100 (literal -> false .)
    COMMA           reduce using rule 100 (literal -> false .)
    DOUBLE_EQUALS   reduce using rule 100 (literal -> false .)
    NOT_EQUALS      reduce using rule 100 (literal -> false .)
    EQUAL_TILDE     reduce using rule 100 (literal -> false .)
    COMPARISON      reduce using rule 100 (literal -> false .)
    CLOSE_SQUARE    reduce using rule 100 (literal -> false .)


state 52

    (98) literal -> NUMBER .

    MULTIPLY        reduce using rule 98 (literal -> NUMBER .)
    DIVIDE          reduce using rule 98 (literal -> NUMBER .)
    MODULO          reduce using rule 98 (literal -> NUMBER .)
    PLUS            reduce using rule 98 (literal -> NUMBER .)
    MINUS           reduce using rule 98 (literal -> NUMBER .)
    LEFT_SHIFT      reduce using rule 98 (literal -> NUMBER .)
    RIGHT_SHIFT     reduce using rule 98 (literal -> NUMBER .)
    BIT_AND         reduce using rule 98 (literal -> NUMBER .)
    BIT_XOR         reduce using rule 98 (literal -> NUMBER .)
    BIT_OR          reduce using rule 98 (literal -> NUMBER .)
    LESS            reduce using rule 98 (literal -> NUMBER .)
    LESS_EQUALS     reduce using rule 98 (literal -> NUMBER .)
    GREATER         reduce using rule 98 (literal -> NUMBER .)
    GREATER_EQUALS  reduce using rule 98 (literal -> NUMBER .)
    INCL_RANGE      reduce using rule 98 (literal -> NUMBER .)
    EXCL_RANGE      reduce using rule 98 (literal -> NUMBER .)
    LOGICAL_OR      reduce using rule 98 (literal -> NUMBER .)
    LOGICAL_AND     reduce using rule 98 (literal -> NUMBER .)
    SEMI_COLON      reduce using rule 98 (literal -> NUMBER .)
    NEWLINE         reduce using rule 98 (literal -> NUMBER .)
    puts            reduce using rule 98 (literal -> NUMBER .)
    print           reduce using rule 98 (literal -> NUMBER .)
    gets            reduce using rule 98 (literal -> NUMBER .)
    break           reduce using rule 98 (literal -> NUMBER .)
    def             reduce using rule 98 (literal -> NUMBER .)
    class           reduce using rule 98 (literal -> NUMBER .)
    if              reduce using rule 98 (literal -> NUMBER .)
    while           reduce using rule 98 (literal -> NUMBER .)
    until           reduce using rule 98 (literal -> NUMBER .)
    case            reduce using rule 98 (literal -> NUMBER .)
    for             reduce using rule 98 (literal -> NUMBER .)
    return          reduce using rule 98 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 98 (literal -> NUMBER .)
    nil             reduce using rule 98 (literal -> NUMBER .)
    self            reduce using rule 98 (literal -> NUMBER .)
    GLOBAL          reduce using rule 98 (literal -> NUMBER .)
    OPEN_BRACKET    reduce using rule 98 (literal -> NUMBER .)
    Array           reduce using rule 98 (literal -> NUMBER .)
    NUMBER          reduce using rule 98 (literal -> NUMBER .)
    true            reduce using rule 98 (literal -> NUMBER .)
    false           reduce using rule 98 (literal -> NUMBER .)
    $end            reduce using rule 98 (literal -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 98 (literal -> NUMBER .)
    when            reduce using rule 98 (literal -> NUMBER .)
    then            reduce using rule 98 (literal -> NUMBER .)
    else            reduce using rule 98 (literal -> NUMBER .)
    end             reduce using rule 98 (literal -> NUMBER .)
    elsif           reduce using rule 98 (literal -> NUMBER .)
    do              reduce using rule 98 (literal -> NUMBER .)
    COMMA           reduce using rule 98 (literal -> NUMBER .)
    DOUBLE_EQUALS   reduce using rule 98 (literal -> NUMBER .)
    NOT_EQUALS      reduce using rule 98 (literal -> NUMBER .)
    EQUAL_TILDE     reduce using rule 98 (literal -> NUMBER .)
    COMPARISON      reduce using rule 98 (literal -> NUMBER .)
    CLOSE_SQUARE    reduce using rule 98 (literal -> NUMBER .)


state 53

    (18) expr -> if . expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> if . expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> if . expr1 pthen M_1 multstmt end M_1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    literal                        shift and go to state 37
    expr1                          shift and go to state 118
    call                           shift and go to state 38
    function                       shift and go to state 42
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    varname                        shift and go to state 30
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 54

    (119) variable -> self .

    OPEN_SQUARE     reduce using rule 119 (variable -> self .)


state 55

    (29) expr1 -> expr2 .

    SEMI_COLON      reduce using rule 29 (expr1 -> expr2 .)
    NEWLINE         reduce using rule 29 (expr1 -> expr2 .)
    puts            reduce using rule 29 (expr1 -> expr2 .)
    print           reduce using rule 29 (expr1 -> expr2 .)
    gets            reduce using rule 29 (expr1 -> expr2 .)
    break           reduce using rule 29 (expr1 -> expr2 .)
    def             reduce using rule 29 (expr1 -> expr2 .)
    class           reduce using rule 29 (expr1 -> expr2 .)
    if              reduce using rule 29 (expr1 -> expr2 .)
    while           reduce using rule 29 (expr1 -> expr2 .)
    until           reduce using rule 29 (expr1 -> expr2 .)
    case            reduce using rule 29 (expr1 -> expr2 .)
    for             reduce using rule 29 (expr1 -> expr2 .)
    return          reduce using rule 29 (expr1 -> expr2 .)
    IDENTIFIER      reduce using rule 29 (expr1 -> expr2 .)
    nil             reduce using rule 29 (expr1 -> expr2 .)
    self            reduce using rule 29 (expr1 -> expr2 .)
    GLOBAL          reduce using rule 29 (expr1 -> expr2 .)
    MINUS           reduce using rule 29 (expr1 -> expr2 .)
    PLUS            reduce using rule 29 (expr1 -> expr2 .)
    OPEN_BRACKET    reduce using rule 29 (expr1 -> expr2 .)
    Array           reduce using rule 29 (expr1 -> expr2 .)
    NUMBER          reduce using rule 29 (expr1 -> expr2 .)
    true            reduce using rule 29 (expr1 -> expr2 .)
    false           reduce using rule 29 (expr1 -> expr2 .)
    $end            reduce using rule 29 (expr1 -> expr2 .)
    end             reduce using rule 29 (expr1 -> expr2 .)
    then            reduce using rule 29 (expr1 -> expr2 .)
    elsif           reduce using rule 29 (expr1 -> expr2 .)
    else            reduce using rule 29 (expr1 -> expr2 .)
    when            reduce using rule 29 (expr1 -> expr2 .)
    do              reduce using rule 29 (expr1 -> expr2 .)


state 56

    (25) expr -> expr1 .

    SEMI_COLON      reduce using rule 25 (expr -> expr1 .)
    NEWLINE         reduce using rule 25 (expr -> expr1 .)
    puts            reduce using rule 25 (expr -> expr1 .)
    print           reduce using rule 25 (expr -> expr1 .)
    gets            reduce using rule 25 (expr -> expr1 .)
    break           reduce using rule 25 (expr -> expr1 .)
    def             reduce using rule 25 (expr -> expr1 .)
    class           reduce using rule 25 (expr -> expr1 .)
    if              reduce using rule 25 (expr -> expr1 .)
    while           reduce using rule 25 (expr -> expr1 .)
    until           reduce using rule 25 (expr -> expr1 .)
    case            reduce using rule 25 (expr -> expr1 .)
    for             reduce using rule 25 (expr -> expr1 .)
    return          reduce using rule 25 (expr -> expr1 .)
    IDENTIFIER      reduce using rule 25 (expr -> expr1 .)
    nil             reduce using rule 25 (expr -> expr1 .)
    self            reduce using rule 25 (expr -> expr1 .)
    GLOBAL          reduce using rule 25 (expr -> expr1 .)
    MINUS           reduce using rule 25 (expr -> expr1 .)
    PLUS            reduce using rule 25 (expr -> expr1 .)
    OPEN_BRACKET    reduce using rule 25 (expr -> expr1 .)
    Array           reduce using rule 25 (expr -> expr1 .)
    NUMBER          reduce using rule 25 (expr -> expr1 .)
    true            reduce using rule 25 (expr -> expr1 .)
    false           reduce using rule 25 (expr -> expr1 .)
    else            reduce using rule 25 (expr -> expr1 .)
    end             reduce using rule 25 (expr -> expr1 .)
    elsif           reduce using rule 25 (expr -> expr1 .)
    then            reduce using rule 25 (expr -> expr1 .)
    $end            reduce using rule 25 (expr -> expr1 .)
    when            reduce using rule 25 (expr -> expr1 .)


state 57

    (9) stmt -> gets . OPEN_BRACKET IDENTIFIER CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 119


state 58

    (118) variable -> nil .

    OPEN_SQUARE     reduce using rule 118 (variable -> nil .)


state 59

    (2) multcompstmt -> newline . stmt1 multcompstmt
    (4) multcompstmt -> newline .
    (5) stmt1 -> . stmt
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    $end            reduce using rule 4 (multcompstmt -> newline .)
    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    function                       shift and go to state 42
    stmt                           shift and go to state 28
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    stmt1                          shift and go to state 120
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 60

    (89) arrayal -> variable . OPEN_SQUARE array_args CLOSE_SQUARE
    (90) arraya -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 121


state 61

    (13) keyclass -> class .

    IDENTIFIER      reduce using rule 13 (keyclass -> class .)


state 62

    (86) arrayd -> Array . OPEN_BRACKET array_size CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 122


state 63

    (6) stmt -> keydef . argdecl newline multstmt keyend
    (112) argdecl -> . OPEN_BRACKET arglist CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 124

    argdecl                        shift and go to state 123

state 64

    (128) opasgn -> MINUS_EQUALS .

    MINUS           reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    PLUS            reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    OPEN_BRACKET    reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    Array           reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    IDENTIFIER      reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    NUMBER          reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    true            reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    false           reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    GLOBAL          reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    nil             reduce using rule 128 (opasgn -> MINUS_EQUALS .)
    self            reduce using rule 128 (opasgn -> MINUS_EQUALS .)


state 65

    (129) opasgn -> PLUS_EQUALS .

    MINUS           reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    PLUS            reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    OPEN_BRACKET    reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    Array           reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    IDENTIFIER      reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    NUMBER          reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    true            reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    false           reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    GLOBAL          reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    nil             reduce using rule 129 (opasgn -> PLUS_EQUALS .)
    self            reduce using rule 129 (opasgn -> PLUS_EQUALS .)


state 66

    (132) opasgn -> XOR_EQUALS .

    MINUS           reduce using rule 132 (opasgn -> XOR_EQUALS .)
    PLUS            reduce using rule 132 (opasgn -> XOR_EQUALS .)
    OPEN_BRACKET    reduce using rule 132 (opasgn -> XOR_EQUALS .)
    Array           reduce using rule 132 (opasgn -> XOR_EQUALS .)
    IDENTIFIER      reduce using rule 132 (opasgn -> XOR_EQUALS .)
    NUMBER          reduce using rule 132 (opasgn -> XOR_EQUALS .)
    true            reduce using rule 132 (opasgn -> XOR_EQUALS .)
    false           reduce using rule 132 (opasgn -> XOR_EQUALS .)
    GLOBAL          reduce using rule 132 (opasgn -> XOR_EQUALS .)
    nil             reduce using rule 132 (opasgn -> XOR_EQUALS .)
    self            reduce using rule 132 (opasgn -> XOR_EQUALS .)


state 67

    (134) opasgn -> LEFT_SHIFT_EQUALS .

    MINUS           reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    PLUS            reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    OPEN_BRACKET    reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    Array           reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    IDENTIFIER      reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    NUMBER          reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    true            reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    false           reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    GLOBAL          reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    nil             reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)
    self            reduce using rule 134 (opasgn -> LEFT_SHIFT_EQUALS .)


state 68

    (131) opasgn -> AND_EQUALS .

    MINUS           reduce using rule 131 (opasgn -> AND_EQUALS .)
    PLUS            reduce using rule 131 (opasgn -> AND_EQUALS .)
    OPEN_BRACKET    reduce using rule 131 (opasgn -> AND_EQUALS .)
    Array           reduce using rule 131 (opasgn -> AND_EQUALS .)
    IDENTIFIER      reduce using rule 131 (opasgn -> AND_EQUALS .)
    NUMBER          reduce using rule 131 (opasgn -> AND_EQUALS .)
    true            reduce using rule 131 (opasgn -> AND_EQUALS .)
    false           reduce using rule 131 (opasgn -> AND_EQUALS .)
    GLOBAL          reduce using rule 131 (opasgn -> AND_EQUALS .)
    nil             reduce using rule 131 (opasgn -> AND_EQUALS .)
    self            reduce using rule 131 (opasgn -> AND_EQUALS .)


state 69

    (127) opasgn -> DIVIDE_EQUALS .

    MINUS           reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    PLUS            reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    OPEN_BRACKET    reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    Array           reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    IDENTIFIER      reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    NUMBER          reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    true            reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    false           reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    GLOBAL          reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    nil             reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)
    self            reduce using rule 127 (opasgn -> DIVIDE_EQUALS .)


state 70

    (133) opasgn -> RIGHT_SHIFT_EQUALS .

    MINUS           reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    PLUS            reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    OPEN_BRACKET    reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    Array           reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    IDENTIFIER      reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    NUMBER          reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    true            reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    false           reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    GLOBAL          reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    nil             reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)
    self            reduce using rule 133 (opasgn -> RIGHT_SHIFT_EQUALS .)


state 71

    (36) term0 -> mlhs EQUALS . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> mlhs EQUALS . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> mlhs EQUALS . IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (40) term1 -> mlhs EQUALS . mrhs
    (106) mrhs -> . term2
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    IDENTIFIER      shift and go to state 126
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 125
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    mrhs                           shift and go to state 127
    variable                       shift and go to state 77
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 72

    (130) opasgn -> OR_EQUALS .

    MINUS           reduce using rule 130 (opasgn -> OR_EQUALS .)
    PLUS            reduce using rule 130 (opasgn -> OR_EQUALS .)
    OPEN_BRACKET    reduce using rule 130 (opasgn -> OR_EQUALS .)
    Array           reduce using rule 130 (opasgn -> OR_EQUALS .)
    IDENTIFIER      reduce using rule 130 (opasgn -> OR_EQUALS .)
    NUMBER          reduce using rule 130 (opasgn -> OR_EQUALS .)
    true            reduce using rule 130 (opasgn -> OR_EQUALS .)
    false           reduce using rule 130 (opasgn -> OR_EQUALS .)
    GLOBAL          reduce using rule 130 (opasgn -> OR_EQUALS .)
    nil             reduce using rule 130 (opasgn -> OR_EQUALS .)
    self            reduce using rule 130 (opasgn -> OR_EQUALS .)


state 73

    (41) term1 -> mlhs opasgn . mrhs
    (106) mrhs -> . term2
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 125
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    mrhs                           shift and go to state 128
    variable                       shift and go to state 77
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 74

    (135) opasgn -> MULTIPLY_EQUALS .

    MINUS           reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    PLUS            reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    OPEN_BRACKET    reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    Array           reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    IDENTIFIER      reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    NUMBER          reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    true            reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    false           reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    GLOBAL          reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    nil             reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)
    self            reduce using rule 135 (opasgn -> MULTIPLY_EQUALS .)


state 75

    (126) opasgn -> MODULO_EQUALS .

    MINUS           reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    PLUS            reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    OPEN_BRACKET    reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    Array           reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    IDENTIFIER      reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    NUMBER          reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    true            reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    false           reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    GLOBAL          reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    nil             reduce using rule 126 (opasgn -> MODULO_EQUALS .)
    self            reduce using rule 126 (opasgn -> MODULO_EQUALS .)


state 76

    (85) classvar -> IDENTIFIER . DOT IDENTIFIER
    (137) varname -> IDENTIFIER .

    DOT             shift and go to state 113
    MULTIPLY        reduce using rule 137 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 137 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 137 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 137 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 137 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 137 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 137 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 137 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 137 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 137 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 137 (varname -> IDENTIFIER .)
    LESS            reduce using rule 137 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 137 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 137 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 137 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 137 (varname -> IDENTIFIER .)
    puts            reduce using rule 137 (varname -> IDENTIFIER .)
    print           reduce using rule 137 (varname -> IDENTIFIER .)
    gets            reduce using rule 137 (varname -> IDENTIFIER .)
    break           reduce using rule 137 (varname -> IDENTIFIER .)
    def             reduce using rule 137 (varname -> IDENTIFIER .)
    class           reduce using rule 137 (varname -> IDENTIFIER .)
    if              reduce using rule 137 (varname -> IDENTIFIER .)
    while           reduce using rule 137 (varname -> IDENTIFIER .)
    until           reduce using rule 137 (varname -> IDENTIFIER .)
    case            reduce using rule 137 (varname -> IDENTIFIER .)
    for             reduce using rule 137 (varname -> IDENTIFIER .)
    return          reduce using rule 137 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 137 (varname -> IDENTIFIER .)
    nil             reduce using rule 137 (varname -> IDENTIFIER .)
    self            reduce using rule 137 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 137 (varname -> IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 137 (varname -> IDENTIFIER .)
    Array           reduce using rule 137 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 137 (varname -> IDENTIFIER .)
    true            reduce using rule 137 (varname -> IDENTIFIER .)
    false           reduce using rule 137 (varname -> IDENTIFIER .)
    $end            reduce using rule 137 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 137 (varname -> IDENTIFIER .)
    when            reduce using rule 137 (varname -> IDENTIFIER .)
    then            reduce using rule 137 (varname -> IDENTIFIER .)
    else            reduce using rule 137 (varname -> IDENTIFIER .)
    end             reduce using rule 137 (varname -> IDENTIFIER .)
    elsif           reduce using rule 137 (varname -> IDENTIFIER .)
    do              reduce using rule 137 (varname -> IDENTIFIER .)
    COMMA           reduce using rule 137 (varname -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 137 (varname -> IDENTIFIER .)
    CLOSE_SQUARE    reduce using rule 137 (varname -> IDENTIFIER .)


state 77

    (90) arraya -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 129


state 78

    (84) primary -> varname .
    (117) variable -> varname .

    MULTIPLY        reduce using rule 84 (primary -> varname .)
    DIVIDE          reduce using rule 84 (primary -> varname .)
    MODULO          reduce using rule 84 (primary -> varname .)
    PLUS            reduce using rule 84 (primary -> varname .)
    MINUS           reduce using rule 84 (primary -> varname .)
    LEFT_SHIFT      reduce using rule 84 (primary -> varname .)
    RIGHT_SHIFT     reduce using rule 84 (primary -> varname .)
    BIT_AND         reduce using rule 84 (primary -> varname .)
    BIT_XOR         reduce using rule 84 (primary -> varname .)
    BIT_OR          reduce using rule 84 (primary -> varname .)
    DOUBLE_EQUALS   reduce using rule 84 (primary -> varname .)
    NOT_EQUALS      reduce using rule 84 (primary -> varname .)
    EQUAL_TILDE     reduce using rule 84 (primary -> varname .)
    COMPARISON      reduce using rule 84 (primary -> varname .)
    LESS            reduce using rule 84 (primary -> varname .)
    LESS_EQUALS     reduce using rule 84 (primary -> varname .)
    GREATER         reduce using rule 84 (primary -> varname .)
    GREATER_EQUALS  reduce using rule 84 (primary -> varname .)
    INCL_RANGE      reduce using rule 84 (primary -> varname .)
    EXCL_RANGE      reduce using rule 84 (primary -> varname .)
    LOGICAL_OR      reduce using rule 84 (primary -> varname .)
    LOGICAL_AND     reduce using rule 84 (primary -> varname .)
    SEMI_COLON      reduce using rule 84 (primary -> varname .)
    NEWLINE         reduce using rule 84 (primary -> varname .)
    puts            reduce using rule 84 (primary -> varname .)
    print           reduce using rule 84 (primary -> varname .)
    gets            reduce using rule 84 (primary -> varname .)
    break           reduce using rule 84 (primary -> varname .)
    def             reduce using rule 84 (primary -> varname .)
    class           reduce using rule 84 (primary -> varname .)
    if              reduce using rule 84 (primary -> varname .)
    while           reduce using rule 84 (primary -> varname .)
    until           reduce using rule 84 (primary -> varname .)
    case            reduce using rule 84 (primary -> varname .)
    for             reduce using rule 84 (primary -> varname .)
    return          reduce using rule 84 (primary -> varname .)
    IDENTIFIER      reduce using rule 84 (primary -> varname .)
    nil             reduce using rule 84 (primary -> varname .)
    self            reduce using rule 84 (primary -> varname .)
    GLOBAL          reduce using rule 84 (primary -> varname .)
    OPEN_BRACKET    reduce using rule 84 (primary -> varname .)
    Array           reduce using rule 84 (primary -> varname .)
    NUMBER          reduce using rule 84 (primary -> varname .)
    true            reduce using rule 84 (primary -> varname .)
    false           reduce using rule 84 (primary -> varname .)
    $end            reduce using rule 84 (primary -> varname .)
    CLOSE_BRACKET   reduce using rule 84 (primary -> varname .)
    when            reduce using rule 84 (primary -> varname .)
    then            reduce using rule 84 (primary -> varname .)
    else            reduce using rule 84 (primary -> varname .)
    end             reduce using rule 84 (primary -> varname .)
    elsif           reduce using rule 84 (primary -> varname .)
    do              reduce using rule 84 (primary -> varname .)
    COMMA           reduce using rule 84 (primary -> varname .)
    CLOSE_SQUARE    reduce using rule 84 (primary -> varname .)
    OPEN_SQUARE     reduce using rule 117 (variable -> varname .)


state 79

    (82) primary -> classvar .

    MULTIPLY        reduce using rule 82 (primary -> classvar .)
    DIVIDE          reduce using rule 82 (primary -> classvar .)
    MODULO          reduce using rule 82 (primary -> classvar .)
    PLUS            reduce using rule 82 (primary -> classvar .)
    MINUS           reduce using rule 82 (primary -> classvar .)
    LEFT_SHIFT      reduce using rule 82 (primary -> classvar .)
    RIGHT_SHIFT     reduce using rule 82 (primary -> classvar .)
    BIT_AND         reduce using rule 82 (primary -> classvar .)
    BIT_XOR         reduce using rule 82 (primary -> classvar .)
    BIT_OR          reduce using rule 82 (primary -> classvar .)
    DOUBLE_EQUALS   reduce using rule 82 (primary -> classvar .)
    NOT_EQUALS      reduce using rule 82 (primary -> classvar .)
    EQUAL_TILDE     reduce using rule 82 (primary -> classvar .)
    COMPARISON      reduce using rule 82 (primary -> classvar .)
    LESS            reduce using rule 82 (primary -> classvar .)
    LESS_EQUALS     reduce using rule 82 (primary -> classvar .)
    GREATER         reduce using rule 82 (primary -> classvar .)
    GREATER_EQUALS  reduce using rule 82 (primary -> classvar .)
    INCL_RANGE      reduce using rule 82 (primary -> classvar .)
    EXCL_RANGE      reduce using rule 82 (primary -> classvar .)
    LOGICAL_OR      reduce using rule 82 (primary -> classvar .)
    LOGICAL_AND     reduce using rule 82 (primary -> classvar .)
    SEMI_COLON      reduce using rule 82 (primary -> classvar .)
    NEWLINE         reduce using rule 82 (primary -> classvar .)
    puts            reduce using rule 82 (primary -> classvar .)
    print           reduce using rule 82 (primary -> classvar .)
    gets            reduce using rule 82 (primary -> classvar .)
    break           reduce using rule 82 (primary -> classvar .)
    def             reduce using rule 82 (primary -> classvar .)
    class           reduce using rule 82 (primary -> classvar .)
    if              reduce using rule 82 (primary -> classvar .)
    while           reduce using rule 82 (primary -> classvar .)
    until           reduce using rule 82 (primary -> classvar .)
    case            reduce using rule 82 (primary -> classvar .)
    for             reduce using rule 82 (primary -> classvar .)
    return          reduce using rule 82 (primary -> classvar .)
    IDENTIFIER      reduce using rule 82 (primary -> classvar .)
    nil             reduce using rule 82 (primary -> classvar .)
    self            reduce using rule 82 (primary -> classvar .)
    GLOBAL          reduce using rule 82 (primary -> classvar .)
    OPEN_BRACKET    reduce using rule 82 (primary -> classvar .)
    Array           reduce using rule 82 (primary -> classvar .)
    NUMBER          reduce using rule 82 (primary -> classvar .)
    true            reduce using rule 82 (primary -> classvar .)
    false           reduce using rule 82 (primary -> classvar .)
    $end            reduce using rule 82 (primary -> classvar .)
    CLOSE_BRACKET   reduce using rule 82 (primary -> classvar .)
    when            reduce using rule 82 (primary -> classvar .)
    then            reduce using rule 82 (primary -> classvar .)
    else            reduce using rule 82 (primary -> classvar .)
    end             reduce using rule 82 (primary -> classvar .)
    elsif           reduce using rule 82 (primary -> classvar .)
    do              reduce using rule 82 (primary -> classvar .)
    COMMA           reduce using rule 82 (primary -> classvar .)
    CLOSE_SQUARE    reduce using rule 82 (primary -> classvar .)


state 80

    (74) term11 -> MINUS term11 .

    MULTIPLY        reduce using rule 74 (term11 -> MINUS term11 .)
    DIVIDE          reduce using rule 74 (term11 -> MINUS term11 .)
    MODULO          reduce using rule 74 (term11 -> MINUS term11 .)
    PLUS            reduce using rule 74 (term11 -> MINUS term11 .)
    MINUS           reduce using rule 74 (term11 -> MINUS term11 .)
    LEFT_SHIFT      reduce using rule 74 (term11 -> MINUS term11 .)
    RIGHT_SHIFT     reduce using rule 74 (term11 -> MINUS term11 .)
    BIT_AND         reduce using rule 74 (term11 -> MINUS term11 .)
    BIT_XOR         reduce using rule 74 (term11 -> MINUS term11 .)
    BIT_OR          reduce using rule 74 (term11 -> MINUS term11 .)
    DOUBLE_EQUALS   reduce using rule 74 (term11 -> MINUS term11 .)
    NOT_EQUALS      reduce using rule 74 (term11 -> MINUS term11 .)
    EQUAL_TILDE     reduce using rule 74 (term11 -> MINUS term11 .)
    COMPARISON      reduce using rule 74 (term11 -> MINUS term11 .)
    LESS            reduce using rule 74 (term11 -> MINUS term11 .)
    LESS_EQUALS     reduce using rule 74 (term11 -> MINUS term11 .)
    GREATER         reduce using rule 74 (term11 -> MINUS term11 .)
    GREATER_EQUALS  reduce using rule 74 (term11 -> MINUS term11 .)
    INCL_RANGE      reduce using rule 74 (term11 -> MINUS term11 .)
    EXCL_RANGE      reduce using rule 74 (term11 -> MINUS term11 .)
    LOGICAL_OR      reduce using rule 74 (term11 -> MINUS term11 .)
    LOGICAL_AND     reduce using rule 74 (term11 -> MINUS term11 .)
    SEMI_COLON      reduce using rule 74 (term11 -> MINUS term11 .)
    NEWLINE         reduce using rule 74 (term11 -> MINUS term11 .)
    puts            reduce using rule 74 (term11 -> MINUS term11 .)
    print           reduce using rule 74 (term11 -> MINUS term11 .)
    gets            reduce using rule 74 (term11 -> MINUS term11 .)
    break           reduce using rule 74 (term11 -> MINUS term11 .)
    def             reduce using rule 74 (term11 -> MINUS term11 .)
    class           reduce using rule 74 (term11 -> MINUS term11 .)
    if              reduce using rule 74 (term11 -> MINUS term11 .)
    while           reduce using rule 74 (term11 -> MINUS term11 .)
    until           reduce using rule 74 (term11 -> MINUS term11 .)
    case            reduce using rule 74 (term11 -> MINUS term11 .)
    for             reduce using rule 74 (term11 -> MINUS term11 .)
    return          reduce using rule 74 (term11 -> MINUS term11 .)
    IDENTIFIER      reduce using rule 74 (term11 -> MINUS term11 .)
    nil             reduce using rule 74 (term11 -> MINUS term11 .)
    self            reduce using rule 74 (term11 -> MINUS term11 .)
    GLOBAL          reduce using rule 74 (term11 -> MINUS term11 .)
    OPEN_BRACKET    reduce using rule 74 (term11 -> MINUS term11 .)
    Array           reduce using rule 74 (term11 -> MINUS term11 .)
    NUMBER          reduce using rule 74 (term11 -> MINUS term11 .)
    true            reduce using rule 74 (term11 -> MINUS term11 .)
    false           reduce using rule 74 (term11 -> MINUS term11 .)
    when            reduce using rule 74 (term11 -> MINUS term11 .)
    end             reduce using rule 74 (term11 -> MINUS term11 .)
    $end            reduce using rule 74 (term11 -> MINUS term11 .)
    CLOSE_BRACKET   reduce using rule 74 (term11 -> MINUS term11 .)
    then            reduce using rule 74 (term11 -> MINUS term11 .)
    else            reduce using rule 74 (term11 -> MINUS term11 .)
    elsif           reduce using rule 74 (term11 -> MINUS term11 .)
    do              reduce using rule 74 (term11 -> MINUS term11 .)
    COMMA           reduce using rule 74 (term11 -> MINUS term11 .)


state 81

    (79) primary -> OPEN_BRACKET expr2 . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 130


state 82

    (76) term12 -> PLUS term12 .

    MULTIPLY        reduce using rule 76 (term12 -> PLUS term12 .)
    DIVIDE          reduce using rule 76 (term12 -> PLUS term12 .)
    MODULO          reduce using rule 76 (term12 -> PLUS term12 .)
    PLUS            reduce using rule 76 (term12 -> PLUS term12 .)
    MINUS           reduce using rule 76 (term12 -> PLUS term12 .)
    LEFT_SHIFT      reduce using rule 76 (term12 -> PLUS term12 .)
    RIGHT_SHIFT     reduce using rule 76 (term12 -> PLUS term12 .)
    BIT_AND         reduce using rule 76 (term12 -> PLUS term12 .)
    BIT_XOR         reduce using rule 76 (term12 -> PLUS term12 .)
    BIT_OR          reduce using rule 76 (term12 -> PLUS term12 .)
    DOUBLE_EQUALS   reduce using rule 76 (term12 -> PLUS term12 .)
    NOT_EQUALS      reduce using rule 76 (term12 -> PLUS term12 .)
    EQUAL_TILDE     reduce using rule 76 (term12 -> PLUS term12 .)
    COMPARISON      reduce using rule 76 (term12 -> PLUS term12 .)
    LESS            reduce using rule 76 (term12 -> PLUS term12 .)
    LESS_EQUALS     reduce using rule 76 (term12 -> PLUS term12 .)
    GREATER         reduce using rule 76 (term12 -> PLUS term12 .)
    GREATER_EQUALS  reduce using rule 76 (term12 -> PLUS term12 .)
    INCL_RANGE      reduce using rule 76 (term12 -> PLUS term12 .)
    EXCL_RANGE      reduce using rule 76 (term12 -> PLUS term12 .)
    LOGICAL_OR      reduce using rule 76 (term12 -> PLUS term12 .)
    LOGICAL_AND     reduce using rule 76 (term12 -> PLUS term12 .)
    SEMI_COLON      reduce using rule 76 (term12 -> PLUS term12 .)
    NEWLINE         reduce using rule 76 (term12 -> PLUS term12 .)
    puts            reduce using rule 76 (term12 -> PLUS term12 .)
    print           reduce using rule 76 (term12 -> PLUS term12 .)
    gets            reduce using rule 76 (term12 -> PLUS term12 .)
    break           reduce using rule 76 (term12 -> PLUS term12 .)
    def             reduce using rule 76 (term12 -> PLUS term12 .)
    class           reduce using rule 76 (term12 -> PLUS term12 .)
    if              reduce using rule 76 (term12 -> PLUS term12 .)
    while           reduce using rule 76 (term12 -> PLUS term12 .)
    until           reduce using rule 76 (term12 -> PLUS term12 .)
    case            reduce using rule 76 (term12 -> PLUS term12 .)
    for             reduce using rule 76 (term12 -> PLUS term12 .)
    return          reduce using rule 76 (term12 -> PLUS term12 .)
    IDENTIFIER      reduce using rule 76 (term12 -> PLUS term12 .)
    nil             reduce using rule 76 (term12 -> PLUS term12 .)
    self            reduce using rule 76 (term12 -> PLUS term12 .)
    GLOBAL          reduce using rule 76 (term12 -> PLUS term12 .)
    OPEN_BRACKET    reduce using rule 76 (term12 -> PLUS term12 .)
    Array           reduce using rule 76 (term12 -> PLUS term12 .)
    NUMBER          reduce using rule 76 (term12 -> PLUS term12 .)
    true            reduce using rule 76 (term12 -> PLUS term12 .)
    false           reduce using rule 76 (term12 -> PLUS term12 .)
    $end            reduce using rule 76 (term12 -> PLUS term12 .)
    CLOSE_BRACKET   reduce using rule 76 (term12 -> PLUS term12 .)
    when            reduce using rule 76 (term12 -> PLUS term12 .)
    then            reduce using rule 76 (term12 -> PLUS term12 .)
    else            reduce using rule 76 (term12 -> PLUS term12 .)
    end             reduce using rule 76 (term12 -> PLUS term12 .)
    elsif           reduce using rule 76 (term12 -> PLUS term12 .)
    do              reduce using rule 76 (term12 -> PLUS term12 .)
    COMMA           reduce using rule 76 (term12 -> PLUS term12 .)


state 83

    (27) expr1 -> return term2 .

    SEMI_COLON      reduce using rule 27 (expr1 -> return term2 .)
    NEWLINE         reduce using rule 27 (expr1 -> return term2 .)
    puts            reduce using rule 27 (expr1 -> return term2 .)
    print           reduce using rule 27 (expr1 -> return term2 .)
    gets            reduce using rule 27 (expr1 -> return term2 .)
    break           reduce using rule 27 (expr1 -> return term2 .)
    def             reduce using rule 27 (expr1 -> return term2 .)
    class           reduce using rule 27 (expr1 -> return term2 .)
    if              reduce using rule 27 (expr1 -> return term2 .)
    while           reduce using rule 27 (expr1 -> return term2 .)
    until           reduce using rule 27 (expr1 -> return term2 .)
    case            reduce using rule 27 (expr1 -> return term2 .)
    for             reduce using rule 27 (expr1 -> return term2 .)
    return          reduce using rule 27 (expr1 -> return term2 .)
    IDENTIFIER      reduce using rule 27 (expr1 -> return term2 .)
    nil             reduce using rule 27 (expr1 -> return term2 .)
    self            reduce using rule 27 (expr1 -> return term2 .)
    GLOBAL          reduce using rule 27 (expr1 -> return term2 .)
    MINUS           reduce using rule 27 (expr1 -> return term2 .)
    PLUS            reduce using rule 27 (expr1 -> return term2 .)
    OPEN_BRACKET    reduce using rule 27 (expr1 -> return term2 .)
    Array           reduce using rule 27 (expr1 -> return term2 .)
    NUMBER          reduce using rule 27 (expr1 -> return term2 .)
    true            reduce using rule 27 (expr1 -> return term2 .)
    false           reduce using rule 27 (expr1 -> return term2 .)
    $end            reduce using rule 27 (expr1 -> return term2 .)
    end             reduce using rule 27 (expr1 -> return term2 .)
    then            reduce using rule 27 (expr1 -> return term2 .)
    elsif           reduce using rule 27 (expr1 -> return term2 .)
    else            reduce using rule 27 (expr1 -> return term2 .)
    when            reduce using rule 27 (expr1 -> return term2 .)
    do              reduce using rule 27 (expr1 -> return term2 .)


state 84

    (70) term10 -> term10 MULTIPLY . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 131

state 85

    (72) term10 -> term10 MODULO . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 132

state 86

    (71) term10 -> term10 DIVIDE . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 133

state 87

    (62) term7 -> term7 BIT_AND . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 134
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 88

    (59) term6 -> term6 BIT_XOR . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 135
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 89

    (60) term6 -> term6 BIT_OR . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 136
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 90

    (52) term4 -> term5 COMPARISON . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 137
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 91

    (49) term4 -> term5 DOUBLE_EQUALS . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 138
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 92

    (56) term5 -> term5 GREATER . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 139
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 93

    (54) term5 -> term5 LESS . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 140
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 94

    (50) term4 -> term5 NOT_EQUALS . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 141
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 95

    (55) term5 -> term5 LESS_EQUALS . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 142
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 96

    (51) term4 -> term5 EQUAL_TILDE . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 143
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 97

    (57) term5 -> term5 GREATER_EQUALS . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 144
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 98

    (10) stmt -> keyclass IDENTIFIER . newline multstmt keyend
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    empty                          shift and go to state 41
    newline                        shift and go to state 145

state 99

    (44) term2 -> term3 EXCL_RANGE . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 146
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 100

    (43) term2 -> term3 INCL_RANGE . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 147
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 101

    (46) term3 -> term3 LOGICAL_OR . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 148
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 102

    (47) term3 -> term3 LOGICAL_AND . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 149
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 103

    (67) term9 -> term9 PLUS . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 150

state 104

    (68) term9 -> term9 MINUS . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 151

state 105

    (65) term8 -> term8 RIGHT_SHIFT . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 152
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 106

    (64) term8 -> term8 LEFT_SHIFT . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 33
    term9                          shift and go to state 153
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 107

    (24) expr -> for M_1 . mlhs in expr1 pdo M_1 multstmt end M_1
    (102) mlhs -> . mlhsitem
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER

    IDENTIFIER      shift and go to state 158
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32

    varname                        shift and go to state 154
    classvar                       shift and go to state 155
    mlhs                           shift and go to state 156
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 157
    arrayal                        shift and go to state 35

state 108

    (26) M_1 -> empty .

    puts            reduce using rule 26 (M_1 -> empty .)
    print           reduce using rule 26 (M_1 -> empty .)
    gets            reduce using rule 26 (M_1 -> empty .)
    break           reduce using rule 26 (M_1 -> empty .)
    def             reduce using rule 26 (M_1 -> empty .)
    class           reduce using rule 26 (M_1 -> empty .)
    if              reduce using rule 26 (M_1 -> empty .)
    while           reduce using rule 26 (M_1 -> empty .)
    until           reduce using rule 26 (M_1 -> empty .)
    case            reduce using rule 26 (M_1 -> empty .)
    for             reduce using rule 26 (M_1 -> empty .)
    return          reduce using rule 26 (M_1 -> empty .)
    IDENTIFIER      reduce using rule 26 (M_1 -> empty .)
    nil             reduce using rule 26 (M_1 -> empty .)
    self            reduce using rule 26 (M_1 -> empty .)
    GLOBAL          reduce using rule 26 (M_1 -> empty .)
    MINUS           reduce using rule 26 (M_1 -> empty .)
    PLUS            reduce using rule 26 (M_1 -> empty .)
    OPEN_BRACKET    reduce using rule 26 (M_1 -> empty .)
    Array           reduce using rule 26 (M_1 -> empty .)
    NUMBER          reduce using rule 26 (M_1 -> empty .)
    true            reduce using rule 26 (M_1 -> empty .)
    false           reduce using rule 26 (M_1 -> empty .)
    when            reduce using rule 26 (M_1 -> empty .)
    end             reduce using rule 26 (M_1 -> empty .)
    SEMI_COLON      reduce using rule 26 (M_1 -> empty .)
    NEWLINE         reduce using rule 26 (M_1 -> empty .)
    $end            reduce using rule 26 (M_1 -> empty .)
    else            reduce using rule 26 (M_1 -> empty .)
    elsif           reduce using rule 26 (M_1 -> empty .)
    then            reduce using rule 26 (M_1 -> empty .)


state 109

    (8) stmt -> print OPEN_BRACKET . primary CLOSE_BRACKET
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 159
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50

state 110

    (3) multcompstmt -> stmt1 multcompstmt .

    $end            reduce using rule 3 (multcompstmt -> stmt1 multcompstmt .)


state 111

    (7) stmt -> puts OPEN_BRACKET . STRING CLOSE_BRACKET

    STRING          shift and go to state 160


state 112

    (33) function -> IDENTIFIER OPEN_BRACKET . callargs CLOSE_BRACKET
    (34) function -> IDENTIFIER OPEN_BRACKET . CLOSE_BRACKET
    (107) callargs -> . callarglist
    (108) callarglist -> . term2 callmultarglist
    (109) callarglist -> . empty
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (141) empty -> .
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

  ! shift/reduce conflict for CLOSE_BRACKET resolved as shift
    CLOSE_BRACKET   shift and go to state 161
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

  ! CLOSE_BRACKET   [ reduce using rule 141 (empty -> .) ]

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 162
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    empty                          shift and go to state 163
    callarglist                    shift and go to state 164
    variable                       shift and go to state 77
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    callargs                       shift and go to state 165
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 113

    (85) classvar -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 166


state 114

    (22) expr -> until M_1 . expr1 pdo M_1 multstmt end M_1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    literal                        shift and go to state 37
    expr1                          shift and go to state 167
    call                           shift and go to state 38
    function                       shift and go to state 42
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    varname                        shift and go to state 30
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 115

    (23) expr -> case expr1 . newline multcase end M_1
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    when            reduce using rule 141 (empty -> .)

    empty                          shift and go to state 41
    newline                        shift and go to state 168

state 116

    (21) expr -> while M_1 . expr1 pdo M_1 multstmt end M_1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    literal                        shift and go to state 37
    expr1                          shift and go to state 169
    call                           shift and go to state 38
    function                       shift and go to state 42
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    varname                        shift and go to state 30
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 117

    (14) keydef -> def IDENTIFIER .

    OPEN_BRACKET    reduce using rule 14 (keydef -> def IDENTIFIER .)


state 118

    (18) expr -> if expr1 . pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> if expr1 . pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> if expr1 . pthen M_1 multstmt end M_1
    (120) pthen -> . newline
    (121) pthen -> . then
    (122) pthen -> . newline then
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

  ! shift/reduce conflict for then resolved as shift
    then            shift and go to state 170
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)

  ! then            [ reduce using rule 141 (empty -> .) ]

    newline                        shift and go to state 171
    pthen                          shift and go to state 172
    empty                          shift and go to state 41

state 119

    (9) stmt -> gets OPEN_BRACKET . IDENTIFIER CLOSE_BRACKET

    IDENTIFIER      shift and go to state 173


state 120

    (2) multcompstmt -> newline stmt1 . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (5) stmt1 -> . stmt
    (141) empty -> .
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

  ! shift/reduce conflict for puts resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for gets resolved as shift
  ! shift/reduce conflict for break resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for while resolved as shift
  ! shift/reduce conflict for until resolved as shift
  ! shift/reduce conflict for case resolved as shift
  ! shift/reduce conflict for for resolved as shift
  ! shift/reduce conflict for return resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for nil resolved as shift
  ! shift/reduce conflict for self resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
  ! shift/reduce conflict for Array resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for true resolved as shift
  ! shift/reduce conflict for false resolved as shift
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    $end            reduce using rule 141 (empty -> .)
    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

  ! puts            [ reduce using rule 141 (empty -> .) ]
  ! print           [ reduce using rule 141 (empty -> .) ]
  ! gets            [ reduce using rule 141 (empty -> .) ]
  ! break           [ reduce using rule 141 (empty -> .) ]
  ! def             [ reduce using rule 141 (empty -> .) ]
  ! class           [ reduce using rule 141 (empty -> .) ]
  ! if              [ reduce using rule 141 (empty -> .) ]
  ! while           [ reduce using rule 141 (empty -> .) ]
  ! until           [ reduce using rule 141 (empty -> .) ]
  ! case            [ reduce using rule 141 (empty -> .) ]
  ! for             [ reduce using rule 141 (empty -> .) ]
  ! return          [ reduce using rule 141 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 141 (empty -> .) ]
  ! nil             [ reduce using rule 141 (empty -> .) ]
  ! self            [ reduce using rule 141 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 141 (empty -> .) ]
  ! MINUS           [ reduce using rule 141 (empty -> .) ]
  ! PLUS            [ reduce using rule 141 (empty -> .) ]
  ! OPEN_BRACKET    [ reduce using rule 141 (empty -> .) ]
  ! Array           [ reduce using rule 141 (empty -> .) ]
  ! NUMBER          [ reduce using rule 141 (empty -> .) ]
  ! true            [ reduce using rule 141 (empty -> .) ]
  ! false           [ reduce using rule 141 (empty -> .) ]

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 41
    function                       shift and go to state 42
    newline                        shift and go to state 59
    multcompstmt                   shift and go to state 174
    stmt                           shift and go to state 28
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    stmt1                          shift and go to state 31
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 121

    (89) arrayal -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (90) arraya -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (91) array_args -> . primary COMMA array_args
    (92) array_args -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 176
    array_args                     shift and go to state 175
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50

state 122

    (86) arrayd -> Array OPEN_BRACKET . array_size CLOSE_BRACKET
    (87) array_size -> . term2 COMMA array_size
    (88) array_size -> . term2
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 177
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    array_size                     shift and go to state 178
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 123

    (6) stmt -> keydef argdecl . newline multstmt keyend
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    newline                        shift and go to state 179
    empty                          shift and go to state 41

state 124

    (112) argdecl -> OPEN_BRACKET . arglist CLOSE_BRACKET
    (113) arglist -> . IDENTIFIER multarglist
    (114) arglist -> . empty
    (141) empty -> .

    IDENTIFIER      shift and go to state 181
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    arglist                        shift and go to state 180
    empty                          shift and go to state 182

state 125

    (106) mrhs -> term2 .

    SEMI_COLON      reduce using rule 106 (mrhs -> term2 .)
    NEWLINE         reduce using rule 106 (mrhs -> term2 .)
    puts            reduce using rule 106 (mrhs -> term2 .)
    print           reduce using rule 106 (mrhs -> term2 .)
    gets            reduce using rule 106 (mrhs -> term2 .)
    break           reduce using rule 106 (mrhs -> term2 .)
    def             reduce using rule 106 (mrhs -> term2 .)
    class           reduce using rule 106 (mrhs -> term2 .)
    if              reduce using rule 106 (mrhs -> term2 .)
    while           reduce using rule 106 (mrhs -> term2 .)
    until           reduce using rule 106 (mrhs -> term2 .)
    case            reduce using rule 106 (mrhs -> term2 .)
    for             reduce using rule 106 (mrhs -> term2 .)
    return          reduce using rule 106 (mrhs -> term2 .)
    IDENTIFIER      reduce using rule 106 (mrhs -> term2 .)
    nil             reduce using rule 106 (mrhs -> term2 .)
    self            reduce using rule 106 (mrhs -> term2 .)
    GLOBAL          reduce using rule 106 (mrhs -> term2 .)
    MINUS           reduce using rule 106 (mrhs -> term2 .)
    PLUS            reduce using rule 106 (mrhs -> term2 .)
    OPEN_BRACKET    reduce using rule 106 (mrhs -> term2 .)
    Array           reduce using rule 106 (mrhs -> term2 .)
    NUMBER          reduce using rule 106 (mrhs -> term2 .)
    true            reduce using rule 106 (mrhs -> term2 .)
    false           reduce using rule 106 (mrhs -> term2 .)
    $end            reduce using rule 106 (mrhs -> term2 .)
    CLOSE_BRACKET   reduce using rule 106 (mrhs -> term2 .)
    when            reduce using rule 106 (mrhs -> term2 .)
    then            reduce using rule 106 (mrhs -> term2 .)
    else            reduce using rule 106 (mrhs -> term2 .)
    end             reduce using rule 106 (mrhs -> term2 .)
    elsif           reduce using rule 106 (mrhs -> term2 .)
    do              reduce using rule 106 (mrhs -> term2 .)


state 126

    (36) term0 -> mlhs EQUALS IDENTIFIER . OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> mlhs EQUALS IDENTIFIER . OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> mlhs EQUALS IDENTIFIER . DOT new OPEN_BRACKET CLOSE_BRACKET
    (85) classvar -> IDENTIFIER . DOT IDENTIFIER
    (137) varname -> IDENTIFIER .

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    OPEN_BRACKET    shift and go to state 183
    DOT             shift and go to state 184
    MULTIPLY        reduce using rule 137 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 137 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 137 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 137 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 137 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 137 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 137 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 137 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 137 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 137 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 137 (varname -> IDENTIFIER .)
    LESS            reduce using rule 137 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 137 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 137 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 137 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 137 (varname -> IDENTIFIER .)
    puts            reduce using rule 137 (varname -> IDENTIFIER .)
    print           reduce using rule 137 (varname -> IDENTIFIER .)
    gets            reduce using rule 137 (varname -> IDENTIFIER .)
    break           reduce using rule 137 (varname -> IDENTIFIER .)
    def             reduce using rule 137 (varname -> IDENTIFIER .)
    class           reduce using rule 137 (varname -> IDENTIFIER .)
    if              reduce using rule 137 (varname -> IDENTIFIER .)
    while           reduce using rule 137 (varname -> IDENTIFIER .)
    until           reduce using rule 137 (varname -> IDENTIFIER .)
    case            reduce using rule 137 (varname -> IDENTIFIER .)
    for             reduce using rule 137 (varname -> IDENTIFIER .)
    return          reduce using rule 137 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 137 (varname -> IDENTIFIER .)
    nil             reduce using rule 137 (varname -> IDENTIFIER .)
    self            reduce using rule 137 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 137 (varname -> IDENTIFIER .)
    Array           reduce using rule 137 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 137 (varname -> IDENTIFIER .)
    true            reduce using rule 137 (varname -> IDENTIFIER .)
    false           reduce using rule 137 (varname -> IDENTIFIER .)
    $end            reduce using rule 137 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 137 (varname -> IDENTIFIER .)
    when            reduce using rule 137 (varname -> IDENTIFIER .)
    then            reduce using rule 137 (varname -> IDENTIFIER .)
    else            reduce using rule 137 (varname -> IDENTIFIER .)
    end             reduce using rule 137 (varname -> IDENTIFIER .)
    elsif           reduce using rule 137 (varname -> IDENTIFIER .)
    do              reduce using rule 137 (varname -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 137 (varname -> IDENTIFIER .)

  ! OPEN_BRACKET    [ reduce using rule 137 (varname -> IDENTIFIER .) ]


state 127

    (40) term1 -> mlhs EQUALS mrhs .

    SEMI_COLON      reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    NEWLINE         reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    when            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    puts            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    print           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    gets            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    break           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    def             reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    class           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    if              reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    while           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    until           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    case            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    for             reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    return          reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    IDENTIFIER      reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    nil             reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    self            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    GLOBAL          reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    MINUS           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    PLUS            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    OPEN_BRACKET    reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    Array           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    NUMBER          reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    true            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    false           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    end             reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    $end            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    then            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    elsif           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    else            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    do              reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    CLOSE_BRACKET   reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)


state 128

    (41) term1 -> mlhs opasgn mrhs .

    SEMI_COLON      reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    NEWLINE         reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    when            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    puts            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    print           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    gets            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    break           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    def             reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    class           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    if              reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    while           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    until           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    case            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    for             reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    return          reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    IDENTIFIER      reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    nil             reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    self            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    GLOBAL          reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    MINUS           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    PLUS            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    OPEN_BRACKET    reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    Array           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    NUMBER          reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    true            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    false           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    end             reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    $end            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    then            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    elsif           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    else            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    do              reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    CLOSE_BRACKET   reduce using rule 41 (term1 -> mlhs opasgn mrhs .)


state 129

    (90) arraya -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (91) array_args -> . primary COMMA array_args
    (92) array_args -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 176
    array_args                     shift and go to state 185
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50

state 130

    (79) primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .

    MULTIPLY        reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    DIVIDE          reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    MODULO          reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    PLUS            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    MINUS           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LEFT_SHIFT      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    RIGHT_SHIFT     reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_AND         reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_XOR         reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_OR          reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    DOUBLE_EQUALS   reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NOT_EQUALS      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    EQUAL_TILDE     reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    COMPARISON      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LESS            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LESS_EQUALS     reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GREATER         reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GREATER_EQUALS  reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    INCL_RANGE      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    EXCL_RANGE      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LOGICAL_OR      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LOGICAL_AND     reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    do              reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    SEMI_COLON      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NEWLINE         reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    puts            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    print           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    gets            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    break           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    def             reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    class           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    if              reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    while           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    until           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    case            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    for             reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    return          reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    nil             reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    self            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GLOBAL          reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    Array           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NUMBER          reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    true            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    false           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    end             reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    when            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    $end            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    then            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    else            reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    elsif           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    COMMA           reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    CLOSE_SQUARE    reduce using rule 79 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)


state 131

    (70) term10 -> term10 MULTIPLY term11 .

    MULTIPLY        reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    DIVIDE          reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    MODULO          reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    PLUS            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    MINUS           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    LEFT_SHIFT      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    RIGHT_SHIFT     reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    BIT_AND         reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    BIT_XOR         reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    BIT_OR          reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    DOUBLE_EQUALS   reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    NOT_EQUALS      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    EQUAL_TILDE     reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    COMPARISON      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    LESS            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    LESS_EQUALS     reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    GREATER         reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    GREATER_EQUALS  reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    INCL_RANGE      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    EXCL_RANGE      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    LOGICAL_OR      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    LOGICAL_AND     reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    SEMI_COLON      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    NEWLINE         reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    puts            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    print           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    gets            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    break           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    def             reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    class           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    if              reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    while           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    until           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    case            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    for             reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    return          reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    IDENTIFIER      reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    nil             reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    self            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    GLOBAL          reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    OPEN_BRACKET    reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    Array           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    NUMBER          reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    true            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    false           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    $end            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    CLOSE_BRACKET   reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    when            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    then            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    else            reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    end             reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    elsif           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    do              reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)
    COMMA           reduce using rule 70 (term10 -> term10 MULTIPLY term11 .)


state 132

    (72) term10 -> term10 MODULO term11 .

    MULTIPLY        reduce using rule 72 (term10 -> term10 MODULO term11 .)
    DIVIDE          reduce using rule 72 (term10 -> term10 MODULO term11 .)
    MODULO          reduce using rule 72 (term10 -> term10 MODULO term11 .)
    PLUS            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    MINUS           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    LEFT_SHIFT      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    RIGHT_SHIFT     reduce using rule 72 (term10 -> term10 MODULO term11 .)
    BIT_AND         reduce using rule 72 (term10 -> term10 MODULO term11 .)
    BIT_XOR         reduce using rule 72 (term10 -> term10 MODULO term11 .)
    BIT_OR          reduce using rule 72 (term10 -> term10 MODULO term11 .)
    DOUBLE_EQUALS   reduce using rule 72 (term10 -> term10 MODULO term11 .)
    NOT_EQUALS      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    EQUAL_TILDE     reduce using rule 72 (term10 -> term10 MODULO term11 .)
    COMPARISON      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    LESS            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    LESS_EQUALS     reduce using rule 72 (term10 -> term10 MODULO term11 .)
    GREATER         reduce using rule 72 (term10 -> term10 MODULO term11 .)
    GREATER_EQUALS  reduce using rule 72 (term10 -> term10 MODULO term11 .)
    INCL_RANGE      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    EXCL_RANGE      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    LOGICAL_OR      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    LOGICAL_AND     reduce using rule 72 (term10 -> term10 MODULO term11 .)
    SEMI_COLON      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    NEWLINE         reduce using rule 72 (term10 -> term10 MODULO term11 .)
    puts            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    print           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    gets            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    break           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    def             reduce using rule 72 (term10 -> term10 MODULO term11 .)
    class           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    if              reduce using rule 72 (term10 -> term10 MODULO term11 .)
    while           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    until           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    case            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    for             reduce using rule 72 (term10 -> term10 MODULO term11 .)
    return          reduce using rule 72 (term10 -> term10 MODULO term11 .)
    IDENTIFIER      reduce using rule 72 (term10 -> term10 MODULO term11 .)
    nil             reduce using rule 72 (term10 -> term10 MODULO term11 .)
    self            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    GLOBAL          reduce using rule 72 (term10 -> term10 MODULO term11 .)
    OPEN_BRACKET    reduce using rule 72 (term10 -> term10 MODULO term11 .)
    Array           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    NUMBER          reduce using rule 72 (term10 -> term10 MODULO term11 .)
    true            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    false           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    $end            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    CLOSE_BRACKET   reduce using rule 72 (term10 -> term10 MODULO term11 .)
    when            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    then            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    else            reduce using rule 72 (term10 -> term10 MODULO term11 .)
    end             reduce using rule 72 (term10 -> term10 MODULO term11 .)
    elsif           reduce using rule 72 (term10 -> term10 MODULO term11 .)
    do              reduce using rule 72 (term10 -> term10 MODULO term11 .)
    COMMA           reduce using rule 72 (term10 -> term10 MODULO term11 .)


state 133

    (71) term10 -> term10 DIVIDE term11 .

    MULTIPLY        reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    DIVIDE          reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    MODULO          reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    PLUS            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    MINUS           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    LEFT_SHIFT      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    RIGHT_SHIFT     reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    BIT_AND         reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    BIT_XOR         reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    BIT_OR          reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    DOUBLE_EQUALS   reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    NOT_EQUALS      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    EQUAL_TILDE     reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    COMPARISON      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    LESS            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    LESS_EQUALS     reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    GREATER         reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    GREATER_EQUALS  reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    INCL_RANGE      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    EXCL_RANGE      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    LOGICAL_OR      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    LOGICAL_AND     reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    SEMI_COLON      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    NEWLINE         reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    puts            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    print           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    gets            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    break           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    def             reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    class           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    if              reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    while           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    until           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    case            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    for             reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    return          reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    IDENTIFIER      reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    nil             reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    self            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    GLOBAL          reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    OPEN_BRACKET    reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    Array           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    NUMBER          reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    true            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    false           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    $end            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    CLOSE_BRACKET   reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    when            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    then            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    else            reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    end             reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    elsif           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    do              reduce using rule 71 (term10 -> term10 DIVIDE term11 .)
    COMMA           reduce using rule 71 (term10 -> term10 DIVIDE term11 .)


state 134

    (62) term7 -> term7 BIT_AND term8 .
    (64) term8 -> term8 . LEFT_SHIFT term9
    (65) term8 -> term8 . RIGHT_SHIFT term9

    BIT_AND         reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    BIT_XOR         reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    BIT_OR          reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    DOUBLE_EQUALS   reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    NOT_EQUALS      reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    EQUAL_TILDE     reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    COMPARISON      reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    LESS            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    LESS_EQUALS     reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    GREATER         reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    GREATER_EQUALS  reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    INCL_RANGE      reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    EXCL_RANGE      reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    LOGICAL_OR      reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    LOGICAL_AND     reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    SEMI_COLON      reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    NEWLINE         reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    puts            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    print           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    gets            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    break           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    def             reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    class           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    if              reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    while           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    until           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    case            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    for             reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    return          reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    IDENTIFIER      reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    nil             reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    self            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    GLOBAL          reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    MINUS           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    PLUS            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    OPEN_BRACKET    reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    Array           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    NUMBER          reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    true            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    false           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    $end            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    when            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    then            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    else            reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    end             reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    elsif           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    do              reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    CLOSE_BRACKET   reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    COMMA           reduce using rule 62 (term7 -> term7 BIT_AND term8 .)
    LEFT_SHIFT      shift and go to state 106
    RIGHT_SHIFT     shift and go to state 105


state 135

    (59) term6 -> term6 BIT_XOR term7 .
    (62) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    BIT_OR          reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    DOUBLE_EQUALS   reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    NOT_EQUALS      reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    EQUAL_TILDE     reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    COMPARISON      reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    LESS            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    LESS_EQUALS     reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    GREATER         reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    GREATER_EQUALS  reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    INCL_RANGE      reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    EXCL_RANGE      reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    LOGICAL_OR      reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    LOGICAL_AND     reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    COMMA           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    CLOSE_BRACKET   reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    SEMI_COLON      reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    NEWLINE         reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    puts            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    print           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    gets            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    break           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    def             reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    class           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    if              reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    while           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    until           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    case            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    for             reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    return          reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    IDENTIFIER      reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    nil             reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    self            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    GLOBAL          reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    MINUS           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    PLUS            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    OPEN_BRACKET    reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    Array           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    NUMBER          reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    true            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    false           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    end             reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    $end            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    when            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    then            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    else            reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    elsif           reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    do              reduce using rule 59 (term6 -> term6 BIT_XOR term7 .)
    BIT_AND         shift and go to state 87


state 136

    (60) term6 -> term6 BIT_OR term7 .
    (62) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    BIT_OR          reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    DOUBLE_EQUALS   reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    NOT_EQUALS      reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    EQUAL_TILDE     reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    COMPARISON      reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    LESS            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    LESS_EQUALS     reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    GREATER         reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    GREATER_EQUALS  reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    INCL_RANGE      reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    EXCL_RANGE      reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    LOGICAL_OR      reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    LOGICAL_AND     reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    COMMA           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    CLOSE_BRACKET   reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    SEMI_COLON      reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    NEWLINE         reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    puts            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    print           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    gets            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    break           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    def             reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    class           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    if              reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    while           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    until           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    case            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    for             reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    return          reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    IDENTIFIER      reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    nil             reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    self            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    GLOBAL          reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    MINUS           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    PLUS            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    OPEN_BRACKET    reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    Array           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    NUMBER          reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    true            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    false           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    end             reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    $end            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    when            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    then            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    else            reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    elsif           reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    do              reduce using rule 60 (term6 -> term6 BIT_OR term7 .)
    BIT_AND         shift and go to state 87


state 137

    (52) term4 -> term5 COMPARISON term5 .
    (54) term5 -> term5 . LESS term6
    (55) term5 -> term5 . LESS_EQUALS term6
    (56) term5 -> term5 . GREATER term6
    (57) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    EXCL_RANGE      reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    LOGICAL_OR      reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    LOGICAL_AND     reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    SEMI_COLON      reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    NEWLINE         reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    puts            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    print           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    gets            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    break           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    def             reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    class           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    if              reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    while           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    until           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    case            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    for             reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    return          reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    IDENTIFIER      reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    nil             reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    self            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    GLOBAL          reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    MINUS           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    PLUS            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    OPEN_BRACKET    reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    Array           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    NUMBER          reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    true            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    false           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    elsif           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    else            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    end             reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    do              reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    $end            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    CLOSE_BRACKET   reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    when            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    then            reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    COMMA           reduce using rule 52 (term4 -> term5 COMPARISON term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 138

    (49) term4 -> term5 DOUBLE_EQUALS term5 .
    (54) term5 -> term5 . LESS term6
    (55) term5 -> term5 . LESS_EQUALS term6
    (56) term5 -> term5 . GREATER term6
    (57) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    EXCL_RANGE      reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    LOGICAL_OR      reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    LOGICAL_AND     reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    SEMI_COLON      reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    NEWLINE         reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    puts            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    print           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    gets            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    break           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    def             reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    class           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    if              reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    while           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    until           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    case            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    for             reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    return          reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    IDENTIFIER      reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    nil             reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    self            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    GLOBAL          reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    MINUS           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    PLUS            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    OPEN_BRACKET    reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    Array           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    NUMBER          reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    true            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    false           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    elsif           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    else            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    end             reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    do              reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    $end            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    CLOSE_BRACKET   reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    when            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    then            reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    COMMA           reduce using rule 49 (term4 -> term5 DOUBLE_EQUALS term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 139

    (56) term5 -> term5 GREATER term6 .
    (59) term6 -> term6 . BIT_XOR term7
    (60) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 56 (term5 -> term5 GREATER term6 .)
    NOT_EQUALS      reduce using rule 56 (term5 -> term5 GREATER term6 .)
    EQUAL_TILDE     reduce using rule 56 (term5 -> term5 GREATER term6 .)
    COMPARISON      reduce using rule 56 (term5 -> term5 GREATER term6 .)
    LESS            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    LESS_EQUALS     reduce using rule 56 (term5 -> term5 GREATER term6 .)
    GREATER         reduce using rule 56 (term5 -> term5 GREATER term6 .)
    GREATER_EQUALS  reduce using rule 56 (term5 -> term5 GREATER term6 .)
    INCL_RANGE      reduce using rule 56 (term5 -> term5 GREATER term6 .)
    EXCL_RANGE      reduce using rule 56 (term5 -> term5 GREATER term6 .)
    LOGICAL_OR      reduce using rule 56 (term5 -> term5 GREATER term6 .)
    LOGICAL_AND     reduce using rule 56 (term5 -> term5 GREATER term6 .)
    SEMI_COLON      reduce using rule 56 (term5 -> term5 GREATER term6 .)
    NEWLINE         reduce using rule 56 (term5 -> term5 GREATER term6 .)
    puts            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    print           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    gets            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    break           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    def             reduce using rule 56 (term5 -> term5 GREATER term6 .)
    class           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    if              reduce using rule 56 (term5 -> term5 GREATER term6 .)
    while           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    until           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    case            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    for             reduce using rule 56 (term5 -> term5 GREATER term6 .)
    return          reduce using rule 56 (term5 -> term5 GREATER term6 .)
    IDENTIFIER      reduce using rule 56 (term5 -> term5 GREATER term6 .)
    nil             reduce using rule 56 (term5 -> term5 GREATER term6 .)
    self            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    GLOBAL          reduce using rule 56 (term5 -> term5 GREATER term6 .)
    MINUS           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    PLUS            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    OPEN_BRACKET    reduce using rule 56 (term5 -> term5 GREATER term6 .)
    Array           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    NUMBER          reduce using rule 56 (term5 -> term5 GREATER term6 .)
    true            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    false           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    end             reduce using rule 56 (term5 -> term5 GREATER term6 .)
    else            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    elsif           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    when            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    COMMA           reduce using rule 56 (term5 -> term5 GREATER term6 .)
    CLOSE_BRACKET   reduce using rule 56 (term5 -> term5 GREATER term6 .)
    $end            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    do              reduce using rule 56 (term5 -> term5 GREATER term6 .)
    then            reduce using rule 56 (term5 -> term5 GREATER term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 140

    (54) term5 -> term5 LESS term6 .
    (59) term6 -> term6 . BIT_XOR term7
    (60) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 54 (term5 -> term5 LESS term6 .)
    NOT_EQUALS      reduce using rule 54 (term5 -> term5 LESS term6 .)
    EQUAL_TILDE     reduce using rule 54 (term5 -> term5 LESS term6 .)
    COMPARISON      reduce using rule 54 (term5 -> term5 LESS term6 .)
    LESS            reduce using rule 54 (term5 -> term5 LESS term6 .)
    LESS_EQUALS     reduce using rule 54 (term5 -> term5 LESS term6 .)
    GREATER         reduce using rule 54 (term5 -> term5 LESS term6 .)
    GREATER_EQUALS  reduce using rule 54 (term5 -> term5 LESS term6 .)
    INCL_RANGE      reduce using rule 54 (term5 -> term5 LESS term6 .)
    EXCL_RANGE      reduce using rule 54 (term5 -> term5 LESS term6 .)
    LOGICAL_OR      reduce using rule 54 (term5 -> term5 LESS term6 .)
    LOGICAL_AND     reduce using rule 54 (term5 -> term5 LESS term6 .)
    SEMI_COLON      reduce using rule 54 (term5 -> term5 LESS term6 .)
    NEWLINE         reduce using rule 54 (term5 -> term5 LESS term6 .)
    puts            reduce using rule 54 (term5 -> term5 LESS term6 .)
    print           reduce using rule 54 (term5 -> term5 LESS term6 .)
    gets            reduce using rule 54 (term5 -> term5 LESS term6 .)
    break           reduce using rule 54 (term5 -> term5 LESS term6 .)
    def             reduce using rule 54 (term5 -> term5 LESS term6 .)
    class           reduce using rule 54 (term5 -> term5 LESS term6 .)
    if              reduce using rule 54 (term5 -> term5 LESS term6 .)
    while           reduce using rule 54 (term5 -> term5 LESS term6 .)
    until           reduce using rule 54 (term5 -> term5 LESS term6 .)
    case            reduce using rule 54 (term5 -> term5 LESS term6 .)
    for             reduce using rule 54 (term5 -> term5 LESS term6 .)
    return          reduce using rule 54 (term5 -> term5 LESS term6 .)
    IDENTIFIER      reduce using rule 54 (term5 -> term5 LESS term6 .)
    nil             reduce using rule 54 (term5 -> term5 LESS term6 .)
    self            reduce using rule 54 (term5 -> term5 LESS term6 .)
    GLOBAL          reduce using rule 54 (term5 -> term5 LESS term6 .)
    MINUS           reduce using rule 54 (term5 -> term5 LESS term6 .)
    PLUS            reduce using rule 54 (term5 -> term5 LESS term6 .)
    OPEN_BRACKET    reduce using rule 54 (term5 -> term5 LESS term6 .)
    Array           reduce using rule 54 (term5 -> term5 LESS term6 .)
    NUMBER          reduce using rule 54 (term5 -> term5 LESS term6 .)
    true            reduce using rule 54 (term5 -> term5 LESS term6 .)
    false           reduce using rule 54 (term5 -> term5 LESS term6 .)
    end             reduce using rule 54 (term5 -> term5 LESS term6 .)
    else            reduce using rule 54 (term5 -> term5 LESS term6 .)
    elsif           reduce using rule 54 (term5 -> term5 LESS term6 .)
    when            reduce using rule 54 (term5 -> term5 LESS term6 .)
    COMMA           reduce using rule 54 (term5 -> term5 LESS term6 .)
    CLOSE_BRACKET   reduce using rule 54 (term5 -> term5 LESS term6 .)
    $end            reduce using rule 54 (term5 -> term5 LESS term6 .)
    do              reduce using rule 54 (term5 -> term5 LESS term6 .)
    then            reduce using rule 54 (term5 -> term5 LESS term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 141

    (50) term4 -> term5 NOT_EQUALS term5 .
    (54) term5 -> term5 . LESS term6
    (55) term5 -> term5 . LESS_EQUALS term6
    (56) term5 -> term5 . GREATER term6
    (57) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    EXCL_RANGE      reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    LOGICAL_OR      reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    LOGICAL_AND     reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    SEMI_COLON      reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    NEWLINE         reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    puts            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    print           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    gets            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    break           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    def             reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    class           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    if              reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    while           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    until           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    case            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    for             reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    return          reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    IDENTIFIER      reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    nil             reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    self            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    GLOBAL          reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    MINUS           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    PLUS            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    OPEN_BRACKET    reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    Array           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    NUMBER          reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    true            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    false           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    elsif           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    else            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    end             reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    do              reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    $end            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    CLOSE_BRACKET   reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    when            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    then            reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    COMMA           reduce using rule 50 (term4 -> term5 NOT_EQUALS term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 142

    (55) term5 -> term5 LESS_EQUALS term6 .
    (59) term6 -> term6 . BIT_XOR term7
    (60) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    NOT_EQUALS      reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    EQUAL_TILDE     reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    COMPARISON      reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    LESS            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    LESS_EQUALS     reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    GREATER         reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    GREATER_EQUALS  reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    INCL_RANGE      reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    EXCL_RANGE      reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    LOGICAL_OR      reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    LOGICAL_AND     reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    SEMI_COLON      reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    NEWLINE         reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    puts            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    print           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    gets            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    break           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    def             reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    class           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    if              reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    while           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    until           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    case            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    for             reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    return          reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    IDENTIFIER      reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    nil             reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    self            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    GLOBAL          reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    MINUS           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    PLUS            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    OPEN_BRACKET    reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    Array           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    NUMBER          reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    true            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    false           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    end             reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    else            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    elsif           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    when            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    COMMA           reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    CLOSE_BRACKET   reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    $end            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    do              reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    then            reduce using rule 55 (term5 -> term5 LESS_EQUALS term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 143

    (51) term4 -> term5 EQUAL_TILDE term5 .
    (54) term5 -> term5 . LESS term6
    (55) term5 -> term5 . LESS_EQUALS term6
    (56) term5 -> term5 . GREATER term6
    (57) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    EXCL_RANGE      reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    LOGICAL_OR      reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    LOGICAL_AND     reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    SEMI_COLON      reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    NEWLINE         reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    puts            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    print           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    gets            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    break           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    def             reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    class           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    if              reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    while           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    until           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    case            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    for             reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    return          reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    IDENTIFIER      reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    nil             reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    self            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    GLOBAL          reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    MINUS           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    PLUS            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    OPEN_BRACKET    reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    Array           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    NUMBER          reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    true            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    false           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    elsif           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    else            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    end             reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    do              reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    $end            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    CLOSE_BRACKET   reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    when            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    then            reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    COMMA           reduce using rule 51 (term4 -> term5 EQUAL_TILDE term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 144

    (57) term5 -> term5 GREATER_EQUALS term6 .
    (59) term6 -> term6 . BIT_XOR term7
    (60) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    NOT_EQUALS      reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    EQUAL_TILDE     reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    COMPARISON      reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    LESS            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    LESS_EQUALS     reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    GREATER         reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    GREATER_EQUALS  reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    INCL_RANGE      reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    EXCL_RANGE      reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    LOGICAL_OR      reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    LOGICAL_AND     reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    SEMI_COLON      reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    NEWLINE         reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    puts            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    print           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    gets            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    break           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    def             reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    class           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    if              reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    while           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    until           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    case            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    for             reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    return          reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    IDENTIFIER      reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    nil             reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    self            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    GLOBAL          reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    MINUS           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    PLUS            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    OPEN_BRACKET    reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    Array           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    NUMBER          reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    true            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    false           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    end             reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    else            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    elsif           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    when            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    COMMA           reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    CLOSE_BRACKET   reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    $end            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    do              reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    then            reduce using rule 57 (term5 -> term5 GREATER_EQUALS term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 145

    (10) stmt -> keyclass IDENTIFIER newline . multstmt keyend
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 188
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 146

    (44) term2 -> term3 EXCL_RANGE term3 .
    (46) term3 -> term3 . LOGICAL_OR term4
    (47) term3 -> term3 . LOGICAL_AND term4

    COMMA           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    CLOSE_BRACKET   reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    SEMI_COLON      reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    NEWLINE         reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    puts            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    print           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    gets            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    break           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    def             reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    class           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    if              reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    while           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    until           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    case            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    for             reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    return          reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    IDENTIFIER      reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    nil             reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    self            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    GLOBAL          reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    MINUS           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    PLUS            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    OPEN_BRACKET    reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    Array           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    NUMBER          reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    true            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    false           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    $end            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    elsif           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    else            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    end             reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    when            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    do              reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    then            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    LOGICAL_OR      shift and go to state 101
    LOGICAL_AND     shift and go to state 102


state 147

    (43) term2 -> term3 INCL_RANGE term3 .
    (46) term3 -> term3 . LOGICAL_OR term4
    (47) term3 -> term3 . LOGICAL_AND term4

    COMMA           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    CLOSE_BRACKET   reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    SEMI_COLON      reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    NEWLINE         reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    puts            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    print           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    gets            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    break           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    def             reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    class           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    if              reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    while           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    until           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    case            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    for             reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    return          reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    IDENTIFIER      reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    nil             reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    self            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    GLOBAL          reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    MINUS           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    PLUS            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    OPEN_BRACKET    reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    Array           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    NUMBER          reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    true            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    false           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    $end            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    elsif           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    else            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    end             reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    when            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    do              reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    then            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    LOGICAL_OR      shift and go to state 101
    LOGICAL_AND     shift and go to state 102


state 148

    (46) term3 -> term3 LOGICAL_OR term4 .

    INCL_RANGE      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    EXCL_RANGE      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    LOGICAL_OR      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    LOGICAL_AND     reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    do              reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    SEMI_COLON      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    NEWLINE         reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    puts            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    print           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    gets            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    break           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    def             reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    class           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    if              reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    while           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    until           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    case            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    for             reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    return          reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    IDENTIFIER      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    nil             reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    self            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    GLOBAL          reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    MINUS           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    PLUS            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    OPEN_BRACKET    reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    Array           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    NUMBER          reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    true            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    false           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    end             reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    COMMA           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    CLOSE_BRACKET   reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    $end            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    then            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    elsif           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    else            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    when            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)


state 149

    (47) term3 -> term3 LOGICAL_AND term4 .

    INCL_RANGE      reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    EXCL_RANGE      reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    LOGICAL_OR      reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    LOGICAL_AND     reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    do              reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    SEMI_COLON      reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    NEWLINE         reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    puts            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    print           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    gets            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    break           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    def             reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    class           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    if              reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    while           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    until           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    case            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    for             reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    return          reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    IDENTIFIER      reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    nil             reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    self            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    GLOBAL          reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    MINUS           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    PLUS            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    OPEN_BRACKET    reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    Array           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    NUMBER          reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    true            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    false           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    end             reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    COMMA           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    CLOSE_BRACKET   reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    $end            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    then            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    elsif           reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    else            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)
    when            reduce using rule 47 (term3 -> term3 LOGICAL_AND term4 .)


state 150

    (67) term9 -> term9 PLUS term10 .
    (70) term10 -> term10 . MULTIPLY term11
    (71) term10 -> term10 . DIVIDE term11
    (72) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    MINUS           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    LEFT_SHIFT      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    RIGHT_SHIFT     reduce using rule 67 (term9 -> term9 PLUS term10 .)
    BIT_AND         reduce using rule 67 (term9 -> term9 PLUS term10 .)
    BIT_XOR         reduce using rule 67 (term9 -> term9 PLUS term10 .)
    BIT_OR          reduce using rule 67 (term9 -> term9 PLUS term10 .)
    LESS            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    LESS_EQUALS     reduce using rule 67 (term9 -> term9 PLUS term10 .)
    GREATER         reduce using rule 67 (term9 -> term9 PLUS term10 .)
    GREATER_EQUALS  reduce using rule 67 (term9 -> term9 PLUS term10 .)
    INCL_RANGE      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    EXCL_RANGE      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    LOGICAL_OR      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    LOGICAL_AND     reduce using rule 67 (term9 -> term9 PLUS term10 .)
    SEMI_COLON      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    NEWLINE         reduce using rule 67 (term9 -> term9 PLUS term10 .)
    puts            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    print           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    gets            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    break           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    def             reduce using rule 67 (term9 -> term9 PLUS term10 .)
    class           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    if              reduce using rule 67 (term9 -> term9 PLUS term10 .)
    while           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    until           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    case            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    for             reduce using rule 67 (term9 -> term9 PLUS term10 .)
    return          reduce using rule 67 (term9 -> term9 PLUS term10 .)
    IDENTIFIER      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    nil             reduce using rule 67 (term9 -> term9 PLUS term10 .)
    self            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    GLOBAL          reduce using rule 67 (term9 -> term9 PLUS term10 .)
    OPEN_BRACKET    reduce using rule 67 (term9 -> term9 PLUS term10 .)
    Array           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    NUMBER          reduce using rule 67 (term9 -> term9 PLUS term10 .)
    true            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    false           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    $end            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    CLOSE_BRACKET   reduce using rule 67 (term9 -> term9 PLUS term10 .)
    when            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    then            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    else            reduce using rule 67 (term9 -> term9 PLUS term10 .)
    end             reduce using rule 67 (term9 -> term9 PLUS term10 .)
    elsif           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    do              reduce using rule 67 (term9 -> term9 PLUS term10 .)
    COMMA           reduce using rule 67 (term9 -> term9 PLUS term10 .)
    DOUBLE_EQUALS   reduce using rule 67 (term9 -> term9 PLUS term10 .)
    NOT_EQUALS      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    EQUAL_TILDE     reduce using rule 67 (term9 -> term9 PLUS term10 .)
    COMPARISON      reduce using rule 67 (term9 -> term9 PLUS term10 .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 86
    MODULO          shift and go to state 85


state 151

    (68) term9 -> term9 MINUS term10 .
    (70) term10 -> term10 . MULTIPLY term11
    (71) term10 -> term10 . DIVIDE term11
    (72) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    MINUS           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    LEFT_SHIFT      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    RIGHT_SHIFT     reduce using rule 68 (term9 -> term9 MINUS term10 .)
    BIT_AND         reduce using rule 68 (term9 -> term9 MINUS term10 .)
    BIT_XOR         reduce using rule 68 (term9 -> term9 MINUS term10 .)
    BIT_OR          reduce using rule 68 (term9 -> term9 MINUS term10 .)
    LESS            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    LESS_EQUALS     reduce using rule 68 (term9 -> term9 MINUS term10 .)
    GREATER         reduce using rule 68 (term9 -> term9 MINUS term10 .)
    GREATER_EQUALS  reduce using rule 68 (term9 -> term9 MINUS term10 .)
    INCL_RANGE      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    EXCL_RANGE      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    LOGICAL_OR      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    LOGICAL_AND     reduce using rule 68 (term9 -> term9 MINUS term10 .)
    SEMI_COLON      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    NEWLINE         reduce using rule 68 (term9 -> term9 MINUS term10 .)
    puts            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    print           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    gets            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    break           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    def             reduce using rule 68 (term9 -> term9 MINUS term10 .)
    class           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    if              reduce using rule 68 (term9 -> term9 MINUS term10 .)
    while           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    until           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    case            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    for             reduce using rule 68 (term9 -> term9 MINUS term10 .)
    return          reduce using rule 68 (term9 -> term9 MINUS term10 .)
    IDENTIFIER      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    nil             reduce using rule 68 (term9 -> term9 MINUS term10 .)
    self            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    GLOBAL          reduce using rule 68 (term9 -> term9 MINUS term10 .)
    OPEN_BRACKET    reduce using rule 68 (term9 -> term9 MINUS term10 .)
    Array           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    NUMBER          reduce using rule 68 (term9 -> term9 MINUS term10 .)
    true            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    false           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    $end            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    CLOSE_BRACKET   reduce using rule 68 (term9 -> term9 MINUS term10 .)
    when            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    then            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    else            reduce using rule 68 (term9 -> term9 MINUS term10 .)
    end             reduce using rule 68 (term9 -> term9 MINUS term10 .)
    elsif           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    do              reduce using rule 68 (term9 -> term9 MINUS term10 .)
    COMMA           reduce using rule 68 (term9 -> term9 MINUS term10 .)
    DOUBLE_EQUALS   reduce using rule 68 (term9 -> term9 MINUS term10 .)
    NOT_EQUALS      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    EQUAL_TILDE     reduce using rule 68 (term9 -> term9 MINUS term10 .)
    COMPARISON      reduce using rule 68 (term9 -> term9 MINUS term10 .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 86
    MODULO          shift and go to state 85


state 152

    (65) term8 -> term8 RIGHT_SHIFT term9 .
    (67) term9 -> term9 . PLUS term10
    (68) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    RIGHT_SHIFT     reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_AND         reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_XOR         reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_OR          reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    DOUBLE_EQUALS   reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    NOT_EQUALS      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    EQUAL_TILDE     reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    COMPARISON      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    LESS            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    LESS_EQUALS     reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    GREATER         reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    GREATER_EQUALS  reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    LOGICAL_OR      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    LOGICAL_AND     reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    SEMI_COLON      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    NEWLINE         reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    puts            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    print           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    gets            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    break           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    def             reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    class           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    if              reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    while           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    until           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    case            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    for             reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    return          reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    IDENTIFIER      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    nil             reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    self            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    GLOBAL          reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    OPEN_BRACKET    reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    Array           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    NUMBER          reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    true            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    false           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    $end            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    CLOSE_BRACKET   reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    when            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    then            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    else            reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    end             reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    elsif           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    do              reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    COMMA           reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    INCL_RANGE      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    EXCL_RANGE      reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .)
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104

  ! MINUS           [ reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .) ]
  ! PLUS            [ reduce using rule 65 (term8 -> term8 RIGHT_SHIFT term9 .) ]


state 153

    (64) term8 -> term8 LEFT_SHIFT term9 .
    (67) term9 -> term9 . PLUS term10
    (68) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    RIGHT_SHIFT     reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_AND         reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_XOR         reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_OR          reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    DOUBLE_EQUALS   reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    NOT_EQUALS      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    EQUAL_TILDE     reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    COMPARISON      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    LESS            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    LESS_EQUALS     reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    GREATER         reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    GREATER_EQUALS  reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    LOGICAL_OR      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    LOGICAL_AND     reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    SEMI_COLON      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    NEWLINE         reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    puts            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    print           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    gets            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    break           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    def             reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    class           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    if              reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    while           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    until           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    case            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    for             reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    return          reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    IDENTIFIER      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    nil             reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    self            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    GLOBAL          reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    OPEN_BRACKET    reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    Array           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    NUMBER          reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    true            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    false           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    $end            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    CLOSE_BRACKET   reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    when            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    then            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    else            reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    end             reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    elsif           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    do              reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    COMMA           reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    INCL_RANGE      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    EXCL_RANGE      reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .)
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104

  ! MINUS           [ reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .) ]
  ! PLUS            [ reduce using rule 64 (term8 -> term8 LEFT_SHIFT term9 .) ]


state 154

    (117) variable -> varname .

    OPEN_SQUARE     reduce using rule 117 (variable -> varname .)


state 155

    (105) mlhsitem -> classvar .

    in              reduce using rule 105 (mlhsitem -> classvar .)


state 156

    (24) expr -> for M_1 mlhs . in expr1 pdo M_1 multstmt end M_1

    in              shift and go to state 189


state 157

    (89) arrayal -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 190


state 158

    (103) mlhsitem -> IDENTIFIER .
    (85) classvar -> IDENTIFIER . DOT IDENTIFIER
    (137) varname -> IDENTIFIER .

    in              reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    EQUALS          reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    OR_EQUALS       reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    AND_EQUALS      reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    XOR_EQUALS      reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 103 (mlhsitem -> IDENTIFIER .)
    DOT             shift and go to state 113
    OPEN_SQUARE     reduce using rule 137 (varname -> IDENTIFIER .)
    MULTIPLY        reduce using rule 137 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 137 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 137 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 137 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 137 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 137 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 137 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 137 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 137 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 137 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 137 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 137 (varname -> IDENTIFIER .)
    LESS            reduce using rule 137 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 137 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 137 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 137 (varname -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 137 (varname -> IDENTIFIER .)
    then            reduce using rule 137 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 137 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 137 (varname -> IDENTIFIER .)
    puts            reduce using rule 137 (varname -> IDENTIFIER .)
    print           reduce using rule 137 (varname -> IDENTIFIER .)
    gets            reduce using rule 137 (varname -> IDENTIFIER .)
    break           reduce using rule 137 (varname -> IDENTIFIER .)
    def             reduce using rule 137 (varname -> IDENTIFIER .)
    class           reduce using rule 137 (varname -> IDENTIFIER .)
    if              reduce using rule 137 (varname -> IDENTIFIER .)
    while           reduce using rule 137 (varname -> IDENTIFIER .)
    until           reduce using rule 137 (varname -> IDENTIFIER .)
    case            reduce using rule 137 (varname -> IDENTIFIER .)
    for             reduce using rule 137 (varname -> IDENTIFIER .)
    return          reduce using rule 137 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 137 (varname -> IDENTIFIER .)
    nil             reduce using rule 137 (varname -> IDENTIFIER .)
    self            reduce using rule 137 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 137 (varname -> IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 137 (varname -> IDENTIFIER .)
    Array           reduce using rule 137 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 137 (varname -> IDENTIFIER .)
    true            reduce using rule 137 (varname -> IDENTIFIER .)
    false           reduce using rule 137 (varname -> IDENTIFIER .)
    when            reduce using rule 137 (varname -> IDENTIFIER .)
    end             reduce using rule 137 (varname -> IDENTIFIER .)


state 159

    (8) stmt -> print OPEN_BRACKET primary . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 191


state 160

    (7) stmt -> puts OPEN_BRACKET STRING . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 192


state 161

    (34) function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NEWLINE         reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    puts            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    print           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    gets            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    break           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    def             reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    class           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    if              reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    while           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    until           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    case            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    for             reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    return          reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    nil             reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    self            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    GLOBAL          reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    MINUS           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    PLUS            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    Array           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NUMBER          reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    true            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    false           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    $end            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    then            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    else            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    end             reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    elsif           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    do              reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    when            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)


state 162

    (108) callarglist -> term2 . callmultarglist
    (110) callmultarglist -> . COMMA term2 callmultarglist
    (111) callmultarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 194
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    callmultarglist                shift and go to state 193
    empty                          shift and go to state 195

state 163

    (109) callarglist -> empty .

    CLOSE_BRACKET   reduce using rule 109 (callarglist -> empty .)


state 164

    (107) callargs -> callarglist .

    CLOSE_BRACKET   reduce using rule 107 (callargs -> callarglist .)


state 165

    (33) function -> IDENTIFIER OPEN_BRACKET callargs . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 196


state 166

    (85) classvar -> IDENTIFIER DOT IDENTIFIER .

    MULTIPLY        reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    MODULO          reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    MINUS           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    BIT_AND         reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    BIT_XOR         reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    BIT_OR          reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    NOT_EQUALS      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    COMPARISON      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    LESS            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    LESS_EQUALS     reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    GREATER         reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    INCL_RANGE      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    EXCL_RANGE      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    LOGICAL_OR      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    LOGICAL_AND     reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    SEMI_COLON      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    NEWLINE         reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    puts            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    print           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    gets            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    break           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    def             reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    class           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    if              reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    while           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    until           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    case            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    for             reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    return          reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    nil             reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    self            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    GLOBAL          reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    Array           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    NUMBER          reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    true            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    false           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    $end            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    when            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    then            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    else            reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    end             reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    elsif           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    do              reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    COMMA           reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    CLOSE_SQUARE    reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    in              reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    EQUALS          reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    OR_EQUALS       reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    AND_EQUALS      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    XOR_EQUALS      reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 85 (classvar -> IDENTIFIER DOT IDENTIFIER .)


state 167

    (22) expr -> until M_1 expr1 . pdo M_1 multstmt end M_1
    (123) pdo -> . newline
    (124) pdo -> . do newline
    (125) pdo -> . newline do
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

  ! shift/reduce conflict for do resolved as shift
    do              shift and go to state 197
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

  ! do              [ reduce using rule 141 (empty -> .) ]

    newline                        shift and go to state 198
    pdo                            shift and go to state 199
    empty                          shift and go to state 41

state 168

    (23) expr -> case expr1 newline . multcase end M_1
    (93) multcase -> . when whenargs pthen M_1 multstmt M_1 multcase
    (94) multcase -> . when whenargs pthen M_1 multstmt M_1

    when            shift and go to state 200

    multcase                       shift and go to state 201

state 169

    (21) expr -> while M_1 expr1 . pdo M_1 multstmt end M_1
    (123) pdo -> . newline
    (124) pdo -> . do newline
    (125) pdo -> . newline do
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

  ! shift/reduce conflict for do resolved as shift
    do              shift and go to state 197
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

  ! do              [ reduce using rule 141 (empty -> .) ]

    newline                        shift and go to state 198
    pdo                            shift and go to state 202
    empty                          shift and go to state 41

state 170

    (121) pthen -> then .

    puts            reduce using rule 121 (pthen -> then .)
    print           reduce using rule 121 (pthen -> then .)
    gets            reduce using rule 121 (pthen -> then .)
    break           reduce using rule 121 (pthen -> then .)
    def             reduce using rule 121 (pthen -> then .)
    class           reduce using rule 121 (pthen -> then .)
    if              reduce using rule 121 (pthen -> then .)
    while           reduce using rule 121 (pthen -> then .)
    until           reduce using rule 121 (pthen -> then .)
    case            reduce using rule 121 (pthen -> then .)
    for             reduce using rule 121 (pthen -> then .)
    return          reduce using rule 121 (pthen -> then .)
    IDENTIFIER      reduce using rule 121 (pthen -> then .)
    nil             reduce using rule 121 (pthen -> then .)
    self            reduce using rule 121 (pthen -> then .)
    GLOBAL          reduce using rule 121 (pthen -> then .)
    MINUS           reduce using rule 121 (pthen -> then .)
    PLUS            reduce using rule 121 (pthen -> then .)
    OPEN_BRACKET    reduce using rule 121 (pthen -> then .)
    Array           reduce using rule 121 (pthen -> then .)
    NUMBER          reduce using rule 121 (pthen -> then .)
    true            reduce using rule 121 (pthen -> then .)
    false           reduce using rule 121 (pthen -> then .)
    elsif           reduce using rule 121 (pthen -> then .)
    else            reduce using rule 121 (pthen -> then .)
    end             reduce using rule 121 (pthen -> then .)
    when            reduce using rule 121 (pthen -> then .)


state 171

    (120) pthen -> newline .
    (122) pthen -> newline . then

    puts            reduce using rule 120 (pthen -> newline .)
    print           reduce using rule 120 (pthen -> newline .)
    gets            reduce using rule 120 (pthen -> newline .)
    break           reduce using rule 120 (pthen -> newline .)
    def             reduce using rule 120 (pthen -> newline .)
    class           reduce using rule 120 (pthen -> newline .)
    if              reduce using rule 120 (pthen -> newline .)
    while           reduce using rule 120 (pthen -> newline .)
    until           reduce using rule 120 (pthen -> newline .)
    case            reduce using rule 120 (pthen -> newline .)
    for             reduce using rule 120 (pthen -> newline .)
    return          reduce using rule 120 (pthen -> newline .)
    IDENTIFIER      reduce using rule 120 (pthen -> newline .)
    nil             reduce using rule 120 (pthen -> newline .)
    self            reduce using rule 120 (pthen -> newline .)
    GLOBAL          reduce using rule 120 (pthen -> newline .)
    MINUS           reduce using rule 120 (pthen -> newline .)
    PLUS            reduce using rule 120 (pthen -> newline .)
    OPEN_BRACKET    reduce using rule 120 (pthen -> newline .)
    Array           reduce using rule 120 (pthen -> newline .)
    NUMBER          reduce using rule 120 (pthen -> newline .)
    true            reduce using rule 120 (pthen -> newline .)
    false           reduce using rule 120 (pthen -> newline .)
    elsif           reduce using rule 120 (pthen -> newline .)
    else            reduce using rule 120 (pthen -> newline .)
    end             reduce using rule 120 (pthen -> newline .)
    when            reduce using rule 120 (pthen -> newline .)
    then            shift and go to state 203


state 172

    (18) expr -> if expr1 pthen . M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> if expr1 pthen . M_1 multstmt M_1 multelsif end M_1
    (20) expr -> if expr1 pthen . M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 204
    empty                          shift and go to state 108

state 173

    (9) stmt -> gets OPEN_BRACKET IDENTIFIER . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 205


state 174

    (2) multcompstmt -> newline stmt1 multcompstmt .

    $end            reduce using rule 2 (multcompstmt -> newline stmt1 multcompstmt .)


state 175

    (89) arrayal -> variable OPEN_SQUARE array_args . CLOSE_SQUARE
    (90) arraya -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 206


state 176

    (91) array_args -> primary . COMMA array_args
    (92) array_args -> primary .

    COMMA           shift and go to state 207
    CLOSE_SQUARE    reduce using rule 92 (array_args -> primary .)


state 177

    (87) array_size -> term2 . COMMA array_size
    (88) array_size -> term2 .

    COMMA           shift and go to state 208
    CLOSE_BRACKET   reduce using rule 88 (array_size -> term2 .)


state 178

    (86) arrayd -> Array OPEN_BRACKET array_size . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 209


state 179

    (6) stmt -> keydef argdecl newline . multstmt keyend
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 210
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 180

    (112) argdecl -> OPEN_BRACKET arglist . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 211


state 181

    (113) arglist -> IDENTIFIER . multarglist
    (115) multarglist -> . COMMA IDENTIFIER multarglist
    (116) multarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 212
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    multarglist                    shift and go to state 213
    empty                          shift and go to state 214

state 182

    (114) arglist -> empty .

    CLOSE_BRACKET   reduce using rule 114 (arglist -> empty .)


state 183

    (36) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET . CLOSE_BRACKET
    (37) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET . callargs CLOSE_BRACKET
    (107) callargs -> . callarglist
    (108) callarglist -> . term2 callmultarglist
    (109) callarglist -> . empty
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (141) empty -> .
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

  ! shift/reduce conflict for CLOSE_BRACKET resolved as shift
    CLOSE_BRACKET   shift and go to state 215
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

  ! CLOSE_BRACKET   [ reduce using rule 141 (empty -> .) ]

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 162
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    empty                          shift and go to state 163
    callarglist                    shift and go to state 164
    variable                       shift and go to state 77
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    callargs                       shift and go to state 216
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 184

    (38) term0 -> mlhs EQUALS IDENTIFIER DOT . new OPEN_BRACKET CLOSE_BRACKET
    (85) classvar -> IDENTIFIER DOT . IDENTIFIER

    new             shift and go to state 217
    IDENTIFIER      shift and go to state 166


state 185

    (90) arraya -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 218


state 186

    (16) multstmt -> stmt . newline multstmt
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)

    newline                        shift and go to state 219
    empty                          shift and go to state 41

state 187

    (17) multstmt -> empty .

    end             reduce using rule 17 (multstmt -> empty .)
    when            reduce using rule 17 (multstmt -> empty .)
    elsif           reduce using rule 17 (multstmt -> empty .)
    else            reduce using rule 17 (multstmt -> empty .)


state 188

    (10) stmt -> keyclass IDENTIFIER newline multstmt . keyend
    (15) keyend -> . end

    end             shift and go to state 221

    keyend                         shift and go to state 220

state 189

    (24) expr -> for M_1 mlhs in . expr1 pdo M_1 multstmt end M_1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    literal                        shift and go to state 37
    expr1                          shift and go to state 222
    call                           shift and go to state 38
    function                       shift and go to state 42
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    varname                        shift and go to state 30
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 190

    (89) arrayal -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (91) array_args -> . primary COMMA array_args
    (92) array_args -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 176
    array_args                     shift and go to state 223
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50

state 191

    (8) stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    NEWLINE         reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    puts            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    print           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    gets            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    break           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    def             reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    class           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    if              reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    while           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    until           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    case            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    for             reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    return          reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    nil             reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    self            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    GLOBAL          reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    MINUS           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    PLUS            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    Array           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    NUMBER          reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    true            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    false           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    end             reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    $end            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    when            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    else            reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    elsif           reduce using rule 8 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)


state 192

    (7) stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    NEWLINE         reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    puts            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    print           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    gets            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    break           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    def             reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    class           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    if              reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    while           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    until           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    case            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    for             reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    return          reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    nil             reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    self            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    GLOBAL          reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    MINUS           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    PLUS            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    Array           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    NUMBER          reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    true            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    false           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    end             reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    $end            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    when            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    else            reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    elsif           reduce using rule 7 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)


state 193

    (108) callarglist -> term2 callmultarglist .

    CLOSE_BRACKET   reduce using rule 108 (callarglist -> term2 callmultarglist .)


state 194

    (110) callmultarglist -> COMMA . term2 callmultarglist
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 224
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 195

    (111) callmultarglist -> empty .

    CLOSE_BRACKET   reduce using rule 111 (callmultarglist -> empty .)


state 196

    (33) function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NEWLINE         reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    puts            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    print           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    gets            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    break           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    def             reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    class           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    if              reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    while           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    until           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    case            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    for             reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    return          reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    nil             reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    self            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    GLOBAL          reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    MINUS           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    PLUS            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    Array           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NUMBER          reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    true            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    false           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    $end            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    then            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    else            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    end             reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    elsif           reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    do              reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    when            reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 33 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)


state 197

    (124) pdo -> do . newline
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    newline                        shift and go to state 225
    empty                          shift and go to state 41

state 198

    (123) pdo -> newline .
    (125) pdo -> newline . do

    puts            reduce using rule 123 (pdo -> newline .)
    print           reduce using rule 123 (pdo -> newline .)
    gets            reduce using rule 123 (pdo -> newline .)
    break           reduce using rule 123 (pdo -> newline .)
    def             reduce using rule 123 (pdo -> newline .)
    class           reduce using rule 123 (pdo -> newline .)
    if              reduce using rule 123 (pdo -> newline .)
    while           reduce using rule 123 (pdo -> newline .)
    until           reduce using rule 123 (pdo -> newline .)
    case            reduce using rule 123 (pdo -> newline .)
    for             reduce using rule 123 (pdo -> newline .)
    return          reduce using rule 123 (pdo -> newline .)
    IDENTIFIER      reduce using rule 123 (pdo -> newline .)
    nil             reduce using rule 123 (pdo -> newline .)
    self            reduce using rule 123 (pdo -> newline .)
    GLOBAL          reduce using rule 123 (pdo -> newline .)
    MINUS           reduce using rule 123 (pdo -> newline .)
    PLUS            reduce using rule 123 (pdo -> newline .)
    OPEN_BRACKET    reduce using rule 123 (pdo -> newline .)
    Array           reduce using rule 123 (pdo -> newline .)
    NUMBER          reduce using rule 123 (pdo -> newline .)
    true            reduce using rule 123 (pdo -> newline .)
    false           reduce using rule 123 (pdo -> newline .)
    end             reduce using rule 123 (pdo -> newline .)
    do              shift and go to state 226


state 199

    (22) expr -> until M_1 expr1 pdo . M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 227
    empty                          shift and go to state 108

state 200

    (93) multcase -> when . whenargs pthen M_1 multstmt M_1 multcase
    (94) multcase -> when . whenargs pthen M_1 multstmt M_1
    (101) whenargs -> . arg
    (35) arg -> . term0
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    IDENTIFIER      shift and go to state 158
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 228
    arrayal                        shift and go to state 35
    literal                        shift and go to state 37
    whenargs                       shift and go to state 229
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    varname                        shift and go to state 30
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 201

    (23) expr -> case expr1 newline multcase . end M_1

    end             shift and go to state 230


state 202

    (21) expr -> while M_1 expr1 pdo . M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 231
    empty                          shift and go to state 108

state 203

    (122) pthen -> newline then .

    puts            reduce using rule 122 (pthen -> newline then .)
    print           reduce using rule 122 (pthen -> newline then .)
    gets            reduce using rule 122 (pthen -> newline then .)
    break           reduce using rule 122 (pthen -> newline then .)
    def             reduce using rule 122 (pthen -> newline then .)
    class           reduce using rule 122 (pthen -> newline then .)
    if              reduce using rule 122 (pthen -> newline then .)
    while           reduce using rule 122 (pthen -> newline then .)
    until           reduce using rule 122 (pthen -> newline then .)
    case            reduce using rule 122 (pthen -> newline then .)
    for             reduce using rule 122 (pthen -> newline then .)
    return          reduce using rule 122 (pthen -> newline then .)
    IDENTIFIER      reduce using rule 122 (pthen -> newline then .)
    nil             reduce using rule 122 (pthen -> newline then .)
    self            reduce using rule 122 (pthen -> newline then .)
    GLOBAL          reduce using rule 122 (pthen -> newline then .)
    MINUS           reduce using rule 122 (pthen -> newline then .)
    PLUS            reduce using rule 122 (pthen -> newline then .)
    OPEN_BRACKET    reduce using rule 122 (pthen -> newline then .)
    Array           reduce using rule 122 (pthen -> newline then .)
    NUMBER          reduce using rule 122 (pthen -> newline then .)
    true            reduce using rule 122 (pthen -> newline then .)
    false           reduce using rule 122 (pthen -> newline then .)
    elsif           reduce using rule 122 (pthen -> newline then .)
    else            reduce using rule 122 (pthen -> newline then .)
    end             reduce using rule 122 (pthen -> newline then .)
    when            reduce using rule 122 (pthen -> newline then .)


state 204

    (18) expr -> if expr1 pthen M_1 . multstmt else newline M_1 multstmt end M_1
    (19) expr -> if expr1 pthen M_1 . multstmt M_1 multelsif end M_1
    (20) expr -> if expr1 pthen M_1 . multstmt end M_1
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 232
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 205

    (9) stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    NEWLINE         reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    puts            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    print           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    gets            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    break           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    def             reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    class           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    if              reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    while           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    until           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    case            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    for             reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    return          reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    nil             reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    self            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    GLOBAL          reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    MINUS           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    PLUS            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    Array           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    NUMBER          reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    true            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    false           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    end             reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    $end            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    when            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    else            reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    elsif           reduce using rule 9 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)


state 206

    (89) arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .
    (90) arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    EQUALS          reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO_EQUALS   reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE_EQUALS   reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS_EQUALS    reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS_EQUALS     reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OR_EQUALS       reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    AND_EQUALS      reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    XOR_EQUALS      reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT_EQUALS reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT_EQUALS reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MULTIPLY_EQUALS reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MULTIPLY        reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_AND         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_XOR         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_OR          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DOUBLE_EQUALS   reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NOT_EQUALS      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EQUAL_TILDE     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMPARISON      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS_EQUALS     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER_EQUALS  reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    INCL_RANGE      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EXCL_RANGE      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_AND     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    do              reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    SEMI_COLON      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NEWLINE         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    puts            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    print           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    gets            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    break           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    def             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    class           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    if              reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    while           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    until           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    case            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    for             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    return          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    IDENTIFIER      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    nil             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    self            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GLOBAL          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OPEN_BRACKET    reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    Array           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NUMBER          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    true            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    false           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    end             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    then            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    when            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    elsif           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    else            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    $end            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_BRACKET   reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 207

    (91) array_args -> primary COMMA . array_args
    (91) array_args -> . primary COMMA array_args
    (92) array_args -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    primary                        shift and go to state 176
    array_args                     shift and go to state 233
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50

state 208

    (87) array_size -> term2 COMMA . array_size
    (87) array_size -> . term2 COMMA array_size
    (88) array_size -> . term2
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    IDENTIFIER      shift and go to state 76
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51
    GLOBAL          shift and go to state 32
    nil             shift and go to state 58
    self            shift and go to state 54

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 177
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    literal                        shift and go to state 37
    variable                       shift and go to state 77
    array_size                     shift and go to state 234
    varname                        shift and go to state 78
    classvar                       shift and go to state 79
    arraya                         shift and go to state 48
    term10                         shift and go to state 13
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    arrayd                         shift and go to state 50

state 209

    (86) arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .

    MULTIPLY        reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    DIVIDE          reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    MODULO          reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    PLUS            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    MINUS           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LEFT_SHIFT      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    RIGHT_SHIFT     reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_AND         reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_XOR         reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_OR          reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    DOUBLE_EQUALS   reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NOT_EQUALS      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    EQUAL_TILDE     reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    COMPARISON      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LESS            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LESS_EQUALS     reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GREATER         reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GREATER_EQUALS  reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    INCL_RANGE      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    EXCL_RANGE      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LOGICAL_OR      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LOGICAL_AND     reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    SEMI_COLON      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NEWLINE         reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    puts            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    print           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    gets            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    break           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    def             reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    class           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    if              reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    while           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    until           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    case            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    for             reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    return          reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    nil             reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    self            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GLOBAL          reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    Array           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NUMBER          reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    true            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    false           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    $end            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    when            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    then            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    else            reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    end             reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    elsif           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    do              reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    COMMA           reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    CLOSE_SQUARE    reduce using rule 86 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)


state 210

    (6) stmt -> keydef argdecl newline multstmt . keyend
    (15) keyend -> . end

    end             shift and go to state 221

    keyend                         shift and go to state 235

state 211

    (112) argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    NEWLINE         reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    puts            reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    print           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    gets            reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    break           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    def             reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    class           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    if              reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    while           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    until           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    case            reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    for             reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    return          reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    nil             reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    self            reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    GLOBAL          reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    MINUS           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    PLUS            reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    Array           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    NUMBER          reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    true            reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    false           reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    end             reduce using rule 112 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)


state 212

    (115) multarglist -> COMMA . IDENTIFIER multarglist

    IDENTIFIER      shift and go to state 236


state 213

    (113) arglist -> IDENTIFIER multarglist .

    CLOSE_BRACKET   reduce using rule 113 (arglist -> IDENTIFIER multarglist .)


state 214

    (116) multarglist -> empty .

    CLOSE_BRACKET   reduce using rule 116 (multarglist -> empty .)


state 215

    (36) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NEWLINE         reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    puts            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    print           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    gets            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    break           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    def             reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    class           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    if              reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    while           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    until           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    case            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    for             reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    return          reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    nil             reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    self            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    GLOBAL          reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    MINUS           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    PLUS            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    Array           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NUMBER          reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    true            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    false           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    $end            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    do              reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    end             reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    then            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    else            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    elsif           reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    when            reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 36 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)


state 216

    (37) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 237


state 217

    (38) term0 -> mlhs EQUALS IDENTIFIER DOT new . OPEN_BRACKET CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 238


state 218

    (90) arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    MULTIPLY        reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_AND         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_XOR         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_OR          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS_EQUALS     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER_EQUALS  reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    INCL_RANGE      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EXCL_RANGE      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_AND     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    SEMI_COLON      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NEWLINE         reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    puts            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    print           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    gets            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    break           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    def             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    class           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    if              reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    while           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    until           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    case            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    for             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    return          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    IDENTIFIER      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    nil             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    self            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GLOBAL          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OPEN_BRACKET    reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    Array           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NUMBER          reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    true            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    false           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    $end            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_BRACKET   reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    when            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    then            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    else            reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    end             reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    elsif           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    do              reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMMA           reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DOUBLE_EQUALS   reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NOT_EQUALS      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EQUAL_TILDE     reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMPARISON      reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_SQUARE    reduce using rule 90 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 219

    (16) multstmt -> stmt newline . multstmt
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 239
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 220

    (10) stmt -> keyclass IDENTIFIER newline multstmt keyend .

    SEMI_COLON      reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    NEWLINE         reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    puts            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    print           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    gets            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    break           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    def             reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    class           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    if              reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    while           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    until           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    case            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    for             reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    return          reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    IDENTIFIER      reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    nil             reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    self            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    GLOBAL          reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    MINUS           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    PLUS            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    OPEN_BRACKET    reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    Array           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    NUMBER          reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    true            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    false           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    end             reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    $end            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    when            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    else            reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)
    elsif           reduce using rule 10 (stmt -> keyclass IDENTIFIER newline multstmt keyend .)


state 221

    (15) keyend -> end .

    SEMI_COLON      reduce using rule 15 (keyend -> end .)
    NEWLINE         reduce using rule 15 (keyend -> end .)
    puts            reduce using rule 15 (keyend -> end .)
    print           reduce using rule 15 (keyend -> end .)
    gets            reduce using rule 15 (keyend -> end .)
    break           reduce using rule 15 (keyend -> end .)
    def             reduce using rule 15 (keyend -> end .)
    class           reduce using rule 15 (keyend -> end .)
    if              reduce using rule 15 (keyend -> end .)
    while           reduce using rule 15 (keyend -> end .)
    until           reduce using rule 15 (keyend -> end .)
    case            reduce using rule 15 (keyend -> end .)
    for             reduce using rule 15 (keyend -> end .)
    return          reduce using rule 15 (keyend -> end .)
    IDENTIFIER      reduce using rule 15 (keyend -> end .)
    nil             reduce using rule 15 (keyend -> end .)
    self            reduce using rule 15 (keyend -> end .)
    GLOBAL          reduce using rule 15 (keyend -> end .)
    MINUS           reduce using rule 15 (keyend -> end .)
    PLUS            reduce using rule 15 (keyend -> end .)
    OPEN_BRACKET    reduce using rule 15 (keyend -> end .)
    Array           reduce using rule 15 (keyend -> end .)
    NUMBER          reduce using rule 15 (keyend -> end .)
    true            reduce using rule 15 (keyend -> end .)
    false           reduce using rule 15 (keyend -> end .)
    $end            reduce using rule 15 (keyend -> end .)
    end             reduce using rule 15 (keyend -> end .)
    else            reduce using rule 15 (keyend -> end .)
    elsif           reduce using rule 15 (keyend -> end .)
    when            reduce using rule 15 (keyend -> end .)


state 222

    (24) expr -> for M_1 mlhs in expr1 . pdo M_1 multstmt end M_1
    (123) pdo -> . newline
    (124) pdo -> . do newline
    (125) pdo -> . newline do
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

  ! shift/reduce conflict for do resolved as shift
    do              shift and go to state 197
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

  ! do              [ reduce using rule 141 (empty -> .) ]

    newline                        shift and go to state 198
    pdo                            shift and go to state 240
    empty                          shift and go to state 41

state 223

    (89) arrayal -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 241


state 224

    (110) callmultarglist -> COMMA term2 . callmultarglist
    (110) callmultarglist -> . COMMA term2 callmultarglist
    (111) callmultarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 194
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    callmultarglist                shift and go to state 242
    empty                          shift and go to state 195

state 225

    (124) pdo -> do newline .

    puts            reduce using rule 124 (pdo -> do newline .)
    print           reduce using rule 124 (pdo -> do newline .)
    gets            reduce using rule 124 (pdo -> do newline .)
    break           reduce using rule 124 (pdo -> do newline .)
    def             reduce using rule 124 (pdo -> do newline .)
    class           reduce using rule 124 (pdo -> do newline .)
    if              reduce using rule 124 (pdo -> do newline .)
    while           reduce using rule 124 (pdo -> do newline .)
    until           reduce using rule 124 (pdo -> do newline .)
    case            reduce using rule 124 (pdo -> do newline .)
    for             reduce using rule 124 (pdo -> do newline .)
    return          reduce using rule 124 (pdo -> do newline .)
    IDENTIFIER      reduce using rule 124 (pdo -> do newline .)
    nil             reduce using rule 124 (pdo -> do newline .)
    self            reduce using rule 124 (pdo -> do newline .)
    GLOBAL          reduce using rule 124 (pdo -> do newline .)
    MINUS           reduce using rule 124 (pdo -> do newline .)
    PLUS            reduce using rule 124 (pdo -> do newline .)
    OPEN_BRACKET    reduce using rule 124 (pdo -> do newline .)
    Array           reduce using rule 124 (pdo -> do newline .)
    NUMBER          reduce using rule 124 (pdo -> do newline .)
    true            reduce using rule 124 (pdo -> do newline .)
    false           reduce using rule 124 (pdo -> do newline .)
    end             reduce using rule 124 (pdo -> do newline .)


state 226

    (125) pdo -> newline do .

    puts            reduce using rule 125 (pdo -> newline do .)
    print           reduce using rule 125 (pdo -> newline do .)
    gets            reduce using rule 125 (pdo -> newline do .)
    break           reduce using rule 125 (pdo -> newline do .)
    def             reduce using rule 125 (pdo -> newline do .)
    class           reduce using rule 125 (pdo -> newline do .)
    if              reduce using rule 125 (pdo -> newline do .)
    while           reduce using rule 125 (pdo -> newline do .)
    until           reduce using rule 125 (pdo -> newline do .)
    case            reduce using rule 125 (pdo -> newline do .)
    for             reduce using rule 125 (pdo -> newline do .)
    return          reduce using rule 125 (pdo -> newline do .)
    IDENTIFIER      reduce using rule 125 (pdo -> newline do .)
    nil             reduce using rule 125 (pdo -> newline do .)
    self            reduce using rule 125 (pdo -> newline do .)
    GLOBAL          reduce using rule 125 (pdo -> newline do .)
    MINUS           reduce using rule 125 (pdo -> newline do .)
    PLUS            reduce using rule 125 (pdo -> newline do .)
    OPEN_BRACKET    reduce using rule 125 (pdo -> newline do .)
    Array           reduce using rule 125 (pdo -> newline do .)
    NUMBER          reduce using rule 125 (pdo -> newline do .)
    true            reduce using rule 125 (pdo -> newline do .)
    false           reduce using rule 125 (pdo -> newline do .)
    end             reduce using rule 125 (pdo -> newline do .)


state 227

    (22) expr -> until M_1 expr1 pdo M_1 . multstmt end M_1
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 243
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 228

    (101) whenargs -> arg .

    then            reduce using rule 101 (whenargs -> arg .)
    SEMI_COLON      reduce using rule 101 (whenargs -> arg .)
    NEWLINE         reduce using rule 101 (whenargs -> arg .)
    puts            reduce using rule 101 (whenargs -> arg .)
    print           reduce using rule 101 (whenargs -> arg .)
    gets            reduce using rule 101 (whenargs -> arg .)
    break           reduce using rule 101 (whenargs -> arg .)
    def             reduce using rule 101 (whenargs -> arg .)
    class           reduce using rule 101 (whenargs -> arg .)
    if              reduce using rule 101 (whenargs -> arg .)
    while           reduce using rule 101 (whenargs -> arg .)
    until           reduce using rule 101 (whenargs -> arg .)
    case            reduce using rule 101 (whenargs -> arg .)
    for             reduce using rule 101 (whenargs -> arg .)
    return          reduce using rule 101 (whenargs -> arg .)
    IDENTIFIER      reduce using rule 101 (whenargs -> arg .)
    nil             reduce using rule 101 (whenargs -> arg .)
    self            reduce using rule 101 (whenargs -> arg .)
    GLOBAL          reduce using rule 101 (whenargs -> arg .)
    MINUS           reduce using rule 101 (whenargs -> arg .)
    PLUS            reduce using rule 101 (whenargs -> arg .)
    OPEN_BRACKET    reduce using rule 101 (whenargs -> arg .)
    Array           reduce using rule 101 (whenargs -> arg .)
    NUMBER          reduce using rule 101 (whenargs -> arg .)
    true            reduce using rule 101 (whenargs -> arg .)
    false           reduce using rule 101 (whenargs -> arg .)
    when            reduce using rule 101 (whenargs -> arg .)
    end             reduce using rule 101 (whenargs -> arg .)


state 229

    (93) multcase -> when whenargs . pthen M_1 multstmt M_1 multcase
    (94) multcase -> when whenargs . pthen M_1 multstmt M_1
    (120) pthen -> . newline
    (121) pthen -> . then
    (122) pthen -> . newline then
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

  ! shift/reduce conflict for then resolved as shift
    then            shift and go to state 170
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

  ! then            [ reduce using rule 141 (empty -> .) ]

    newline                        shift and go to state 171
    pthen                          shift and go to state 244
    empty                          shift and go to state 41

state 230

    (23) expr -> case expr1 newline multcase end . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    empty                          shift and go to state 108
    M_1                            shift and go to state 245

state 231

    (21) expr -> while M_1 expr1 pdo M_1 . multstmt end M_1
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 246
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 232

    (18) expr -> if expr1 pthen M_1 multstmt . else newline M_1 multstmt end M_1
    (19) expr -> if expr1 pthen M_1 multstmt . M_1 multelsif end M_1
    (20) expr -> if expr1 pthen M_1 multstmt . end M_1
    (26) M_1 -> . empty
    (141) empty -> .

  ! shift/reduce conflict for else resolved as shift
  ! shift/reduce conflict for end resolved as shift
    else            shift and go to state 248
    end             shift and go to state 247
    elsif           reduce using rule 141 (empty -> .)

  ! else            [ reduce using rule 141 (empty -> .) ]
  ! end             [ reduce using rule 141 (empty -> .) ]

    M_1                            shift and go to state 249
    empty                          shift and go to state 108

state 233

    (91) array_args -> primary COMMA array_args .

    CLOSE_SQUARE    reduce using rule 91 (array_args -> primary COMMA array_args .)


state 234

    (87) array_size -> term2 COMMA array_size .

    CLOSE_BRACKET   reduce using rule 87 (array_size -> term2 COMMA array_size .)


state 235

    (6) stmt -> keydef argdecl newline multstmt keyend .

    SEMI_COLON      reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    NEWLINE         reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    puts            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    print           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    gets            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    break           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    def             reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    class           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    if              reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    while           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    until           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    case            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    for             reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    return          reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    IDENTIFIER      reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    nil             reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    self            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    GLOBAL          reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    MINUS           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    PLUS            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    OPEN_BRACKET    reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    Array           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    NUMBER          reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    true            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    false           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    end             reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    $end            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    when            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    else            reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)
    elsif           reduce using rule 6 (stmt -> keydef argdecl newline multstmt keyend .)


state 236

    (115) multarglist -> COMMA IDENTIFIER . multarglist
    (115) multarglist -> . COMMA IDENTIFIER multarglist
    (116) multarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 212
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    multarglist                    shift and go to state 250
    empty                          shift and go to state 214

state 237

    (37) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NEWLINE         reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    puts            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    print           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    gets            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    break           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    def             reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    class           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    if              reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    while           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    until           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    case            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    for             reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    return          reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    nil             reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    self            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    GLOBAL          reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    MINUS           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    PLUS            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    Array           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NUMBER          reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    true            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    false           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    $end            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    do              reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    end             reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    then            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    else            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    elsif           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    when            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)


state 238

    (38) term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 251


state 239

    (16) multstmt -> stmt newline multstmt .

    end             reduce using rule 16 (multstmt -> stmt newline multstmt .)
    when            reduce using rule 16 (multstmt -> stmt newline multstmt .)
    elsif           reduce using rule 16 (multstmt -> stmt newline multstmt .)
    else            reduce using rule 16 (multstmt -> stmt newline multstmt .)


state 240

    (24) expr -> for M_1 mlhs in expr1 pdo . M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 252
    empty                          shift and go to state 108

state 241

    (89) arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    in              reduce using rule 89 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 242

    (110) callmultarglist -> COMMA term2 callmultarglist .

    CLOSE_BRACKET   reduce using rule 110 (callmultarglist -> COMMA term2 callmultarglist .)


state 243

    (22) expr -> until M_1 expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 253


state 244

    (93) multcase -> when whenargs pthen . M_1 multstmt M_1 multcase
    (94) multcase -> when whenargs pthen . M_1 multstmt M_1
    (26) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 254
    empty                          shift and go to state 108

state 245

    (23) expr -> case expr1 newline multcase end M_1 .

    SEMI_COLON      reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    NEWLINE         reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    puts            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    print           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    gets            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    break           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    def             reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    class           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    if              reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    while           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    until           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    case            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    for             reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    return          reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    IDENTIFIER      reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    nil             reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    self            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    GLOBAL          reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    MINUS           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    PLUS            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    OPEN_BRACKET    reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    Array           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    NUMBER          reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    true            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    false           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    else            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    end             reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    elsif           reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    then            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    $end            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)
    when            reduce using rule 23 (expr -> case expr1 newline multcase end M_1 .)


state 246

    (21) expr -> while M_1 expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 255


state 247

    (20) expr -> if expr1 pthen M_1 multstmt end . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 256
    empty                          shift and go to state 108

state 248

    (18) expr -> if expr1 pthen M_1 multstmt else . newline M_1 multstmt end M_1
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    newline                        shift and go to state 257
    empty                          shift and go to state 41

state 249

    (19) expr -> if expr1 pthen M_1 multstmt M_1 . multelsif end M_1
    (95) multelsif -> . elsif expr pthen M_1 multstmt M_1 multelsif M_1
    (96) multelsif -> . else newline multstmt
    (97) multelsif -> . empty
    (141) empty -> .

    elsif           shift and go to state 259
    else            shift and go to state 258
    end             reduce using rule 141 (empty -> .)

    empty                          shift and go to state 260
    multelsif                      shift and go to state 261

state 250

    (115) multarglist -> COMMA IDENTIFIER multarglist .

    CLOSE_BRACKET   reduce using rule 115 (multarglist -> COMMA IDENTIFIER multarglist .)


state 251

    (38) term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    NEWLINE         reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    puts            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    print           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    gets            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    break           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    def             reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    class           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    if              reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    while           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    until           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    case            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    for             reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    return          reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    nil             reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    self            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    GLOBAL          reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    MINUS           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    PLUS            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    Array           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    NUMBER          reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    true            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    false           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    $end            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    do              reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    end             reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    then            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    else            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    elsif           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    when            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET .)


state 252

    (24) expr -> for M_1 mlhs in expr1 pdo M_1 . multstmt end M_1
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 262
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 253

    (22) expr -> until M_1 expr1 pdo M_1 multstmt end . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 263
    empty                          shift and go to state 108

state 254

    (93) multcase -> when whenargs pthen M_1 . multstmt M_1 multcase
    (94) multcase -> when whenargs pthen M_1 . multstmt M_1
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    when            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    arrayal                        shift and go to state 35
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 264
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    varname                        shift and go to state 30
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 255

    (21) expr -> while M_1 expr1 pdo M_1 multstmt end . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 265
    empty                          shift and go to state 108

state 256

    (20) expr -> if expr1 pthen M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    puts            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    print           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    gets            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    break           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    def             reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    class           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    if              reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    while           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    until           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    case            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    for             reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    return          reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    nil             reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    self            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    MINUS           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    PLUS            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    Array           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    true            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    false           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    else            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    end             reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    elsif           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    then            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    $end            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    when            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt end M_1 .)


state 257

    (18) expr -> if expr1 pthen M_1 multstmt else newline . M_1 multstmt end M_1
    (26) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 266
    empty                          shift and go to state 108

state 258

    (96) multelsif -> else . newline multstmt
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    newline                        shift and go to state 267
    empty                          shift and go to state 41

state 259

    (95) multelsif -> elsif . expr pthen M_1 multstmt M_1 multelsif M_1
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    term4                          shift and go to state 34
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    function                       shift and go to state 42
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 268
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    term13                         shift and go to state 10
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 260

    (97) multelsif -> empty .

    end             reduce using rule 97 (multelsif -> empty .)


state 261

    (19) expr -> if expr1 pthen M_1 multstmt M_1 multelsif . end M_1

    end             shift and go to state 269


state 262

    (24) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 270


state 263

    (22) expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    gets            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    class           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    else            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    end             reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    elsif           reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    when            reduce using rule 22 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)


state 264

    (93) multcase -> when whenargs pthen M_1 multstmt . M_1 multcase
    (94) multcase -> when whenargs pthen M_1 multstmt . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    when            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 271
    empty                          shift and go to state 108

state 265

    (21) expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    gets            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    class           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    else            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    end             reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    elsif           reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    when            reduce using rule 21 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)


state 266

    (18) expr -> if expr1 pthen M_1 multstmt else newline M_1 . multstmt end M_1
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 272
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 267

    (96) multelsif -> else newline . multstmt
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 273
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 268

    (95) multelsif -> elsif expr . pthen M_1 multstmt M_1 multelsif M_1
    (120) pthen -> . newline
    (121) pthen -> . then
    (122) pthen -> . newline then
    (138) newline -> . SEMI_COLON
    (139) newline -> . NEWLINE
    (140) newline -> . empty
    (141) empty -> .

  ! shift/reduce conflict for then resolved as shift
    then            shift and go to state 170
    SEMI_COLON      shift and go to state 24
    NEWLINE         shift and go to state 3
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

  ! then            [ reduce using rule 141 (empty -> .) ]

    newline                        shift and go to state 171
    pthen                          shift and go to state 274
    empty                          shift and go to state 41

state 269

    (19) expr -> if expr1 pthen M_1 multstmt M_1 multelsif end . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 275
    empty                          shift and go to state 108

state 270

    (24) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 276
    empty                          shift and go to state 108

state 271

    (93) multcase -> when whenargs pthen M_1 multstmt M_1 . multcase
    (94) multcase -> when whenargs pthen M_1 multstmt M_1 .
    (93) multcase -> . when whenargs pthen M_1 multstmt M_1 multcase
    (94) multcase -> . when whenargs pthen M_1 multstmt M_1

    end             reduce using rule 94 (multcase -> when whenargs pthen M_1 multstmt M_1 .)
    when            shift and go to state 200

    multcase                       shift and go to state 277

state 272

    (18) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt . end M_1

    end             shift and go to state 278


state 273

    (96) multelsif -> else newline multstmt .

    end             reduce using rule 96 (multelsif -> else newline multstmt .)


state 274

    (95) multelsif -> elsif expr pthen . M_1 multstmt M_1 multelsif M_1
    (26) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 279
    empty                          shift and go to state 108

state 275

    (19) expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .

    SEMI_COLON      reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    NEWLINE         reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    puts            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    print           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    gets            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    break           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    def             reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    class           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    if              reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    while           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    until           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    case            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    for             reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    return          reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    IDENTIFIER      reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    nil             reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    self            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    GLOBAL          reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    MINUS           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    PLUS            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    OPEN_BRACKET    reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    Array           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    NUMBER          reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    true            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    false           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    else            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    end             reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    elsif           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    then            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    $end            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    when            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)


state 276

    (24) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    gets            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    class           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    else            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    end             reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    elsif           reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    when            reduce using rule 24 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)


state 277

    (93) multcase -> when whenargs pthen M_1 multstmt M_1 multcase .

    end             reduce using rule 93 (multcase -> when whenargs pthen M_1 multstmt M_1 multcase .)


state 278

    (18) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 280
    empty                          shift and go to state 108

state 279

    (95) multelsif -> elsif expr pthen M_1 . multstmt M_1 multelsif M_1
    (16) multstmt -> . stmt newline multstmt
    (17) multstmt -> . empty
    (6) stmt -> . keydef argdecl newline multstmt keyend
    (7) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (8) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (9) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (10) stmt -> . keyclass IDENTIFIER newline multstmt keyend
    (11) stmt -> . break
    (12) stmt -> . expr
    (141) empty -> .
    (14) keydef -> . def IDENTIFIER
    (13) keyclass -> . class
    (18) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (19) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt end M_1
    (21) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (22) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . case expr1 newline multcase end M_1
    (24) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (25) expr -> . expr1
    (27) expr1 -> . return term2
    (28) expr1 -> . return
    (29) expr1 -> . expr2
    (30) expr2 -> . arg
    (31) expr2 -> . call
    (35) arg -> . term0
    (32) call -> . function
    (36) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER DOT new OPEN_BRACKET CLOSE_BRACKET
    (39) term0 -> . term1
    (33) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (34) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (102) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (103) mlhsitem -> . IDENTIFIER
    (104) mlhsitem -> . arrayal
    (105) mlhsitem -> . classvar
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (89) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (85) classvar -> . IDENTIFIER DOT IDENTIFIER
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term3 LOGICAL_AND term4
    (48) term3 -> . term4
    (117) variable -> . varname
    (118) variable -> . nil
    (119) variable -> . self
    (49) term4 -> . term5 DOUBLE_EQUALS term5
    (50) term4 -> . term5 NOT_EQUALS term5
    (51) term4 -> . term5 EQUAL_TILDE term5
    (52) term4 -> . term5 COMPARISON term5
    (53) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . IDENTIFIER
    (54) term5 -> . term5 LESS term6
    (55) term5 -> . term5 LESS_EQUALS term6
    (56) term5 -> . term5 GREATER term6
    (57) term5 -> . term5 GREATER_EQUALS term6
    (58) term5 -> . term6
    (59) term6 -> . term6 BIT_XOR term7
    (60) term6 -> . term6 BIT_OR term7
    (61) term6 -> . term7
    (62) term7 -> . term7 BIT_AND term8
    (63) term7 -> . term8
    (64) term8 -> . term8 LEFT_SHIFT term9
    (65) term8 -> . term8 RIGHT_SHIFT term9
    (66) term8 -> . term9
    (67) term9 -> . term9 PLUS term10
    (68) term9 -> . term9 MINUS term10
    (69) term9 -> . term10
    (70) term10 -> . term10 MULTIPLY term11
    (71) term10 -> . term10 DIVIDE term11
    (72) term10 -> . term10 MODULO term11
    (73) term10 -> . term11
    (74) term11 -> . MINUS term11
    (75) term11 -> . term12
    (76) term12 -> . PLUS term12
    (77) term12 -> . term13
    (78) term13 -> . primary
    (79) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (80) primary -> . arrayd
    (81) primary -> . arraya
    (82) primary -> . classvar
    (83) primary -> . literal
    (84) primary -> . varname
    (86) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (90) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (98) literal -> . NUMBER
    (99) literal -> . true
    (100) literal -> . false

    puts            shift and go to state 36
    print           shift and go to state 27
    gets            shift and go to state 57
    break           shift and go to state 8
    elsif           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 49
    class           shift and go to state 61
    if              shift and go to state 53
    while           shift and go to state 47
    until           shift and go to state 40
    case            shift and go to state 45
    for             shift and go to state 26
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 39
    nil             shift and go to state 58
    self            shift and go to state 54
    GLOBAL          shift and go to state 32
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 62
    NUMBER          shift and go to state 52
    true            shift and go to state 44
    false           shift and go to state 51

    term7                          shift and go to state 14
    term6                          shift and go to state 15
    term5                          shift and go to state 16
    keyclass                       shift and go to state 17
    term3                          shift and go to state 18
    term2                          shift and go to state 19
    term1                          shift and go to state 20
    term0                          shift and go to state 21
    mlhs                           shift and go to state 1
    primary                        shift and go to state 33
    term9                          shift and go to state 22
    term8                          shift and go to state 23
    term4                          shift and go to state 34
    arg                            shift and go to state 25
    arrayal                        shift and go to state 35
    expr2                          shift and go to state 55
    term13                         shift and go to state 10
    literal                        shift and go to state 37
    expr1                          shift and go to state 56
    call                           shift and go to state 38
    varname                        shift and go to state 30
    empty                          shift and go to state 187
    function                       shift and go to state 42
    stmt                           shift and go to state 186
    multstmt                       shift and go to state 281
    mlhsitem                       shift and go to state 43
    variable                       shift and go to state 60
    expr                           shift and go to state 46
    classvar                       shift and go to state 9
    arraya                         shift and go to state 48
    arrayd                         shift and go to state 50
    keydef                         shift and go to state 63
    term12                         shift and go to state 11
    term11                         shift and go to state 12
    term10                         shift and go to state 13

state 280

    (18) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    puts            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    print           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    gets            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    break           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    def             reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    class           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    if              reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    while           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    until           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    case            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    for             reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    return          reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    nil             reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    self            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    MINUS           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    PLUS            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    Array           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    true            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    false           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    else            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    end             reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    elsif           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    then            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    $end            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    when            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)


state 281

    (95) multelsif -> elsif expr pthen M_1 multstmt . M_1 multelsif M_1
    (26) M_1 -> . empty
    (141) empty -> .

    elsif           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 282
    empty                          shift and go to state 108

state 282

    (95) multelsif -> elsif expr pthen M_1 multstmt M_1 . multelsif M_1
    (95) multelsif -> . elsif expr pthen M_1 multstmt M_1 multelsif M_1
    (96) multelsif -> . else newline multstmt
    (97) multelsif -> . empty
    (141) empty -> .

    elsif           shift and go to state 259
    else            shift and go to state 258
    end             reduce using rule 141 (empty -> .)

    multelsif                      shift and go to state 283
    empty                          shift and go to state 260

state 283

    (95) multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif . M_1
    (26) M_1 -> . empty
    (141) empty -> .

    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 284
    empty                          shift and go to state 108

state 284

    (95) multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1 .

    end             reduce using rule 95 (multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for puts in state 0 resolved as shift
WARNING: shift/reduce conflict for print in state 0 resolved as shift
WARNING: shift/reduce conflict for gets in state 0 resolved as shift
WARNING: shift/reduce conflict for break in state 0 resolved as shift
WARNING: shift/reduce conflict for def in state 0 resolved as shift
WARNING: shift/reduce conflict for class in state 0 resolved as shift
WARNING: shift/reduce conflict for if in state 0 resolved as shift
WARNING: shift/reduce conflict for while in state 0 resolved as shift
WARNING: shift/reduce conflict for until in state 0 resolved as shift
WARNING: shift/reduce conflict for case in state 0 resolved as shift
WARNING: shift/reduce conflict for for in state 0 resolved as shift
WARNING: shift/reduce conflict for return in state 0 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 0 resolved as shift
WARNING: shift/reduce conflict for nil in state 0 resolved as shift
WARNING: shift/reduce conflict for self in state 0 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 0 resolved as shift
WARNING: shift/reduce conflict for Array in state 0 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 0 resolved as shift
WARNING: shift/reduce conflict for true in state 0 resolved as shift
WARNING: shift/reduce conflict for false in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 6 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 6 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 6 resolved as shift
WARNING: shift/reduce conflict for Array in state 6 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 6 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 6 resolved as shift
WARNING: shift/reduce conflict for true in state 6 resolved as shift
WARNING: shift/reduce conflict for false in state 6 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 6 resolved as shift
WARNING: shift/reduce conflict for nil in state 6 resolved as shift
WARNING: shift/reduce conflict for self in state 6 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 22 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 22 resolved as shift
WARNING: shift/reduce conflict for puts in state 31 resolved as shift
WARNING: shift/reduce conflict for print in state 31 resolved as shift
WARNING: shift/reduce conflict for gets in state 31 resolved as shift
WARNING: shift/reduce conflict for break in state 31 resolved as shift
WARNING: shift/reduce conflict for def in state 31 resolved as shift
WARNING: shift/reduce conflict for class in state 31 resolved as shift
WARNING: shift/reduce conflict for if in state 31 resolved as shift
WARNING: shift/reduce conflict for while in state 31 resolved as shift
WARNING: shift/reduce conflict for until in state 31 resolved as shift
WARNING: shift/reduce conflict for case in state 31 resolved as shift
WARNING: shift/reduce conflict for for in state 31 resolved as shift
WARNING: shift/reduce conflict for return in state 31 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 31 resolved as shift
WARNING: shift/reduce conflict for nil in state 31 resolved as shift
WARNING: shift/reduce conflict for self in state 31 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 31 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 31 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 31 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 31 resolved as shift
WARNING: shift/reduce conflict for Array in state 31 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 31 resolved as shift
WARNING: shift/reduce conflict for true in state 31 resolved as shift
WARNING: shift/reduce conflict for false in state 31 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 39 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACKET in state 112 resolved as shift
WARNING: shift/reduce conflict for then in state 118 resolved as shift
WARNING: shift/reduce conflict for puts in state 120 resolved as shift
WARNING: shift/reduce conflict for print in state 120 resolved as shift
WARNING: shift/reduce conflict for gets in state 120 resolved as shift
WARNING: shift/reduce conflict for break in state 120 resolved as shift
WARNING: shift/reduce conflict for def in state 120 resolved as shift
WARNING: shift/reduce conflict for class in state 120 resolved as shift
WARNING: shift/reduce conflict for if in state 120 resolved as shift
WARNING: shift/reduce conflict for while in state 120 resolved as shift
WARNING: shift/reduce conflict for until in state 120 resolved as shift
WARNING: shift/reduce conflict for case in state 120 resolved as shift
WARNING: shift/reduce conflict for for in state 120 resolved as shift
WARNING: shift/reduce conflict for return in state 120 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 120 resolved as shift
WARNING: shift/reduce conflict for nil in state 120 resolved as shift
WARNING: shift/reduce conflict for self in state 120 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 120 resolved as shift
WARNING: shift/reduce conflict for Array in state 120 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 120 resolved as shift
WARNING: shift/reduce conflict for true in state 120 resolved as shift
WARNING: shift/reduce conflict for false in state 120 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 126 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for do in state 167 resolved as shift
WARNING: shift/reduce conflict for do in state 169 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACKET in state 183 resolved as shift
WARNING: shift/reduce conflict for do in state 222 resolved as shift
WARNING: shift/reduce conflict for then in state 229 resolved as shift
WARNING: shift/reduce conflict for else in state 232 resolved as shift
WARNING: shift/reduce conflict for end in state 232 resolved as shift
WARNING: shift/reduce conflict for then in state 268 resolved as shift
