Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    BEGIN
    ensure
    END
    not
    super
    alias
    defined
    or
    yield
    and
    redo
    begin
    rescue
    undef
    module
    retry
    unless
    next
    CONSTANT_RESOLUTION
    ELEMENT_REFERENCE
    ELEMENT_SET
    POWER
    SYMBOL_NOT
    COMPLEMENT
    TRIPLE_EQUALS
    BANG_TILDE
    LOGICAL_AND
    POWER_EQUALS
    WORD_NOT
    WORD_AND
    WORD_OR
    MAP
    PLUS_AT
    MINUS_AT
    STRING2
    HEREDOC
    REGEXP
    DOUBLE_QUOTE
    DOLLAR
    COLON
    QUESTION_MARK
    OPEN_FLOWER
    CLOSE_FLOWER
    DOT

Grammar

Rule 0     S' -> compstmt
Rule 1     compstmt -> multcompstmt
Rule 2     multcompstmt -> newline stmt1 multcompstmt
Rule 3     multcompstmt -> stmt1 multcompstmt
Rule 4     multcompstmt -> newline
Rule 5     multcompstmt -> empty
Rule 6     stmt1 -> stmt
Rule 7     stmt -> keydef argdecl newline multstmt keyend
Rule 8     stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET
Rule 9     stmt -> print OPEN_BRACKET primary CLOSE_BRACKET
Rule 10    stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
Rule 11    stmt -> class IDENTIFIER newline multstmt end
Rule 12    stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end
Rule 13    stmt -> break
Rule 14    stmt -> expr
Rule 15    keydef -> def IDENTIFIER
Rule 16    keyend -> end
Rule 17    multstmt -> stmt newline multstmt
Rule 18    multstmt -> empty
Rule 19    expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
Rule 20    expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1
Rule 21    expr -> if expr1 pthen M_1 multstmt end M_1
Rule 22    expr -> while M_1 expr1 pdo M_1 multstmt end M_1
Rule 23    expr -> until M_1 expr1 pdo M_1 multstmt end M_1
Rule 24    expr -> case expr1 newline multcase end M_1
Rule 25    expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
Rule 26    expr -> expr1
Rule 27    M_1 -> empty
Rule 28    expr1 -> return term2
Rule 29    expr1 -> return
Rule 30    expr1 -> expr2
Rule 31    expr2 -> arg
Rule 32    expr2 -> call
Rule 33    call -> function
Rule 34    function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
Rule 35    function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
Rule 36    arg -> term0
Rule 37    term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
Rule 38    term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
Rule 39    term0 -> term1
Rule 40    term1 -> mlhs EQUALS mrhs
Rule 41    term1 -> mlhs opasgn mrhs
Rule 42    term1 -> term2
Rule 43    term2 -> term3 INCL_RANGE term3
Rule 44    term2 -> term3 EXCL_RANGE term3
Rule 45    term2 -> term3
Rule 46    term3 -> term3 LOGICAL_OR term4
Rule 47    term3 -> term4
Rule 48    term4 -> term5 DOUBLE_EQUALS term5
Rule 49    term4 -> term5 NOT_EQUALS term5
Rule 50    term4 -> term5 EQUAL_TILDE term5
Rule 51    term4 -> term5 COMPARISON term5
Rule 52    term4 -> term5
Rule 53    term5 -> term5 LESS term6
Rule 54    term5 -> term5 LESS_EQUALS term6
Rule 55    term5 -> term5 GREATER term6
Rule 56    term5 -> term5 GREATER_EQUALS term6
Rule 57    term5 -> term6
Rule 58    term6 -> term6 BIT_XOR term7
Rule 59    term6 -> term6 BIT_OR term7
Rule 60    term6 -> term7
Rule 61    term7 -> term7 BIT_AND term8
Rule 62    term7 -> term8
Rule 63    term8 -> term8 LEFT_SHIFT term9
Rule 64    term8 -> term8 RIGHT_SHIFT term9
Rule 65    term8 -> term9
Rule 66    term9 -> term9 PLUS term10
Rule 67    term9 -> term9 MINUS term10
Rule 68    term9 -> term10
Rule 69    term10 -> term10 MULTIPLY term11
Rule 70    term10 -> term10 DIVIDE term11
Rule 71    term10 -> term10 MODULO term11
Rule 72    term10 -> term11
Rule 73    term11 -> MINUS term11
Rule 74    term11 -> term12
Rule 75    term12 -> PLUS term12
Rule 76    term12 -> term13
Rule 77    term13 -> primary
Rule 78    primary -> OPEN_BRACKET expr2 CLOSE_BRACKET
Rule 79    primary -> arrayd
Rule 80    primary -> arraya
Rule 81    primary -> literal
Rule 82    primary -> varname
Rule 83    arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET
Rule 84    array_size -> primary COMMA array_size
Rule 85    array_size -> primary
Rule 86    arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE
Rule 87    arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE
Rule 88    array_args -> primary COMMA array_args
Rule 89    array_args -> primary
Rule 90    multcase -> when whenargs pthen M_1 multstmt M_1 multcase
Rule 91    multcase -> when whenargs pthen M_1 multstmt M_1
Rule 92    multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1
Rule 93    multelsif -> else newline multstmt
Rule 94    multelsif -> empty
Rule 95    literal -> NUMBER
Rule 96    literal -> FLOAT
Rule 97    literal -> STRING
Rule 98    literal -> true
Rule 99    literal -> false
Rule 100   whenargs -> arg
Rule 101   mlhs -> mlhsitem
Rule 102   mlhsitem -> IDENTIFIER
Rule 103   mlhsitem -> arrayal
Rule 104   mrhs -> term2
Rule 105   callargs -> callarglist
Rule 106   callarglist -> primary callmultarglist
Rule 107   callarglist -> empty
Rule 108   callmultarglist -> COMMA primary callmultarglist
Rule 109   callmultarglist -> empty
Rule 110   argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET
Rule 111   arglist -> IDENTIFIER multarglist
Rule 112   arglist -> empty
Rule 113   multarglist -> COMMA IDENTIFIER multarglist
Rule 114   multarglist -> empty
Rule 115   variable -> varname
Rule 116   variable -> nil
Rule 117   variable -> self
Rule 118   pthen -> newline
Rule 119   pthen -> then
Rule 120   pthen -> newline then
Rule 121   pdo -> newline
Rule 122   pdo -> do newline
Rule 123   pdo -> newline do
Rule 124   opasgn -> MODULO_EQUALS
Rule 125   opasgn -> DIVIDE_EQUALS
Rule 126   opasgn -> MINUS_EQUALS
Rule 127   opasgn -> PLUS_EQUALS
Rule 128   opasgn -> OR_EQUALS
Rule 129   opasgn -> AND_EQUALS
Rule 130   opasgn -> XOR_EQUALS
Rule 131   opasgn -> RIGHT_SHIFT_EQUALS
Rule 132   opasgn -> LEFT_SHIFT_EQUALS
Rule 133   opasgn -> MULTIPLY_EQUALS
Rule 134   opasgn -> LOGICAL_AND_EQUALS
Rule 135   opasgn -> LOGICAL_OR_EQUALS
Rule 136   varname -> GLOBAL
Rule 137   varname -> AT_THE_RATE IDENTIFIER
Rule 138   varname -> IDENTIFIER
Rule 139   newline -> SEMI_COLON
Rule 140   newline -> NEWLINE
Rule 141   empty -> <empty>

Terminals, with rules where they appear

AND_EQUALS           : 129
AT_THE_RATE          : 137
Array                : 83
BANG_TILDE           : 
BEGIN                : 
BIT_AND              : 61
BIT_OR               : 59
BIT_XOR              : 58
CLOSE_BRACKET        : 8 9 10 34 35 37 38 78 83 110
CLOSE_FLOWER         : 
CLOSE_SQUARE         : 86 87
COLON                : 
COMMA                : 84 88 108 113
COMPARISON           : 51
COMPLEMENT           : 
CONSTANT_RESOLUTION  : 
DIVIDE               : 70
DIVIDE_EQUALS        : 125
DOLLAR               : 
DOT                  : 
DOUBLE_EQUALS        : 48
DOUBLE_QUOTE         : 
ELEMENT_REFERENCE    : 
ELEMENT_SET          : 
END                  : 
EQUALS               : 37 38 40
EQUAL_TILDE          : 50
EXCL_RANGE           : 44
FLOAT                : 96
GLOBAL               : 136
GREATER              : 55
GREATER_EQUALS       : 56
HEREDOC              : 
IDENTIFIER           : 10 11 12 12 15 34 35 37 38 102 111 113 137 138
INCL_RANGE           : 43
LEFT_SHIFT           : 63
LEFT_SHIFT_EQUALS    : 132
LESS                 : 12 53
LESS_EQUALS          : 54
LOGICAL_AND          : 
LOGICAL_AND_EQUALS   : 134
LOGICAL_OR           : 46
LOGICAL_OR_EQUALS    : 135
MAP                  : 
MINUS                : 67 73
MINUS_AT             : 
MINUS_EQUALS         : 126
MODULO               : 71
MODULO_EQUALS        : 124
MULTIPLY             : 69
MULTIPLY_EQUALS      : 133
NEWLINE              : 140
NOT_EQUALS           : 49
NUMBER               : 95
OPEN_BRACKET         : 8 9 10 34 35 37 38 78 83 110
OPEN_FLOWER          : 
OPEN_SQUARE          : 86 87
OR_EQUALS            : 128
PLUS                 : 66 75
PLUS_AT              : 
PLUS_EQUALS          : 127
POWER                : 
POWER_EQUALS         : 
QUESTION_MARK        : 
REGEXP               : 
RIGHT_SHIFT          : 64
RIGHT_SHIFT_EQUALS   : 131
SEMI_COLON           : 139
STRING               : 8 97
STRING2              : 
SYMBOL_NOT           : 
TRIPLE_EQUALS        : 
WORD_AND             : 
WORD_NOT             : 
WORD_OR              : 
XOR_EQUALS           : 130
alias                : 
and                  : 
begin                : 
break                : 13
case                 : 24
class                : 11 12
def                  : 15
defined              : 
do                   : 122 123
else                 : 19 93
elsif                : 92
end                  : 11 12 16 19 20 21 22 23 24 25
ensure               : 
error                : 
false                : 99
for                  : 25
gets                 : 10
if                   : 19 20 21
in                   : 25
module               : 
next                 : 
nil                  : 116
not                  : 
or                   : 
print                : 9
puts                 : 8
redo                 : 
rescue               : 
retry                : 
return               : 28 29
self                 : 117
super                : 
then                 : 119 120
true                 : 98
undef                : 
unless               : 
until                : 23
when                 : 90 91
while                : 22
yield                : 

Nonterminals, with rules where they appear

M_1                  : 19 19 19 20 20 20 21 21 22 22 22 23 23 23 24 25 25 25 90 90 91 91 92 92 92
arg                  : 31 100
argdecl              : 7
arglist              : 110
array_args           : 86 87 88
array_size           : 83 84
arraya               : 80
arrayal              : 103
arrayd               : 79
call                 : 32
callarglist          : 105
callargs             : 34 38
callmultarglist      : 106 108
compstmt             : 0
empty                : 5 18 27 94 107 109 112 114
expr                 : 14 92
expr1                : 19 20 21 22 23 24 25 26
expr2                : 30 78
function             : 33
keydef               : 7
keyend               : 7
literal              : 81
mlhs                 : 25 37 38 40 41
mlhsitem             : 101
mrhs                 : 40 41
multarglist          : 111 113
multcase             : 24 90
multcompstmt         : 1 2 3
multelsif            : 20 92
multstmt             : 7 11 12 17 19 19 20 21 22 23 25 90 91 92 93
newline              : 2 4 7 11 12 17 19 24 93 118 120 121 122 123
opasgn               : 41
pdo                  : 22 23 25
primary              : 9 77 84 85 88 89 106 108
pthen                : 19 20 21 90 91 92
stmt                 : 6 17
stmt1                : 2 3
term0                : 36
term1                : 39
term10               : 66 67 68 69 70 71
term11               : 69 70 71 72 73
term12               : 74 75
term13               : 76
term2                : 28 42 104
term3                : 43 43 44 44 45 46
term4                : 46 47
term5                : 48 48 49 49 50 50 51 51 52 53 54 55 56
term6                : 53 54 55 56 57 58 59
term7                : 58 59 60 61
term8                : 61 62 63 64
term9                : 63 64 65 66 67
variable             : 86 87
varname              : 82 115
whenargs             : 90 91

Parsing method: LALR

state 0

    (0) S' -> . compstmt
    (1) compstmt -> . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (5) multcompstmt -> . empty
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE
    (6) stmt1 -> . stmt
    (141) empty -> .
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7
    $end            reduce using rule 141 (empty -> .)
    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    compstmt                       shift and go to state 1
    multcompstmt                   shift and go to state 2
    newline                        shift and go to state 3
    stmt1                          shift and go to state 4
    empty                          shift and go to state 5
    stmt                           shift and go to state 8
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 1

    (0) S' -> compstmt .



state 2

    (1) compstmt -> multcompstmt .

    $end            reduce using rule 1 (compstmt -> multcompstmt .)


state 3

    (2) multcompstmt -> newline . stmt1 multcompstmt
    (4) multcompstmt -> newline .
    (6) stmt1 -> . stmt
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    $end            reduce using rule 4 (multcompstmt -> newline .)
    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    stmt1                          shift and go to state 65
    stmt                           shift and go to state 8
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 4

    (3) multcompstmt -> stmt1 . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (5) multcompstmt -> . empty
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE
    (6) stmt1 -> . stmt
    (141) empty -> .
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7
    $end            reduce using rule 141 (empty -> .)
    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    stmt1                          shift and go to state 4
    multcompstmt                   shift and go to state 66
    newline                        shift and go to state 3
    empty                          shift and go to state 5
    stmt                           shift and go to state 8
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 5

    (5) multcompstmt -> empty .

    $end            reduce using rule 5 (multcompstmt -> empty .)


state 6

    (139) newline -> SEMI_COLON .

    puts            reduce using rule 139 (newline -> SEMI_COLON .)
    print           reduce using rule 139 (newline -> SEMI_COLON .)
    gets            reduce using rule 139 (newline -> SEMI_COLON .)
    class           reduce using rule 139 (newline -> SEMI_COLON .)
    break           reduce using rule 139 (newline -> SEMI_COLON .)
    def             reduce using rule 139 (newline -> SEMI_COLON .)
    if              reduce using rule 139 (newline -> SEMI_COLON .)
    while           reduce using rule 139 (newline -> SEMI_COLON .)
    until           reduce using rule 139 (newline -> SEMI_COLON .)
    case            reduce using rule 139 (newline -> SEMI_COLON .)
    for             reduce using rule 139 (newline -> SEMI_COLON .)
    return          reduce using rule 139 (newline -> SEMI_COLON .)
    IDENTIFIER      reduce using rule 139 (newline -> SEMI_COLON .)
    nil             reduce using rule 139 (newline -> SEMI_COLON .)
    self            reduce using rule 139 (newline -> SEMI_COLON .)
    GLOBAL          reduce using rule 139 (newline -> SEMI_COLON .)
    AT_THE_RATE     reduce using rule 139 (newline -> SEMI_COLON .)
    MINUS           reduce using rule 139 (newline -> SEMI_COLON .)
    PLUS            reduce using rule 139 (newline -> SEMI_COLON .)
    OPEN_BRACKET    reduce using rule 139 (newline -> SEMI_COLON .)
    Array           reduce using rule 139 (newline -> SEMI_COLON .)
    NUMBER          reduce using rule 139 (newline -> SEMI_COLON .)
    FLOAT           reduce using rule 139 (newline -> SEMI_COLON .)
    STRING          reduce using rule 139 (newline -> SEMI_COLON .)
    true            reduce using rule 139 (newline -> SEMI_COLON .)
    false           reduce using rule 139 (newline -> SEMI_COLON .)
    $end            reduce using rule 139 (newline -> SEMI_COLON .)
    end             reduce using rule 139 (newline -> SEMI_COLON .)
    then            reduce using rule 139 (newline -> SEMI_COLON .)
    else            reduce using rule 139 (newline -> SEMI_COLON .)
    elsif           reduce using rule 139 (newline -> SEMI_COLON .)
    when            reduce using rule 139 (newline -> SEMI_COLON .)
    do              reduce using rule 139 (newline -> SEMI_COLON .)


state 7

    (140) newline -> NEWLINE .

    puts            reduce using rule 140 (newline -> NEWLINE .)
    print           reduce using rule 140 (newline -> NEWLINE .)
    gets            reduce using rule 140 (newline -> NEWLINE .)
    class           reduce using rule 140 (newline -> NEWLINE .)
    break           reduce using rule 140 (newline -> NEWLINE .)
    def             reduce using rule 140 (newline -> NEWLINE .)
    if              reduce using rule 140 (newline -> NEWLINE .)
    while           reduce using rule 140 (newline -> NEWLINE .)
    until           reduce using rule 140 (newline -> NEWLINE .)
    case            reduce using rule 140 (newline -> NEWLINE .)
    for             reduce using rule 140 (newline -> NEWLINE .)
    return          reduce using rule 140 (newline -> NEWLINE .)
    IDENTIFIER      reduce using rule 140 (newline -> NEWLINE .)
    nil             reduce using rule 140 (newline -> NEWLINE .)
    self            reduce using rule 140 (newline -> NEWLINE .)
    GLOBAL          reduce using rule 140 (newline -> NEWLINE .)
    AT_THE_RATE     reduce using rule 140 (newline -> NEWLINE .)
    MINUS           reduce using rule 140 (newline -> NEWLINE .)
    PLUS            reduce using rule 140 (newline -> NEWLINE .)
    OPEN_BRACKET    reduce using rule 140 (newline -> NEWLINE .)
    Array           reduce using rule 140 (newline -> NEWLINE .)
    NUMBER          reduce using rule 140 (newline -> NEWLINE .)
    FLOAT           reduce using rule 140 (newline -> NEWLINE .)
    STRING          reduce using rule 140 (newline -> NEWLINE .)
    true            reduce using rule 140 (newline -> NEWLINE .)
    false           reduce using rule 140 (newline -> NEWLINE .)
    $end            reduce using rule 140 (newline -> NEWLINE .)
    end             reduce using rule 140 (newline -> NEWLINE .)
    then            reduce using rule 140 (newline -> NEWLINE .)
    else            reduce using rule 140 (newline -> NEWLINE .)
    elsif           reduce using rule 140 (newline -> NEWLINE .)
    when            reduce using rule 140 (newline -> NEWLINE .)
    do              reduce using rule 140 (newline -> NEWLINE .)


state 8

    (6) stmt1 -> stmt .

    SEMI_COLON      reduce using rule 6 (stmt1 -> stmt .)
    NEWLINE         reduce using rule 6 (stmt1 -> stmt .)
    puts            reduce using rule 6 (stmt1 -> stmt .)
    print           reduce using rule 6 (stmt1 -> stmt .)
    gets            reduce using rule 6 (stmt1 -> stmt .)
    class           reduce using rule 6 (stmt1 -> stmt .)
    break           reduce using rule 6 (stmt1 -> stmt .)
    def             reduce using rule 6 (stmt1 -> stmt .)
    if              reduce using rule 6 (stmt1 -> stmt .)
    while           reduce using rule 6 (stmt1 -> stmt .)
    until           reduce using rule 6 (stmt1 -> stmt .)
    case            reduce using rule 6 (stmt1 -> stmt .)
    for             reduce using rule 6 (stmt1 -> stmt .)
    return          reduce using rule 6 (stmt1 -> stmt .)
    IDENTIFIER      reduce using rule 6 (stmt1 -> stmt .)
    nil             reduce using rule 6 (stmt1 -> stmt .)
    self            reduce using rule 6 (stmt1 -> stmt .)
    GLOBAL          reduce using rule 6 (stmt1 -> stmt .)
    AT_THE_RATE     reduce using rule 6 (stmt1 -> stmt .)
    MINUS           reduce using rule 6 (stmt1 -> stmt .)
    PLUS            reduce using rule 6 (stmt1 -> stmt .)
    OPEN_BRACKET    reduce using rule 6 (stmt1 -> stmt .)
    Array           reduce using rule 6 (stmt1 -> stmt .)
    NUMBER          reduce using rule 6 (stmt1 -> stmt .)
    FLOAT           reduce using rule 6 (stmt1 -> stmt .)
    STRING          reduce using rule 6 (stmt1 -> stmt .)
    true            reduce using rule 6 (stmt1 -> stmt .)
    false           reduce using rule 6 (stmt1 -> stmt .)
    $end            reduce using rule 6 (stmt1 -> stmt .)


state 9

    (7) stmt -> keydef . argdecl newline multstmt keyend
    (110) argdecl -> . OPEN_BRACKET arglist CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 68

    argdecl                        shift and go to state 67

state 10

    (8) stmt -> puts . OPEN_BRACKET STRING CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 69


state 11

    (78) primary -> OPEN_BRACKET . expr2 CLOSE_BRACKET
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr2                          shift and go to state 70
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    mlhs                           shift and go to state 27
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    term2                          shift and go to state 29
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 12

    (97) literal -> STRING .

    MULTIPLY        reduce using rule 97 (literal -> STRING .)
    DIVIDE          reduce using rule 97 (literal -> STRING .)
    MODULO          reduce using rule 97 (literal -> STRING .)
    PLUS            reduce using rule 97 (literal -> STRING .)
    MINUS           reduce using rule 97 (literal -> STRING .)
    LEFT_SHIFT      reduce using rule 97 (literal -> STRING .)
    RIGHT_SHIFT     reduce using rule 97 (literal -> STRING .)
    BIT_AND         reduce using rule 97 (literal -> STRING .)
    BIT_XOR         reduce using rule 97 (literal -> STRING .)
    BIT_OR          reduce using rule 97 (literal -> STRING .)
    DOUBLE_EQUALS   reduce using rule 97 (literal -> STRING .)
    NOT_EQUALS      reduce using rule 97 (literal -> STRING .)
    EQUAL_TILDE     reduce using rule 97 (literal -> STRING .)
    COMPARISON      reduce using rule 97 (literal -> STRING .)
    LESS            reduce using rule 97 (literal -> STRING .)
    LESS_EQUALS     reduce using rule 97 (literal -> STRING .)
    GREATER         reduce using rule 97 (literal -> STRING .)
    GREATER_EQUALS  reduce using rule 97 (literal -> STRING .)
    INCL_RANGE      reduce using rule 97 (literal -> STRING .)
    EXCL_RANGE      reduce using rule 97 (literal -> STRING .)
    LOGICAL_OR      reduce using rule 97 (literal -> STRING .)
    SEMI_COLON      reduce using rule 97 (literal -> STRING .)
    NEWLINE         reduce using rule 97 (literal -> STRING .)
    puts            reduce using rule 97 (literal -> STRING .)
    print           reduce using rule 97 (literal -> STRING .)
    gets            reduce using rule 97 (literal -> STRING .)
    class           reduce using rule 97 (literal -> STRING .)
    break           reduce using rule 97 (literal -> STRING .)
    def             reduce using rule 97 (literal -> STRING .)
    if              reduce using rule 97 (literal -> STRING .)
    while           reduce using rule 97 (literal -> STRING .)
    until           reduce using rule 97 (literal -> STRING .)
    case            reduce using rule 97 (literal -> STRING .)
    for             reduce using rule 97 (literal -> STRING .)
    return          reduce using rule 97 (literal -> STRING .)
    IDENTIFIER      reduce using rule 97 (literal -> STRING .)
    nil             reduce using rule 97 (literal -> STRING .)
    self            reduce using rule 97 (literal -> STRING .)
    GLOBAL          reduce using rule 97 (literal -> STRING .)
    AT_THE_RATE     reduce using rule 97 (literal -> STRING .)
    OPEN_BRACKET    reduce using rule 97 (literal -> STRING .)
    Array           reduce using rule 97 (literal -> STRING .)
    NUMBER          reduce using rule 97 (literal -> STRING .)
    FLOAT           reduce using rule 97 (literal -> STRING .)
    STRING          reduce using rule 97 (literal -> STRING .)
    true            reduce using rule 97 (literal -> STRING .)
    false           reduce using rule 97 (literal -> STRING .)
    $end            reduce using rule 97 (literal -> STRING .)
    CLOSE_BRACKET   reduce using rule 97 (literal -> STRING .)
    then            reduce using rule 97 (literal -> STRING .)
    do              reduce using rule 97 (literal -> STRING .)
    COMMA           reduce using rule 97 (literal -> STRING .)
    CLOSE_SQUARE    reduce using rule 97 (literal -> STRING .)


state 13

    (9) stmt -> print . OPEN_BRACKET primary CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 71


state 14

    (77) term13 -> primary .

    MULTIPLY        reduce using rule 77 (term13 -> primary .)
    DIVIDE          reduce using rule 77 (term13 -> primary .)
    MODULO          reduce using rule 77 (term13 -> primary .)
    PLUS            reduce using rule 77 (term13 -> primary .)
    MINUS           reduce using rule 77 (term13 -> primary .)
    LEFT_SHIFT      reduce using rule 77 (term13 -> primary .)
    RIGHT_SHIFT     reduce using rule 77 (term13 -> primary .)
    BIT_AND         reduce using rule 77 (term13 -> primary .)
    BIT_XOR         reduce using rule 77 (term13 -> primary .)
    BIT_OR          reduce using rule 77 (term13 -> primary .)
    DOUBLE_EQUALS   reduce using rule 77 (term13 -> primary .)
    NOT_EQUALS      reduce using rule 77 (term13 -> primary .)
    EQUAL_TILDE     reduce using rule 77 (term13 -> primary .)
    COMPARISON      reduce using rule 77 (term13 -> primary .)
    LESS            reduce using rule 77 (term13 -> primary .)
    LESS_EQUALS     reduce using rule 77 (term13 -> primary .)
    GREATER         reduce using rule 77 (term13 -> primary .)
    GREATER_EQUALS  reduce using rule 77 (term13 -> primary .)
    INCL_RANGE      reduce using rule 77 (term13 -> primary .)
    EXCL_RANGE      reduce using rule 77 (term13 -> primary .)
    LOGICAL_OR      reduce using rule 77 (term13 -> primary .)
    SEMI_COLON      reduce using rule 77 (term13 -> primary .)
    NEWLINE         reduce using rule 77 (term13 -> primary .)
    puts            reduce using rule 77 (term13 -> primary .)
    print           reduce using rule 77 (term13 -> primary .)
    gets            reduce using rule 77 (term13 -> primary .)
    class           reduce using rule 77 (term13 -> primary .)
    break           reduce using rule 77 (term13 -> primary .)
    def             reduce using rule 77 (term13 -> primary .)
    if              reduce using rule 77 (term13 -> primary .)
    while           reduce using rule 77 (term13 -> primary .)
    until           reduce using rule 77 (term13 -> primary .)
    case            reduce using rule 77 (term13 -> primary .)
    for             reduce using rule 77 (term13 -> primary .)
    return          reduce using rule 77 (term13 -> primary .)
    IDENTIFIER      reduce using rule 77 (term13 -> primary .)
    nil             reduce using rule 77 (term13 -> primary .)
    self            reduce using rule 77 (term13 -> primary .)
    GLOBAL          reduce using rule 77 (term13 -> primary .)
    AT_THE_RATE     reduce using rule 77 (term13 -> primary .)
    OPEN_BRACKET    reduce using rule 77 (term13 -> primary .)
    Array           reduce using rule 77 (term13 -> primary .)
    NUMBER          reduce using rule 77 (term13 -> primary .)
    FLOAT           reduce using rule 77 (term13 -> primary .)
    STRING          reduce using rule 77 (term13 -> primary .)
    true            reduce using rule 77 (term13 -> primary .)
    false           reduce using rule 77 (term13 -> primary .)
    $end            reduce using rule 77 (term13 -> primary .)
    CLOSE_BRACKET   reduce using rule 77 (term13 -> primary .)
    then            reduce using rule 77 (term13 -> primary .)
    do              reduce using rule 77 (term13 -> primary .)


state 15

    (10) stmt -> gets . OPEN_BRACKET IDENTIFIER CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 72


state 16

    (34) function -> IDENTIFIER . OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> IDENTIFIER . OPEN_BRACKET CLOSE_BRACKET
    (102) mlhsitem -> IDENTIFIER .
    (138) varname -> IDENTIFIER .

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    OPEN_BRACKET    shift and go to state 73
    EQUALS          reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    OR_EQUALS       reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    AND_EQUALS      reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    XOR_EQUALS      reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    LOGICAL_AND_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    LOGICAL_OR_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 138 (varname -> IDENTIFIER .)
    MULTIPLY        reduce using rule 138 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 138 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 138 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 138 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 138 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 138 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 138 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 138 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 138 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 138 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 138 (varname -> IDENTIFIER .)
    LESS            reduce using rule 138 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 138 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 138 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 138 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 138 (varname -> IDENTIFIER .)
    puts            reduce using rule 138 (varname -> IDENTIFIER .)
    print           reduce using rule 138 (varname -> IDENTIFIER .)
    gets            reduce using rule 138 (varname -> IDENTIFIER .)
    class           reduce using rule 138 (varname -> IDENTIFIER .)
    break           reduce using rule 138 (varname -> IDENTIFIER .)
    def             reduce using rule 138 (varname -> IDENTIFIER .)
    if              reduce using rule 138 (varname -> IDENTIFIER .)
    while           reduce using rule 138 (varname -> IDENTIFIER .)
    until           reduce using rule 138 (varname -> IDENTIFIER .)
    case            reduce using rule 138 (varname -> IDENTIFIER .)
    for             reduce using rule 138 (varname -> IDENTIFIER .)
    return          reduce using rule 138 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 138 (varname -> IDENTIFIER .)
    nil             reduce using rule 138 (varname -> IDENTIFIER .)
    self            reduce using rule 138 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 138 (varname -> IDENTIFIER .)
    AT_THE_RATE     reduce using rule 138 (varname -> IDENTIFIER .)
    Array           reduce using rule 138 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 138 (varname -> IDENTIFIER .)
    FLOAT           reduce using rule 138 (varname -> IDENTIFIER .)
    STRING          reduce using rule 138 (varname -> IDENTIFIER .)
    true            reduce using rule 138 (varname -> IDENTIFIER .)
    false           reduce using rule 138 (varname -> IDENTIFIER .)
    $end            reduce using rule 138 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 138 (varname -> IDENTIFIER .)
    then            reduce using rule 138 (varname -> IDENTIFIER .)
    do              reduce using rule 138 (varname -> IDENTIFIER .)

  ! OPEN_BRACKET    [ reduce using rule 138 (varname -> IDENTIFIER .) ]


state 17

    (11) stmt -> class . IDENTIFIER newline multstmt end
    (12) stmt -> class . IDENTIFIER LESS IDENTIFIER newline multstmt end

    IDENTIFIER      shift and go to state 74


state 18

    (13) stmt -> break .

    SEMI_COLON      reduce using rule 13 (stmt -> break .)
    NEWLINE         reduce using rule 13 (stmt -> break .)
    puts            reduce using rule 13 (stmt -> break .)
    print           reduce using rule 13 (stmt -> break .)
    gets            reduce using rule 13 (stmt -> break .)
    class           reduce using rule 13 (stmt -> break .)
    break           reduce using rule 13 (stmt -> break .)
    def             reduce using rule 13 (stmt -> break .)
    if              reduce using rule 13 (stmt -> break .)
    while           reduce using rule 13 (stmt -> break .)
    until           reduce using rule 13 (stmt -> break .)
    case            reduce using rule 13 (stmt -> break .)
    for             reduce using rule 13 (stmt -> break .)
    return          reduce using rule 13 (stmt -> break .)
    IDENTIFIER      reduce using rule 13 (stmt -> break .)
    nil             reduce using rule 13 (stmt -> break .)
    self            reduce using rule 13 (stmt -> break .)
    GLOBAL          reduce using rule 13 (stmt -> break .)
    AT_THE_RATE     reduce using rule 13 (stmt -> break .)
    MINUS           reduce using rule 13 (stmt -> break .)
    PLUS            reduce using rule 13 (stmt -> break .)
    OPEN_BRACKET    reduce using rule 13 (stmt -> break .)
    Array           reduce using rule 13 (stmt -> break .)
    NUMBER          reduce using rule 13 (stmt -> break .)
    FLOAT           reduce using rule 13 (stmt -> break .)
    STRING          reduce using rule 13 (stmt -> break .)
    true            reduce using rule 13 (stmt -> break .)
    false           reduce using rule 13 (stmt -> break .)
    $end            reduce using rule 13 (stmt -> break .)


state 19

    (14) stmt -> expr .

    SEMI_COLON      reduce using rule 14 (stmt -> expr .)
    NEWLINE         reduce using rule 14 (stmt -> expr .)
    puts            reduce using rule 14 (stmt -> expr .)
    print           reduce using rule 14 (stmt -> expr .)
    gets            reduce using rule 14 (stmt -> expr .)
    class           reduce using rule 14 (stmt -> expr .)
    break           reduce using rule 14 (stmt -> expr .)
    def             reduce using rule 14 (stmt -> expr .)
    if              reduce using rule 14 (stmt -> expr .)
    while           reduce using rule 14 (stmt -> expr .)
    until           reduce using rule 14 (stmt -> expr .)
    case            reduce using rule 14 (stmt -> expr .)
    for             reduce using rule 14 (stmt -> expr .)
    return          reduce using rule 14 (stmt -> expr .)
    IDENTIFIER      reduce using rule 14 (stmt -> expr .)
    nil             reduce using rule 14 (stmt -> expr .)
    self            reduce using rule 14 (stmt -> expr .)
    GLOBAL          reduce using rule 14 (stmt -> expr .)
    AT_THE_RATE     reduce using rule 14 (stmt -> expr .)
    MINUS           reduce using rule 14 (stmt -> expr .)
    PLUS            reduce using rule 14 (stmt -> expr .)
    OPEN_BRACKET    reduce using rule 14 (stmt -> expr .)
    Array           reduce using rule 14 (stmt -> expr .)
    NUMBER          reduce using rule 14 (stmt -> expr .)
    FLOAT           reduce using rule 14 (stmt -> expr .)
    STRING          reduce using rule 14 (stmt -> expr .)
    true            reduce using rule 14 (stmt -> expr .)
    false           reduce using rule 14 (stmt -> expr .)
    $end            reduce using rule 14 (stmt -> expr .)


state 20

    (15) keydef -> def . IDENTIFIER

    IDENTIFIER      shift and go to state 75


state 21

    (19) expr -> if . expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> if . expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> if . expr1 pthen M_1 multstmt end M_1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 76
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    mlhs                           shift and go to state 27
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 22

    (26) expr -> expr1 .

    SEMI_COLON      reduce using rule 26 (expr -> expr1 .)
    NEWLINE         reduce using rule 26 (expr -> expr1 .)
    puts            reduce using rule 26 (expr -> expr1 .)
    print           reduce using rule 26 (expr -> expr1 .)
    gets            reduce using rule 26 (expr -> expr1 .)
    class           reduce using rule 26 (expr -> expr1 .)
    break           reduce using rule 26 (expr -> expr1 .)
    def             reduce using rule 26 (expr -> expr1 .)
    if              reduce using rule 26 (expr -> expr1 .)
    while           reduce using rule 26 (expr -> expr1 .)
    until           reduce using rule 26 (expr -> expr1 .)
    case            reduce using rule 26 (expr -> expr1 .)
    for             reduce using rule 26 (expr -> expr1 .)
    return          reduce using rule 26 (expr -> expr1 .)
    IDENTIFIER      reduce using rule 26 (expr -> expr1 .)
    nil             reduce using rule 26 (expr -> expr1 .)
    self            reduce using rule 26 (expr -> expr1 .)
    GLOBAL          reduce using rule 26 (expr -> expr1 .)
    AT_THE_RATE     reduce using rule 26 (expr -> expr1 .)
    MINUS           reduce using rule 26 (expr -> expr1 .)
    PLUS            reduce using rule 26 (expr -> expr1 .)
    OPEN_BRACKET    reduce using rule 26 (expr -> expr1 .)
    Array           reduce using rule 26 (expr -> expr1 .)
    NUMBER          reduce using rule 26 (expr -> expr1 .)
    FLOAT           reduce using rule 26 (expr -> expr1 .)
    STRING          reduce using rule 26 (expr -> expr1 .)
    true            reduce using rule 26 (expr -> expr1 .)
    false           reduce using rule 26 (expr -> expr1 .)
    $end            reduce using rule 26 (expr -> expr1 .)
    then            reduce using rule 26 (expr -> expr1 .)


state 23

    (22) expr -> while . M_1 expr1 pdo M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 77
    empty                          shift and go to state 78

state 24

    (23) expr -> until . M_1 expr1 pdo M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 79
    empty                          shift and go to state 78

state 25

    (24) expr -> case . expr1 newline multcase end M_1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 80
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    mlhs                           shift and go to state 27
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 26

    (25) expr -> for . M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 81
    empty                          shift and go to state 78

state 27

    (37) term0 -> mlhs . EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> mlhs . EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (40) term1 -> mlhs . EQUALS mrhs
    (41) term1 -> mlhs . opasgn mrhs
    (124) opasgn -> . MODULO_EQUALS
    (125) opasgn -> . DIVIDE_EQUALS
    (126) opasgn -> . MINUS_EQUALS
    (127) opasgn -> . PLUS_EQUALS
    (128) opasgn -> . OR_EQUALS
    (129) opasgn -> . AND_EQUALS
    (130) opasgn -> . XOR_EQUALS
    (131) opasgn -> . RIGHT_SHIFT_EQUALS
    (132) opasgn -> . LEFT_SHIFT_EQUALS
    (133) opasgn -> . MULTIPLY_EQUALS
    (134) opasgn -> . LOGICAL_AND_EQUALS
    (135) opasgn -> . LOGICAL_OR_EQUALS

    EQUALS          shift and go to state 82
    MODULO_EQUALS   shift and go to state 84
    DIVIDE_EQUALS   shift and go to state 85
    MINUS_EQUALS    shift and go to state 86
    PLUS_EQUALS     shift and go to state 87
    OR_EQUALS       shift and go to state 88
    AND_EQUALS      shift and go to state 89
    XOR_EQUALS      shift and go to state 90
    RIGHT_SHIFT_EQUALS shift and go to state 91
    LEFT_SHIFT_EQUALS shift and go to state 92
    MULTIPLY_EQUALS shift and go to state 93
    LOGICAL_AND_EQUALS shift and go to state 94
    LOGICAL_OR_EQUALS shift and go to state 95

    opasgn                         shift and go to state 83

state 28

    (28) expr1 -> return . term2
    (29) expr1 -> return .
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
  ! shift/reduce conflict for Array resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for true resolved as shift
  ! shift/reduce conflict for false resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for AT_THE_RATE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for nil resolved as shift
  ! shift/reduce conflict for self resolved as shift
    SEMI_COLON      reduce using rule 29 (expr1 -> return .)
    NEWLINE         reduce using rule 29 (expr1 -> return .)
    puts            reduce using rule 29 (expr1 -> return .)
    print           reduce using rule 29 (expr1 -> return .)
    gets            reduce using rule 29 (expr1 -> return .)
    class           reduce using rule 29 (expr1 -> return .)
    break           reduce using rule 29 (expr1 -> return .)
    def             reduce using rule 29 (expr1 -> return .)
    if              reduce using rule 29 (expr1 -> return .)
    while           reduce using rule 29 (expr1 -> return .)
    until           reduce using rule 29 (expr1 -> return .)
    case            reduce using rule 29 (expr1 -> return .)
    for             reduce using rule 29 (expr1 -> return .)
    return          reduce using rule 29 (expr1 -> return .)
    $end            reduce using rule 29 (expr1 -> return .)
    then            reduce using rule 29 (expr1 -> return .)
    do              reduce using rule 29 (expr1 -> return .)
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

  ! IDENTIFIER      [ reduce using rule 29 (expr1 -> return .) ]
  ! nil             [ reduce using rule 29 (expr1 -> return .) ]
  ! self            [ reduce using rule 29 (expr1 -> return .) ]
  ! GLOBAL          [ reduce using rule 29 (expr1 -> return .) ]
  ! AT_THE_RATE     [ reduce using rule 29 (expr1 -> return .) ]
  ! MINUS           [ reduce using rule 29 (expr1 -> return .) ]
  ! PLUS            [ reduce using rule 29 (expr1 -> return .) ]
  ! OPEN_BRACKET    [ reduce using rule 29 (expr1 -> return .) ]
  ! Array           [ reduce using rule 29 (expr1 -> return .) ]
  ! NUMBER          [ reduce using rule 29 (expr1 -> return .) ]
  ! FLOAT           [ reduce using rule 29 (expr1 -> return .) ]
  ! STRING          [ reduce using rule 29 (expr1 -> return .) ]
  ! true            [ reduce using rule 29 (expr1 -> return .) ]
  ! false           [ reduce using rule 29 (expr1 -> return .) ]

    term2                          shift and go to state 96
    term3                          shift and go to state 38
    term4                          shift and go to state 40
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 29

    (42) term1 -> term2 .

    SEMI_COLON      reduce using rule 42 (term1 -> term2 .)
    NEWLINE         reduce using rule 42 (term1 -> term2 .)
    puts            reduce using rule 42 (term1 -> term2 .)
    print           reduce using rule 42 (term1 -> term2 .)
    gets            reduce using rule 42 (term1 -> term2 .)
    class           reduce using rule 42 (term1 -> term2 .)
    break           reduce using rule 42 (term1 -> term2 .)
    def             reduce using rule 42 (term1 -> term2 .)
    if              reduce using rule 42 (term1 -> term2 .)
    while           reduce using rule 42 (term1 -> term2 .)
    until           reduce using rule 42 (term1 -> term2 .)
    case            reduce using rule 42 (term1 -> term2 .)
    for             reduce using rule 42 (term1 -> term2 .)
    return          reduce using rule 42 (term1 -> term2 .)
    IDENTIFIER      reduce using rule 42 (term1 -> term2 .)
    nil             reduce using rule 42 (term1 -> term2 .)
    self            reduce using rule 42 (term1 -> term2 .)
    GLOBAL          reduce using rule 42 (term1 -> term2 .)
    AT_THE_RATE     reduce using rule 42 (term1 -> term2 .)
    MINUS           reduce using rule 42 (term1 -> term2 .)
    PLUS            reduce using rule 42 (term1 -> term2 .)
    OPEN_BRACKET    reduce using rule 42 (term1 -> term2 .)
    Array           reduce using rule 42 (term1 -> term2 .)
    NUMBER          reduce using rule 42 (term1 -> term2 .)
    FLOAT           reduce using rule 42 (term1 -> term2 .)
    STRING          reduce using rule 42 (term1 -> term2 .)
    true            reduce using rule 42 (term1 -> term2 .)
    false           reduce using rule 42 (term1 -> term2 .)
    $end            reduce using rule 42 (term1 -> term2 .)
    CLOSE_BRACKET   reduce using rule 42 (term1 -> term2 .)
    then            reduce using rule 42 (term1 -> term2 .)
    do              reduce using rule 42 (term1 -> term2 .)


state 30

    (30) expr1 -> expr2 .

    SEMI_COLON      reduce using rule 30 (expr1 -> expr2 .)
    NEWLINE         reduce using rule 30 (expr1 -> expr2 .)
    puts            reduce using rule 30 (expr1 -> expr2 .)
    print           reduce using rule 30 (expr1 -> expr2 .)
    gets            reduce using rule 30 (expr1 -> expr2 .)
    class           reduce using rule 30 (expr1 -> expr2 .)
    break           reduce using rule 30 (expr1 -> expr2 .)
    def             reduce using rule 30 (expr1 -> expr2 .)
    if              reduce using rule 30 (expr1 -> expr2 .)
    while           reduce using rule 30 (expr1 -> expr2 .)
    until           reduce using rule 30 (expr1 -> expr2 .)
    case            reduce using rule 30 (expr1 -> expr2 .)
    for             reduce using rule 30 (expr1 -> expr2 .)
    return          reduce using rule 30 (expr1 -> expr2 .)
    IDENTIFIER      reduce using rule 30 (expr1 -> expr2 .)
    nil             reduce using rule 30 (expr1 -> expr2 .)
    self            reduce using rule 30 (expr1 -> expr2 .)
    GLOBAL          reduce using rule 30 (expr1 -> expr2 .)
    AT_THE_RATE     reduce using rule 30 (expr1 -> expr2 .)
    MINUS           reduce using rule 30 (expr1 -> expr2 .)
    PLUS            reduce using rule 30 (expr1 -> expr2 .)
    OPEN_BRACKET    reduce using rule 30 (expr1 -> expr2 .)
    Array           reduce using rule 30 (expr1 -> expr2 .)
    NUMBER          reduce using rule 30 (expr1 -> expr2 .)
    FLOAT           reduce using rule 30 (expr1 -> expr2 .)
    STRING          reduce using rule 30 (expr1 -> expr2 .)
    true            reduce using rule 30 (expr1 -> expr2 .)
    false           reduce using rule 30 (expr1 -> expr2 .)
    $end            reduce using rule 30 (expr1 -> expr2 .)
    then            reduce using rule 30 (expr1 -> expr2 .)
    do              reduce using rule 30 (expr1 -> expr2 .)


state 31

    (31) expr2 -> arg .

    SEMI_COLON      reduce using rule 31 (expr2 -> arg .)
    NEWLINE         reduce using rule 31 (expr2 -> arg .)
    puts            reduce using rule 31 (expr2 -> arg .)
    print           reduce using rule 31 (expr2 -> arg .)
    gets            reduce using rule 31 (expr2 -> arg .)
    class           reduce using rule 31 (expr2 -> arg .)
    break           reduce using rule 31 (expr2 -> arg .)
    def             reduce using rule 31 (expr2 -> arg .)
    if              reduce using rule 31 (expr2 -> arg .)
    while           reduce using rule 31 (expr2 -> arg .)
    until           reduce using rule 31 (expr2 -> arg .)
    case            reduce using rule 31 (expr2 -> arg .)
    for             reduce using rule 31 (expr2 -> arg .)
    return          reduce using rule 31 (expr2 -> arg .)
    IDENTIFIER      reduce using rule 31 (expr2 -> arg .)
    nil             reduce using rule 31 (expr2 -> arg .)
    self            reduce using rule 31 (expr2 -> arg .)
    GLOBAL          reduce using rule 31 (expr2 -> arg .)
    AT_THE_RATE     reduce using rule 31 (expr2 -> arg .)
    MINUS           reduce using rule 31 (expr2 -> arg .)
    PLUS            reduce using rule 31 (expr2 -> arg .)
    OPEN_BRACKET    reduce using rule 31 (expr2 -> arg .)
    Array           reduce using rule 31 (expr2 -> arg .)
    NUMBER          reduce using rule 31 (expr2 -> arg .)
    FLOAT           reduce using rule 31 (expr2 -> arg .)
    STRING          reduce using rule 31 (expr2 -> arg .)
    true            reduce using rule 31 (expr2 -> arg .)
    false           reduce using rule 31 (expr2 -> arg .)
    $end            reduce using rule 31 (expr2 -> arg .)
    CLOSE_BRACKET   reduce using rule 31 (expr2 -> arg .)
    then            reduce using rule 31 (expr2 -> arg .)
    do              reduce using rule 31 (expr2 -> arg .)


state 32

    (32) expr2 -> call .

    SEMI_COLON      reduce using rule 32 (expr2 -> call .)
    NEWLINE         reduce using rule 32 (expr2 -> call .)
    puts            reduce using rule 32 (expr2 -> call .)
    print           reduce using rule 32 (expr2 -> call .)
    gets            reduce using rule 32 (expr2 -> call .)
    class           reduce using rule 32 (expr2 -> call .)
    break           reduce using rule 32 (expr2 -> call .)
    def             reduce using rule 32 (expr2 -> call .)
    if              reduce using rule 32 (expr2 -> call .)
    while           reduce using rule 32 (expr2 -> call .)
    until           reduce using rule 32 (expr2 -> call .)
    case            reduce using rule 32 (expr2 -> call .)
    for             reduce using rule 32 (expr2 -> call .)
    return          reduce using rule 32 (expr2 -> call .)
    IDENTIFIER      reduce using rule 32 (expr2 -> call .)
    nil             reduce using rule 32 (expr2 -> call .)
    self            reduce using rule 32 (expr2 -> call .)
    GLOBAL          reduce using rule 32 (expr2 -> call .)
    AT_THE_RATE     reduce using rule 32 (expr2 -> call .)
    MINUS           reduce using rule 32 (expr2 -> call .)
    PLUS            reduce using rule 32 (expr2 -> call .)
    OPEN_BRACKET    reduce using rule 32 (expr2 -> call .)
    Array           reduce using rule 32 (expr2 -> call .)
    NUMBER          reduce using rule 32 (expr2 -> call .)
    FLOAT           reduce using rule 32 (expr2 -> call .)
    STRING          reduce using rule 32 (expr2 -> call .)
    true            reduce using rule 32 (expr2 -> call .)
    false           reduce using rule 32 (expr2 -> call .)
    $end            reduce using rule 32 (expr2 -> call .)
    CLOSE_BRACKET   reduce using rule 32 (expr2 -> call .)
    then            reduce using rule 32 (expr2 -> call .)
    do              reduce using rule 32 (expr2 -> call .)


state 33

    (36) arg -> term0 .

    SEMI_COLON      reduce using rule 36 (arg -> term0 .)
    NEWLINE         reduce using rule 36 (arg -> term0 .)
    puts            reduce using rule 36 (arg -> term0 .)
    print           reduce using rule 36 (arg -> term0 .)
    gets            reduce using rule 36 (arg -> term0 .)
    class           reduce using rule 36 (arg -> term0 .)
    break           reduce using rule 36 (arg -> term0 .)
    def             reduce using rule 36 (arg -> term0 .)
    if              reduce using rule 36 (arg -> term0 .)
    while           reduce using rule 36 (arg -> term0 .)
    until           reduce using rule 36 (arg -> term0 .)
    case            reduce using rule 36 (arg -> term0 .)
    for             reduce using rule 36 (arg -> term0 .)
    return          reduce using rule 36 (arg -> term0 .)
    IDENTIFIER      reduce using rule 36 (arg -> term0 .)
    nil             reduce using rule 36 (arg -> term0 .)
    self            reduce using rule 36 (arg -> term0 .)
    GLOBAL          reduce using rule 36 (arg -> term0 .)
    AT_THE_RATE     reduce using rule 36 (arg -> term0 .)
    MINUS           reduce using rule 36 (arg -> term0 .)
    PLUS            reduce using rule 36 (arg -> term0 .)
    OPEN_BRACKET    reduce using rule 36 (arg -> term0 .)
    Array           reduce using rule 36 (arg -> term0 .)
    NUMBER          reduce using rule 36 (arg -> term0 .)
    FLOAT           reduce using rule 36 (arg -> term0 .)
    STRING          reduce using rule 36 (arg -> term0 .)
    true            reduce using rule 36 (arg -> term0 .)
    false           reduce using rule 36 (arg -> term0 .)
    $end            reduce using rule 36 (arg -> term0 .)
    CLOSE_BRACKET   reduce using rule 36 (arg -> term0 .)
    then            reduce using rule 36 (arg -> term0 .)
    do              reduce using rule 36 (arg -> term0 .)


state 34

    (33) call -> function .

    SEMI_COLON      reduce using rule 33 (call -> function .)
    NEWLINE         reduce using rule 33 (call -> function .)
    puts            reduce using rule 33 (call -> function .)
    print           reduce using rule 33 (call -> function .)
    gets            reduce using rule 33 (call -> function .)
    class           reduce using rule 33 (call -> function .)
    break           reduce using rule 33 (call -> function .)
    def             reduce using rule 33 (call -> function .)
    if              reduce using rule 33 (call -> function .)
    while           reduce using rule 33 (call -> function .)
    until           reduce using rule 33 (call -> function .)
    case            reduce using rule 33 (call -> function .)
    for             reduce using rule 33 (call -> function .)
    return          reduce using rule 33 (call -> function .)
    IDENTIFIER      reduce using rule 33 (call -> function .)
    nil             reduce using rule 33 (call -> function .)
    self            reduce using rule 33 (call -> function .)
    GLOBAL          reduce using rule 33 (call -> function .)
    AT_THE_RATE     reduce using rule 33 (call -> function .)
    MINUS           reduce using rule 33 (call -> function .)
    PLUS            reduce using rule 33 (call -> function .)
    OPEN_BRACKET    reduce using rule 33 (call -> function .)
    Array           reduce using rule 33 (call -> function .)
    NUMBER          reduce using rule 33 (call -> function .)
    FLOAT           reduce using rule 33 (call -> function .)
    STRING          reduce using rule 33 (call -> function .)
    true            reduce using rule 33 (call -> function .)
    false           reduce using rule 33 (call -> function .)
    $end            reduce using rule 33 (call -> function .)
    CLOSE_BRACKET   reduce using rule 33 (call -> function .)
    then            reduce using rule 33 (call -> function .)
    do              reduce using rule 33 (call -> function .)


state 35

    (39) term0 -> term1 .

    SEMI_COLON      reduce using rule 39 (term0 -> term1 .)
    NEWLINE         reduce using rule 39 (term0 -> term1 .)
    puts            reduce using rule 39 (term0 -> term1 .)
    print           reduce using rule 39 (term0 -> term1 .)
    gets            reduce using rule 39 (term0 -> term1 .)
    class           reduce using rule 39 (term0 -> term1 .)
    break           reduce using rule 39 (term0 -> term1 .)
    def             reduce using rule 39 (term0 -> term1 .)
    if              reduce using rule 39 (term0 -> term1 .)
    while           reduce using rule 39 (term0 -> term1 .)
    until           reduce using rule 39 (term0 -> term1 .)
    case            reduce using rule 39 (term0 -> term1 .)
    for             reduce using rule 39 (term0 -> term1 .)
    return          reduce using rule 39 (term0 -> term1 .)
    IDENTIFIER      reduce using rule 39 (term0 -> term1 .)
    nil             reduce using rule 39 (term0 -> term1 .)
    self            reduce using rule 39 (term0 -> term1 .)
    GLOBAL          reduce using rule 39 (term0 -> term1 .)
    AT_THE_RATE     reduce using rule 39 (term0 -> term1 .)
    MINUS           reduce using rule 39 (term0 -> term1 .)
    PLUS            reduce using rule 39 (term0 -> term1 .)
    OPEN_BRACKET    reduce using rule 39 (term0 -> term1 .)
    Array           reduce using rule 39 (term0 -> term1 .)
    NUMBER          reduce using rule 39 (term0 -> term1 .)
    FLOAT           reduce using rule 39 (term0 -> term1 .)
    STRING          reduce using rule 39 (term0 -> term1 .)
    true            reduce using rule 39 (term0 -> term1 .)
    false           reduce using rule 39 (term0 -> term1 .)
    $end            reduce using rule 39 (term0 -> term1 .)
    CLOSE_BRACKET   reduce using rule 39 (term0 -> term1 .)
    then            reduce using rule 39 (term0 -> term1 .)
    do              reduce using rule 39 (term0 -> term1 .)


state 36

    (101) mlhs -> mlhsitem .

    EQUALS          reduce using rule 101 (mlhs -> mlhsitem .)
    MODULO_EQUALS   reduce using rule 101 (mlhs -> mlhsitem .)
    DIVIDE_EQUALS   reduce using rule 101 (mlhs -> mlhsitem .)
    MINUS_EQUALS    reduce using rule 101 (mlhs -> mlhsitem .)
    PLUS_EQUALS     reduce using rule 101 (mlhs -> mlhsitem .)
    OR_EQUALS       reduce using rule 101 (mlhs -> mlhsitem .)
    AND_EQUALS      reduce using rule 101 (mlhs -> mlhsitem .)
    XOR_EQUALS      reduce using rule 101 (mlhs -> mlhsitem .)
    RIGHT_SHIFT_EQUALS reduce using rule 101 (mlhs -> mlhsitem .)
    LEFT_SHIFT_EQUALS reduce using rule 101 (mlhs -> mlhsitem .)
    MULTIPLY_EQUALS reduce using rule 101 (mlhs -> mlhsitem .)
    LOGICAL_AND_EQUALS reduce using rule 101 (mlhs -> mlhsitem .)
    LOGICAL_OR_EQUALS reduce using rule 101 (mlhs -> mlhsitem .)
    in              reduce using rule 101 (mlhs -> mlhsitem .)


state 37

    (103) mlhsitem -> arrayal .

    EQUALS          reduce using rule 103 (mlhsitem -> arrayal .)
    MODULO_EQUALS   reduce using rule 103 (mlhsitem -> arrayal .)
    DIVIDE_EQUALS   reduce using rule 103 (mlhsitem -> arrayal .)
    MINUS_EQUALS    reduce using rule 103 (mlhsitem -> arrayal .)
    PLUS_EQUALS     reduce using rule 103 (mlhsitem -> arrayal .)
    OR_EQUALS       reduce using rule 103 (mlhsitem -> arrayal .)
    AND_EQUALS      reduce using rule 103 (mlhsitem -> arrayal .)
    XOR_EQUALS      reduce using rule 103 (mlhsitem -> arrayal .)
    RIGHT_SHIFT_EQUALS reduce using rule 103 (mlhsitem -> arrayal .)
    LEFT_SHIFT_EQUALS reduce using rule 103 (mlhsitem -> arrayal .)
    MULTIPLY_EQUALS reduce using rule 103 (mlhsitem -> arrayal .)
    LOGICAL_AND_EQUALS reduce using rule 103 (mlhsitem -> arrayal .)
    LOGICAL_OR_EQUALS reduce using rule 103 (mlhsitem -> arrayal .)
    in              reduce using rule 103 (mlhsitem -> arrayal .)


state 38

    (43) term2 -> term3 . INCL_RANGE term3
    (44) term2 -> term3 . EXCL_RANGE term3
    (45) term2 -> term3 .
    (46) term3 -> term3 . LOGICAL_OR term4

    INCL_RANGE      shift and go to state 100
    EXCL_RANGE      shift and go to state 101
    SEMI_COLON      reduce using rule 45 (term2 -> term3 .)
    NEWLINE         reduce using rule 45 (term2 -> term3 .)
    puts            reduce using rule 45 (term2 -> term3 .)
    print           reduce using rule 45 (term2 -> term3 .)
    gets            reduce using rule 45 (term2 -> term3 .)
    class           reduce using rule 45 (term2 -> term3 .)
    break           reduce using rule 45 (term2 -> term3 .)
    def             reduce using rule 45 (term2 -> term3 .)
    if              reduce using rule 45 (term2 -> term3 .)
    while           reduce using rule 45 (term2 -> term3 .)
    until           reduce using rule 45 (term2 -> term3 .)
    case            reduce using rule 45 (term2 -> term3 .)
    for             reduce using rule 45 (term2 -> term3 .)
    return          reduce using rule 45 (term2 -> term3 .)
    IDENTIFIER      reduce using rule 45 (term2 -> term3 .)
    nil             reduce using rule 45 (term2 -> term3 .)
    self            reduce using rule 45 (term2 -> term3 .)
    GLOBAL          reduce using rule 45 (term2 -> term3 .)
    AT_THE_RATE     reduce using rule 45 (term2 -> term3 .)
    MINUS           reduce using rule 45 (term2 -> term3 .)
    PLUS            reduce using rule 45 (term2 -> term3 .)
    OPEN_BRACKET    reduce using rule 45 (term2 -> term3 .)
    Array           reduce using rule 45 (term2 -> term3 .)
    NUMBER          reduce using rule 45 (term2 -> term3 .)
    FLOAT           reduce using rule 45 (term2 -> term3 .)
    STRING          reduce using rule 45 (term2 -> term3 .)
    true            reduce using rule 45 (term2 -> term3 .)
    false           reduce using rule 45 (term2 -> term3 .)
    $end            reduce using rule 45 (term2 -> term3 .)
    CLOSE_BRACKET   reduce using rule 45 (term2 -> term3 .)
    then            reduce using rule 45 (term2 -> term3 .)
    do              reduce using rule 45 (term2 -> term3 .)
    LOGICAL_OR      shift and go to state 102


state 39

    (86) arrayal -> variable . OPEN_SQUARE array_args CLOSE_SQUARE
    (87) arraya -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 103


state 40

    (47) term3 -> term4 .

    INCL_RANGE      reduce using rule 47 (term3 -> term4 .)
    EXCL_RANGE      reduce using rule 47 (term3 -> term4 .)
    LOGICAL_OR      reduce using rule 47 (term3 -> term4 .)
    SEMI_COLON      reduce using rule 47 (term3 -> term4 .)
    NEWLINE         reduce using rule 47 (term3 -> term4 .)
    puts            reduce using rule 47 (term3 -> term4 .)
    print           reduce using rule 47 (term3 -> term4 .)
    gets            reduce using rule 47 (term3 -> term4 .)
    class           reduce using rule 47 (term3 -> term4 .)
    break           reduce using rule 47 (term3 -> term4 .)
    def             reduce using rule 47 (term3 -> term4 .)
    if              reduce using rule 47 (term3 -> term4 .)
    while           reduce using rule 47 (term3 -> term4 .)
    until           reduce using rule 47 (term3 -> term4 .)
    case            reduce using rule 47 (term3 -> term4 .)
    for             reduce using rule 47 (term3 -> term4 .)
    return          reduce using rule 47 (term3 -> term4 .)
    IDENTIFIER      reduce using rule 47 (term3 -> term4 .)
    nil             reduce using rule 47 (term3 -> term4 .)
    self            reduce using rule 47 (term3 -> term4 .)
    GLOBAL          reduce using rule 47 (term3 -> term4 .)
    AT_THE_RATE     reduce using rule 47 (term3 -> term4 .)
    MINUS           reduce using rule 47 (term3 -> term4 .)
    PLUS            reduce using rule 47 (term3 -> term4 .)
    OPEN_BRACKET    reduce using rule 47 (term3 -> term4 .)
    Array           reduce using rule 47 (term3 -> term4 .)
    NUMBER          reduce using rule 47 (term3 -> term4 .)
    FLOAT           reduce using rule 47 (term3 -> term4 .)
    STRING          reduce using rule 47 (term3 -> term4 .)
    true            reduce using rule 47 (term3 -> term4 .)
    false           reduce using rule 47 (term3 -> term4 .)
    $end            reduce using rule 47 (term3 -> term4 .)
    CLOSE_BRACKET   reduce using rule 47 (term3 -> term4 .)
    then            reduce using rule 47 (term3 -> term4 .)
    do              reduce using rule 47 (term3 -> term4 .)


state 41

    (115) variable -> varname .
    (82) primary -> varname .

    OPEN_SQUARE     reduce using rule 115 (variable -> varname .)
    MULTIPLY        reduce using rule 82 (primary -> varname .)
    DIVIDE          reduce using rule 82 (primary -> varname .)
    MODULO          reduce using rule 82 (primary -> varname .)
    PLUS            reduce using rule 82 (primary -> varname .)
    MINUS           reduce using rule 82 (primary -> varname .)
    LEFT_SHIFT      reduce using rule 82 (primary -> varname .)
    RIGHT_SHIFT     reduce using rule 82 (primary -> varname .)
    BIT_AND         reduce using rule 82 (primary -> varname .)
    BIT_XOR         reduce using rule 82 (primary -> varname .)
    BIT_OR          reduce using rule 82 (primary -> varname .)
    DOUBLE_EQUALS   reduce using rule 82 (primary -> varname .)
    NOT_EQUALS      reduce using rule 82 (primary -> varname .)
    EQUAL_TILDE     reduce using rule 82 (primary -> varname .)
    COMPARISON      reduce using rule 82 (primary -> varname .)
    LESS            reduce using rule 82 (primary -> varname .)
    LESS_EQUALS     reduce using rule 82 (primary -> varname .)
    GREATER         reduce using rule 82 (primary -> varname .)
    GREATER_EQUALS  reduce using rule 82 (primary -> varname .)
    INCL_RANGE      reduce using rule 82 (primary -> varname .)
    EXCL_RANGE      reduce using rule 82 (primary -> varname .)
    LOGICAL_OR      reduce using rule 82 (primary -> varname .)
    SEMI_COLON      reduce using rule 82 (primary -> varname .)
    NEWLINE         reduce using rule 82 (primary -> varname .)
    puts            reduce using rule 82 (primary -> varname .)
    print           reduce using rule 82 (primary -> varname .)
    gets            reduce using rule 82 (primary -> varname .)
    class           reduce using rule 82 (primary -> varname .)
    break           reduce using rule 82 (primary -> varname .)
    def             reduce using rule 82 (primary -> varname .)
    if              reduce using rule 82 (primary -> varname .)
    while           reduce using rule 82 (primary -> varname .)
    until           reduce using rule 82 (primary -> varname .)
    case            reduce using rule 82 (primary -> varname .)
    for             reduce using rule 82 (primary -> varname .)
    return          reduce using rule 82 (primary -> varname .)
    IDENTIFIER      reduce using rule 82 (primary -> varname .)
    nil             reduce using rule 82 (primary -> varname .)
    self            reduce using rule 82 (primary -> varname .)
    GLOBAL          reduce using rule 82 (primary -> varname .)
    AT_THE_RATE     reduce using rule 82 (primary -> varname .)
    OPEN_BRACKET    reduce using rule 82 (primary -> varname .)
    Array           reduce using rule 82 (primary -> varname .)
    NUMBER          reduce using rule 82 (primary -> varname .)
    FLOAT           reduce using rule 82 (primary -> varname .)
    STRING          reduce using rule 82 (primary -> varname .)
    true            reduce using rule 82 (primary -> varname .)
    false           reduce using rule 82 (primary -> varname .)
    $end            reduce using rule 82 (primary -> varname .)
    CLOSE_BRACKET   reduce using rule 82 (primary -> varname .)
    then            reduce using rule 82 (primary -> varname .)
    do              reduce using rule 82 (primary -> varname .)


state 42

    (116) variable -> nil .

    OPEN_SQUARE     reduce using rule 116 (variable -> nil .)


state 43

    (117) variable -> self .

    OPEN_SQUARE     reduce using rule 117 (variable -> self .)


state 44

    (48) term4 -> term5 . DOUBLE_EQUALS term5
    (49) term4 -> term5 . NOT_EQUALS term5
    (50) term4 -> term5 . EQUAL_TILDE term5
    (51) term4 -> term5 . COMPARISON term5
    (52) term4 -> term5 .
    (53) term5 -> term5 . LESS term6
    (54) term5 -> term5 . LESS_EQUALS term6
    (55) term5 -> term5 . GREATER term6
    (56) term5 -> term5 . GREATER_EQUALS term6

    DOUBLE_EQUALS   shift and go to state 104
    NOT_EQUALS      shift and go to state 105
    EQUAL_TILDE     shift and go to state 106
    COMPARISON      shift and go to state 107
    INCL_RANGE      reduce using rule 52 (term4 -> term5 .)
    EXCL_RANGE      reduce using rule 52 (term4 -> term5 .)
    LOGICAL_OR      reduce using rule 52 (term4 -> term5 .)
    SEMI_COLON      reduce using rule 52 (term4 -> term5 .)
    NEWLINE         reduce using rule 52 (term4 -> term5 .)
    puts            reduce using rule 52 (term4 -> term5 .)
    print           reduce using rule 52 (term4 -> term5 .)
    gets            reduce using rule 52 (term4 -> term5 .)
    class           reduce using rule 52 (term4 -> term5 .)
    break           reduce using rule 52 (term4 -> term5 .)
    def             reduce using rule 52 (term4 -> term5 .)
    if              reduce using rule 52 (term4 -> term5 .)
    while           reduce using rule 52 (term4 -> term5 .)
    until           reduce using rule 52 (term4 -> term5 .)
    case            reduce using rule 52 (term4 -> term5 .)
    for             reduce using rule 52 (term4 -> term5 .)
    return          reduce using rule 52 (term4 -> term5 .)
    IDENTIFIER      reduce using rule 52 (term4 -> term5 .)
    nil             reduce using rule 52 (term4 -> term5 .)
    self            reduce using rule 52 (term4 -> term5 .)
    GLOBAL          reduce using rule 52 (term4 -> term5 .)
    AT_THE_RATE     reduce using rule 52 (term4 -> term5 .)
    MINUS           reduce using rule 52 (term4 -> term5 .)
    PLUS            reduce using rule 52 (term4 -> term5 .)
    OPEN_BRACKET    reduce using rule 52 (term4 -> term5 .)
    Array           reduce using rule 52 (term4 -> term5 .)
    NUMBER          reduce using rule 52 (term4 -> term5 .)
    FLOAT           reduce using rule 52 (term4 -> term5 .)
    STRING          reduce using rule 52 (term4 -> term5 .)
    true            reduce using rule 52 (term4 -> term5 .)
    false           reduce using rule 52 (term4 -> term5 .)
    $end            reduce using rule 52 (term4 -> term5 .)
    CLOSE_BRACKET   reduce using rule 52 (term4 -> term5 .)
    then            reduce using rule 52 (term4 -> term5 .)
    do              reduce using rule 52 (term4 -> term5 .)
    LESS            shift and go to state 108
    LESS_EQUALS     shift and go to state 109
    GREATER         shift and go to state 110
    GREATER_EQUALS  shift and go to state 111


state 45

    (136) varname -> GLOBAL .

    OPEN_SQUARE     reduce using rule 136 (varname -> GLOBAL .)
    MULTIPLY        reduce using rule 136 (varname -> GLOBAL .)
    DIVIDE          reduce using rule 136 (varname -> GLOBAL .)
    MODULO          reduce using rule 136 (varname -> GLOBAL .)
    PLUS            reduce using rule 136 (varname -> GLOBAL .)
    MINUS           reduce using rule 136 (varname -> GLOBAL .)
    LEFT_SHIFT      reduce using rule 136 (varname -> GLOBAL .)
    RIGHT_SHIFT     reduce using rule 136 (varname -> GLOBAL .)
    BIT_AND         reduce using rule 136 (varname -> GLOBAL .)
    BIT_XOR         reduce using rule 136 (varname -> GLOBAL .)
    BIT_OR          reduce using rule 136 (varname -> GLOBAL .)
    DOUBLE_EQUALS   reduce using rule 136 (varname -> GLOBAL .)
    NOT_EQUALS      reduce using rule 136 (varname -> GLOBAL .)
    EQUAL_TILDE     reduce using rule 136 (varname -> GLOBAL .)
    COMPARISON      reduce using rule 136 (varname -> GLOBAL .)
    LESS            reduce using rule 136 (varname -> GLOBAL .)
    LESS_EQUALS     reduce using rule 136 (varname -> GLOBAL .)
    GREATER         reduce using rule 136 (varname -> GLOBAL .)
    GREATER_EQUALS  reduce using rule 136 (varname -> GLOBAL .)
    INCL_RANGE      reduce using rule 136 (varname -> GLOBAL .)
    EXCL_RANGE      reduce using rule 136 (varname -> GLOBAL .)
    LOGICAL_OR      reduce using rule 136 (varname -> GLOBAL .)
    SEMI_COLON      reduce using rule 136 (varname -> GLOBAL .)
    NEWLINE         reduce using rule 136 (varname -> GLOBAL .)
    puts            reduce using rule 136 (varname -> GLOBAL .)
    print           reduce using rule 136 (varname -> GLOBAL .)
    gets            reduce using rule 136 (varname -> GLOBAL .)
    class           reduce using rule 136 (varname -> GLOBAL .)
    break           reduce using rule 136 (varname -> GLOBAL .)
    def             reduce using rule 136 (varname -> GLOBAL .)
    if              reduce using rule 136 (varname -> GLOBAL .)
    while           reduce using rule 136 (varname -> GLOBAL .)
    until           reduce using rule 136 (varname -> GLOBAL .)
    case            reduce using rule 136 (varname -> GLOBAL .)
    for             reduce using rule 136 (varname -> GLOBAL .)
    return          reduce using rule 136 (varname -> GLOBAL .)
    IDENTIFIER      reduce using rule 136 (varname -> GLOBAL .)
    nil             reduce using rule 136 (varname -> GLOBAL .)
    self            reduce using rule 136 (varname -> GLOBAL .)
    GLOBAL          reduce using rule 136 (varname -> GLOBAL .)
    AT_THE_RATE     reduce using rule 136 (varname -> GLOBAL .)
    OPEN_BRACKET    reduce using rule 136 (varname -> GLOBAL .)
    Array           reduce using rule 136 (varname -> GLOBAL .)
    NUMBER          reduce using rule 136 (varname -> GLOBAL .)
    FLOAT           reduce using rule 136 (varname -> GLOBAL .)
    STRING          reduce using rule 136 (varname -> GLOBAL .)
    true            reduce using rule 136 (varname -> GLOBAL .)
    false           reduce using rule 136 (varname -> GLOBAL .)
    $end            reduce using rule 136 (varname -> GLOBAL .)
    CLOSE_BRACKET   reduce using rule 136 (varname -> GLOBAL .)
    then            reduce using rule 136 (varname -> GLOBAL .)
    do              reduce using rule 136 (varname -> GLOBAL .)
    COMMA           reduce using rule 136 (varname -> GLOBAL .)
    CLOSE_SQUARE    reduce using rule 136 (varname -> GLOBAL .)


state 46

    (137) varname -> AT_THE_RATE . IDENTIFIER

    IDENTIFIER      shift and go to state 112


state 47

    (57) term5 -> term6 .
    (58) term6 -> term6 . BIT_XOR term7
    (59) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 57 (term5 -> term6 .)
    NOT_EQUALS      reduce using rule 57 (term5 -> term6 .)
    EQUAL_TILDE     reduce using rule 57 (term5 -> term6 .)
    COMPARISON      reduce using rule 57 (term5 -> term6 .)
    LESS            reduce using rule 57 (term5 -> term6 .)
    LESS_EQUALS     reduce using rule 57 (term5 -> term6 .)
    GREATER         reduce using rule 57 (term5 -> term6 .)
    GREATER_EQUALS  reduce using rule 57 (term5 -> term6 .)
    INCL_RANGE      reduce using rule 57 (term5 -> term6 .)
    EXCL_RANGE      reduce using rule 57 (term5 -> term6 .)
    LOGICAL_OR      reduce using rule 57 (term5 -> term6 .)
    SEMI_COLON      reduce using rule 57 (term5 -> term6 .)
    NEWLINE         reduce using rule 57 (term5 -> term6 .)
    puts            reduce using rule 57 (term5 -> term6 .)
    print           reduce using rule 57 (term5 -> term6 .)
    gets            reduce using rule 57 (term5 -> term6 .)
    class           reduce using rule 57 (term5 -> term6 .)
    break           reduce using rule 57 (term5 -> term6 .)
    def             reduce using rule 57 (term5 -> term6 .)
    if              reduce using rule 57 (term5 -> term6 .)
    while           reduce using rule 57 (term5 -> term6 .)
    until           reduce using rule 57 (term5 -> term6 .)
    case            reduce using rule 57 (term5 -> term6 .)
    for             reduce using rule 57 (term5 -> term6 .)
    return          reduce using rule 57 (term5 -> term6 .)
    IDENTIFIER      reduce using rule 57 (term5 -> term6 .)
    nil             reduce using rule 57 (term5 -> term6 .)
    self            reduce using rule 57 (term5 -> term6 .)
    GLOBAL          reduce using rule 57 (term5 -> term6 .)
    AT_THE_RATE     reduce using rule 57 (term5 -> term6 .)
    MINUS           reduce using rule 57 (term5 -> term6 .)
    PLUS            reduce using rule 57 (term5 -> term6 .)
    OPEN_BRACKET    reduce using rule 57 (term5 -> term6 .)
    Array           reduce using rule 57 (term5 -> term6 .)
    NUMBER          reduce using rule 57 (term5 -> term6 .)
    FLOAT           reduce using rule 57 (term5 -> term6 .)
    STRING          reduce using rule 57 (term5 -> term6 .)
    true            reduce using rule 57 (term5 -> term6 .)
    false           reduce using rule 57 (term5 -> term6 .)
    $end            reduce using rule 57 (term5 -> term6 .)
    CLOSE_BRACKET   reduce using rule 57 (term5 -> term6 .)
    then            reduce using rule 57 (term5 -> term6 .)
    do              reduce using rule 57 (term5 -> term6 .)
    BIT_XOR         shift and go to state 113
    BIT_OR          shift and go to state 114


state 48

    (60) term6 -> term7 .
    (61) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 60 (term6 -> term7 .)
    BIT_OR          reduce using rule 60 (term6 -> term7 .)
    DOUBLE_EQUALS   reduce using rule 60 (term6 -> term7 .)
    NOT_EQUALS      reduce using rule 60 (term6 -> term7 .)
    EQUAL_TILDE     reduce using rule 60 (term6 -> term7 .)
    COMPARISON      reduce using rule 60 (term6 -> term7 .)
    LESS            reduce using rule 60 (term6 -> term7 .)
    LESS_EQUALS     reduce using rule 60 (term6 -> term7 .)
    GREATER         reduce using rule 60 (term6 -> term7 .)
    GREATER_EQUALS  reduce using rule 60 (term6 -> term7 .)
    INCL_RANGE      reduce using rule 60 (term6 -> term7 .)
    EXCL_RANGE      reduce using rule 60 (term6 -> term7 .)
    LOGICAL_OR      reduce using rule 60 (term6 -> term7 .)
    SEMI_COLON      reduce using rule 60 (term6 -> term7 .)
    NEWLINE         reduce using rule 60 (term6 -> term7 .)
    puts            reduce using rule 60 (term6 -> term7 .)
    print           reduce using rule 60 (term6 -> term7 .)
    gets            reduce using rule 60 (term6 -> term7 .)
    class           reduce using rule 60 (term6 -> term7 .)
    break           reduce using rule 60 (term6 -> term7 .)
    def             reduce using rule 60 (term6 -> term7 .)
    if              reduce using rule 60 (term6 -> term7 .)
    while           reduce using rule 60 (term6 -> term7 .)
    until           reduce using rule 60 (term6 -> term7 .)
    case            reduce using rule 60 (term6 -> term7 .)
    for             reduce using rule 60 (term6 -> term7 .)
    return          reduce using rule 60 (term6 -> term7 .)
    IDENTIFIER      reduce using rule 60 (term6 -> term7 .)
    nil             reduce using rule 60 (term6 -> term7 .)
    self            reduce using rule 60 (term6 -> term7 .)
    GLOBAL          reduce using rule 60 (term6 -> term7 .)
    AT_THE_RATE     reduce using rule 60 (term6 -> term7 .)
    MINUS           reduce using rule 60 (term6 -> term7 .)
    PLUS            reduce using rule 60 (term6 -> term7 .)
    OPEN_BRACKET    reduce using rule 60 (term6 -> term7 .)
    Array           reduce using rule 60 (term6 -> term7 .)
    NUMBER          reduce using rule 60 (term6 -> term7 .)
    FLOAT           reduce using rule 60 (term6 -> term7 .)
    STRING          reduce using rule 60 (term6 -> term7 .)
    true            reduce using rule 60 (term6 -> term7 .)
    false           reduce using rule 60 (term6 -> term7 .)
    $end            reduce using rule 60 (term6 -> term7 .)
    CLOSE_BRACKET   reduce using rule 60 (term6 -> term7 .)
    then            reduce using rule 60 (term6 -> term7 .)
    do              reduce using rule 60 (term6 -> term7 .)
    BIT_AND         shift and go to state 115


state 49

    (62) term7 -> term8 .
    (63) term8 -> term8 . LEFT_SHIFT term9
    (64) term8 -> term8 . RIGHT_SHIFT term9

    BIT_AND         reduce using rule 62 (term7 -> term8 .)
    BIT_XOR         reduce using rule 62 (term7 -> term8 .)
    BIT_OR          reduce using rule 62 (term7 -> term8 .)
    DOUBLE_EQUALS   reduce using rule 62 (term7 -> term8 .)
    NOT_EQUALS      reduce using rule 62 (term7 -> term8 .)
    EQUAL_TILDE     reduce using rule 62 (term7 -> term8 .)
    COMPARISON      reduce using rule 62 (term7 -> term8 .)
    LESS            reduce using rule 62 (term7 -> term8 .)
    LESS_EQUALS     reduce using rule 62 (term7 -> term8 .)
    GREATER         reduce using rule 62 (term7 -> term8 .)
    GREATER_EQUALS  reduce using rule 62 (term7 -> term8 .)
    INCL_RANGE      reduce using rule 62 (term7 -> term8 .)
    EXCL_RANGE      reduce using rule 62 (term7 -> term8 .)
    LOGICAL_OR      reduce using rule 62 (term7 -> term8 .)
    SEMI_COLON      reduce using rule 62 (term7 -> term8 .)
    NEWLINE         reduce using rule 62 (term7 -> term8 .)
    puts            reduce using rule 62 (term7 -> term8 .)
    print           reduce using rule 62 (term7 -> term8 .)
    gets            reduce using rule 62 (term7 -> term8 .)
    class           reduce using rule 62 (term7 -> term8 .)
    break           reduce using rule 62 (term7 -> term8 .)
    def             reduce using rule 62 (term7 -> term8 .)
    if              reduce using rule 62 (term7 -> term8 .)
    while           reduce using rule 62 (term7 -> term8 .)
    until           reduce using rule 62 (term7 -> term8 .)
    case            reduce using rule 62 (term7 -> term8 .)
    for             reduce using rule 62 (term7 -> term8 .)
    return          reduce using rule 62 (term7 -> term8 .)
    IDENTIFIER      reduce using rule 62 (term7 -> term8 .)
    nil             reduce using rule 62 (term7 -> term8 .)
    self            reduce using rule 62 (term7 -> term8 .)
    GLOBAL          reduce using rule 62 (term7 -> term8 .)
    AT_THE_RATE     reduce using rule 62 (term7 -> term8 .)
    MINUS           reduce using rule 62 (term7 -> term8 .)
    PLUS            reduce using rule 62 (term7 -> term8 .)
    OPEN_BRACKET    reduce using rule 62 (term7 -> term8 .)
    Array           reduce using rule 62 (term7 -> term8 .)
    NUMBER          reduce using rule 62 (term7 -> term8 .)
    FLOAT           reduce using rule 62 (term7 -> term8 .)
    STRING          reduce using rule 62 (term7 -> term8 .)
    true            reduce using rule 62 (term7 -> term8 .)
    false           reduce using rule 62 (term7 -> term8 .)
    $end            reduce using rule 62 (term7 -> term8 .)
    CLOSE_BRACKET   reduce using rule 62 (term7 -> term8 .)
    then            reduce using rule 62 (term7 -> term8 .)
    do              reduce using rule 62 (term7 -> term8 .)
    LEFT_SHIFT      shift and go to state 116
    RIGHT_SHIFT     shift and go to state 117


state 50

    (65) term8 -> term9 .
    (66) term9 -> term9 . PLUS term10
    (67) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 65 (term8 -> term9 .)
    RIGHT_SHIFT     reduce using rule 65 (term8 -> term9 .)
    BIT_AND         reduce using rule 65 (term8 -> term9 .)
    BIT_XOR         reduce using rule 65 (term8 -> term9 .)
    BIT_OR          reduce using rule 65 (term8 -> term9 .)
    DOUBLE_EQUALS   reduce using rule 65 (term8 -> term9 .)
    NOT_EQUALS      reduce using rule 65 (term8 -> term9 .)
    EQUAL_TILDE     reduce using rule 65 (term8 -> term9 .)
    COMPARISON      reduce using rule 65 (term8 -> term9 .)
    LESS            reduce using rule 65 (term8 -> term9 .)
    LESS_EQUALS     reduce using rule 65 (term8 -> term9 .)
    GREATER         reduce using rule 65 (term8 -> term9 .)
    GREATER_EQUALS  reduce using rule 65 (term8 -> term9 .)
    INCL_RANGE      reduce using rule 65 (term8 -> term9 .)
    EXCL_RANGE      reduce using rule 65 (term8 -> term9 .)
    LOGICAL_OR      reduce using rule 65 (term8 -> term9 .)
    SEMI_COLON      reduce using rule 65 (term8 -> term9 .)
    NEWLINE         reduce using rule 65 (term8 -> term9 .)
    puts            reduce using rule 65 (term8 -> term9 .)
    print           reduce using rule 65 (term8 -> term9 .)
    gets            reduce using rule 65 (term8 -> term9 .)
    class           reduce using rule 65 (term8 -> term9 .)
    break           reduce using rule 65 (term8 -> term9 .)
    def             reduce using rule 65 (term8 -> term9 .)
    if              reduce using rule 65 (term8 -> term9 .)
    while           reduce using rule 65 (term8 -> term9 .)
    until           reduce using rule 65 (term8 -> term9 .)
    case            reduce using rule 65 (term8 -> term9 .)
    for             reduce using rule 65 (term8 -> term9 .)
    return          reduce using rule 65 (term8 -> term9 .)
    IDENTIFIER      reduce using rule 65 (term8 -> term9 .)
    nil             reduce using rule 65 (term8 -> term9 .)
    self            reduce using rule 65 (term8 -> term9 .)
    GLOBAL          reduce using rule 65 (term8 -> term9 .)
    AT_THE_RATE     reduce using rule 65 (term8 -> term9 .)
    OPEN_BRACKET    reduce using rule 65 (term8 -> term9 .)
    Array           reduce using rule 65 (term8 -> term9 .)
    NUMBER          reduce using rule 65 (term8 -> term9 .)
    FLOAT           reduce using rule 65 (term8 -> term9 .)
    STRING          reduce using rule 65 (term8 -> term9 .)
    true            reduce using rule 65 (term8 -> term9 .)
    false           reduce using rule 65 (term8 -> term9 .)
    $end            reduce using rule 65 (term8 -> term9 .)
    CLOSE_BRACKET   reduce using rule 65 (term8 -> term9 .)
    then            reduce using rule 65 (term8 -> term9 .)
    do              reduce using rule 65 (term8 -> term9 .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119

  ! MINUS           [ reduce using rule 65 (term8 -> term9 .) ]
  ! PLUS            [ reduce using rule 65 (term8 -> term9 .) ]


state 51

    (75) term12 -> PLUS . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term12                         shift and go to state 120
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 52

    (68) term9 -> term10 .
    (69) term10 -> term10 . MULTIPLY term11
    (70) term10 -> term10 . DIVIDE term11
    (71) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 68 (term9 -> term10 .)
    MINUS           reduce using rule 68 (term9 -> term10 .)
    LEFT_SHIFT      reduce using rule 68 (term9 -> term10 .)
    RIGHT_SHIFT     reduce using rule 68 (term9 -> term10 .)
    BIT_AND         reduce using rule 68 (term9 -> term10 .)
    BIT_XOR         reduce using rule 68 (term9 -> term10 .)
    BIT_OR          reduce using rule 68 (term9 -> term10 .)
    DOUBLE_EQUALS   reduce using rule 68 (term9 -> term10 .)
    NOT_EQUALS      reduce using rule 68 (term9 -> term10 .)
    EQUAL_TILDE     reduce using rule 68 (term9 -> term10 .)
    COMPARISON      reduce using rule 68 (term9 -> term10 .)
    LESS            reduce using rule 68 (term9 -> term10 .)
    LESS_EQUALS     reduce using rule 68 (term9 -> term10 .)
    GREATER         reduce using rule 68 (term9 -> term10 .)
    GREATER_EQUALS  reduce using rule 68 (term9 -> term10 .)
    INCL_RANGE      reduce using rule 68 (term9 -> term10 .)
    EXCL_RANGE      reduce using rule 68 (term9 -> term10 .)
    LOGICAL_OR      reduce using rule 68 (term9 -> term10 .)
    SEMI_COLON      reduce using rule 68 (term9 -> term10 .)
    NEWLINE         reduce using rule 68 (term9 -> term10 .)
    puts            reduce using rule 68 (term9 -> term10 .)
    print           reduce using rule 68 (term9 -> term10 .)
    gets            reduce using rule 68 (term9 -> term10 .)
    class           reduce using rule 68 (term9 -> term10 .)
    break           reduce using rule 68 (term9 -> term10 .)
    def             reduce using rule 68 (term9 -> term10 .)
    if              reduce using rule 68 (term9 -> term10 .)
    while           reduce using rule 68 (term9 -> term10 .)
    until           reduce using rule 68 (term9 -> term10 .)
    case            reduce using rule 68 (term9 -> term10 .)
    for             reduce using rule 68 (term9 -> term10 .)
    return          reduce using rule 68 (term9 -> term10 .)
    IDENTIFIER      reduce using rule 68 (term9 -> term10 .)
    nil             reduce using rule 68 (term9 -> term10 .)
    self            reduce using rule 68 (term9 -> term10 .)
    GLOBAL          reduce using rule 68 (term9 -> term10 .)
    AT_THE_RATE     reduce using rule 68 (term9 -> term10 .)
    OPEN_BRACKET    reduce using rule 68 (term9 -> term10 .)
    Array           reduce using rule 68 (term9 -> term10 .)
    NUMBER          reduce using rule 68 (term9 -> term10 .)
    FLOAT           reduce using rule 68 (term9 -> term10 .)
    STRING          reduce using rule 68 (term9 -> term10 .)
    true            reduce using rule 68 (term9 -> term10 .)
    false           reduce using rule 68 (term9 -> term10 .)
    $end            reduce using rule 68 (term9 -> term10 .)
    CLOSE_BRACKET   reduce using rule 68 (term9 -> term10 .)
    then            reduce using rule 68 (term9 -> term10 .)
    do              reduce using rule 68 (term9 -> term10 .)
    MULTIPLY        shift and go to state 121
    DIVIDE          shift and go to state 122
    MODULO          shift and go to state 123


state 53

    (73) term11 -> MINUS . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term11                         shift and go to state 124
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 54

    (72) term10 -> term11 .

    MULTIPLY        reduce using rule 72 (term10 -> term11 .)
    DIVIDE          reduce using rule 72 (term10 -> term11 .)
    MODULO          reduce using rule 72 (term10 -> term11 .)
    PLUS            reduce using rule 72 (term10 -> term11 .)
    MINUS           reduce using rule 72 (term10 -> term11 .)
    LEFT_SHIFT      reduce using rule 72 (term10 -> term11 .)
    RIGHT_SHIFT     reduce using rule 72 (term10 -> term11 .)
    BIT_AND         reduce using rule 72 (term10 -> term11 .)
    BIT_XOR         reduce using rule 72 (term10 -> term11 .)
    BIT_OR          reduce using rule 72 (term10 -> term11 .)
    DOUBLE_EQUALS   reduce using rule 72 (term10 -> term11 .)
    NOT_EQUALS      reduce using rule 72 (term10 -> term11 .)
    EQUAL_TILDE     reduce using rule 72 (term10 -> term11 .)
    COMPARISON      reduce using rule 72 (term10 -> term11 .)
    LESS            reduce using rule 72 (term10 -> term11 .)
    LESS_EQUALS     reduce using rule 72 (term10 -> term11 .)
    GREATER         reduce using rule 72 (term10 -> term11 .)
    GREATER_EQUALS  reduce using rule 72 (term10 -> term11 .)
    INCL_RANGE      reduce using rule 72 (term10 -> term11 .)
    EXCL_RANGE      reduce using rule 72 (term10 -> term11 .)
    LOGICAL_OR      reduce using rule 72 (term10 -> term11 .)
    SEMI_COLON      reduce using rule 72 (term10 -> term11 .)
    NEWLINE         reduce using rule 72 (term10 -> term11 .)
    puts            reduce using rule 72 (term10 -> term11 .)
    print           reduce using rule 72 (term10 -> term11 .)
    gets            reduce using rule 72 (term10 -> term11 .)
    class           reduce using rule 72 (term10 -> term11 .)
    break           reduce using rule 72 (term10 -> term11 .)
    def             reduce using rule 72 (term10 -> term11 .)
    if              reduce using rule 72 (term10 -> term11 .)
    while           reduce using rule 72 (term10 -> term11 .)
    until           reduce using rule 72 (term10 -> term11 .)
    case            reduce using rule 72 (term10 -> term11 .)
    for             reduce using rule 72 (term10 -> term11 .)
    return          reduce using rule 72 (term10 -> term11 .)
    IDENTIFIER      reduce using rule 72 (term10 -> term11 .)
    nil             reduce using rule 72 (term10 -> term11 .)
    self            reduce using rule 72 (term10 -> term11 .)
    GLOBAL          reduce using rule 72 (term10 -> term11 .)
    AT_THE_RATE     reduce using rule 72 (term10 -> term11 .)
    OPEN_BRACKET    reduce using rule 72 (term10 -> term11 .)
    Array           reduce using rule 72 (term10 -> term11 .)
    NUMBER          reduce using rule 72 (term10 -> term11 .)
    FLOAT           reduce using rule 72 (term10 -> term11 .)
    STRING          reduce using rule 72 (term10 -> term11 .)
    true            reduce using rule 72 (term10 -> term11 .)
    false           reduce using rule 72 (term10 -> term11 .)
    $end            reduce using rule 72 (term10 -> term11 .)
    CLOSE_BRACKET   reduce using rule 72 (term10 -> term11 .)
    then            reduce using rule 72 (term10 -> term11 .)
    do              reduce using rule 72 (term10 -> term11 .)


state 55

    (74) term11 -> term12 .

    MULTIPLY        reduce using rule 74 (term11 -> term12 .)
    DIVIDE          reduce using rule 74 (term11 -> term12 .)
    MODULO          reduce using rule 74 (term11 -> term12 .)
    PLUS            reduce using rule 74 (term11 -> term12 .)
    MINUS           reduce using rule 74 (term11 -> term12 .)
    LEFT_SHIFT      reduce using rule 74 (term11 -> term12 .)
    RIGHT_SHIFT     reduce using rule 74 (term11 -> term12 .)
    BIT_AND         reduce using rule 74 (term11 -> term12 .)
    BIT_XOR         reduce using rule 74 (term11 -> term12 .)
    BIT_OR          reduce using rule 74 (term11 -> term12 .)
    DOUBLE_EQUALS   reduce using rule 74 (term11 -> term12 .)
    NOT_EQUALS      reduce using rule 74 (term11 -> term12 .)
    EQUAL_TILDE     reduce using rule 74 (term11 -> term12 .)
    COMPARISON      reduce using rule 74 (term11 -> term12 .)
    LESS            reduce using rule 74 (term11 -> term12 .)
    LESS_EQUALS     reduce using rule 74 (term11 -> term12 .)
    GREATER         reduce using rule 74 (term11 -> term12 .)
    GREATER_EQUALS  reduce using rule 74 (term11 -> term12 .)
    INCL_RANGE      reduce using rule 74 (term11 -> term12 .)
    EXCL_RANGE      reduce using rule 74 (term11 -> term12 .)
    LOGICAL_OR      reduce using rule 74 (term11 -> term12 .)
    SEMI_COLON      reduce using rule 74 (term11 -> term12 .)
    NEWLINE         reduce using rule 74 (term11 -> term12 .)
    puts            reduce using rule 74 (term11 -> term12 .)
    print           reduce using rule 74 (term11 -> term12 .)
    gets            reduce using rule 74 (term11 -> term12 .)
    class           reduce using rule 74 (term11 -> term12 .)
    break           reduce using rule 74 (term11 -> term12 .)
    def             reduce using rule 74 (term11 -> term12 .)
    if              reduce using rule 74 (term11 -> term12 .)
    while           reduce using rule 74 (term11 -> term12 .)
    until           reduce using rule 74 (term11 -> term12 .)
    case            reduce using rule 74 (term11 -> term12 .)
    for             reduce using rule 74 (term11 -> term12 .)
    return          reduce using rule 74 (term11 -> term12 .)
    IDENTIFIER      reduce using rule 74 (term11 -> term12 .)
    nil             reduce using rule 74 (term11 -> term12 .)
    self            reduce using rule 74 (term11 -> term12 .)
    GLOBAL          reduce using rule 74 (term11 -> term12 .)
    AT_THE_RATE     reduce using rule 74 (term11 -> term12 .)
    OPEN_BRACKET    reduce using rule 74 (term11 -> term12 .)
    Array           reduce using rule 74 (term11 -> term12 .)
    NUMBER          reduce using rule 74 (term11 -> term12 .)
    FLOAT           reduce using rule 74 (term11 -> term12 .)
    STRING          reduce using rule 74 (term11 -> term12 .)
    true            reduce using rule 74 (term11 -> term12 .)
    false           reduce using rule 74 (term11 -> term12 .)
    $end            reduce using rule 74 (term11 -> term12 .)
    CLOSE_BRACKET   reduce using rule 74 (term11 -> term12 .)
    then            reduce using rule 74 (term11 -> term12 .)
    do              reduce using rule 74 (term11 -> term12 .)


state 56

    (76) term12 -> term13 .

    MULTIPLY        reduce using rule 76 (term12 -> term13 .)
    DIVIDE          reduce using rule 76 (term12 -> term13 .)
    MODULO          reduce using rule 76 (term12 -> term13 .)
    PLUS            reduce using rule 76 (term12 -> term13 .)
    MINUS           reduce using rule 76 (term12 -> term13 .)
    LEFT_SHIFT      reduce using rule 76 (term12 -> term13 .)
    RIGHT_SHIFT     reduce using rule 76 (term12 -> term13 .)
    BIT_AND         reduce using rule 76 (term12 -> term13 .)
    BIT_XOR         reduce using rule 76 (term12 -> term13 .)
    BIT_OR          reduce using rule 76 (term12 -> term13 .)
    DOUBLE_EQUALS   reduce using rule 76 (term12 -> term13 .)
    NOT_EQUALS      reduce using rule 76 (term12 -> term13 .)
    EQUAL_TILDE     reduce using rule 76 (term12 -> term13 .)
    COMPARISON      reduce using rule 76 (term12 -> term13 .)
    LESS            reduce using rule 76 (term12 -> term13 .)
    LESS_EQUALS     reduce using rule 76 (term12 -> term13 .)
    GREATER         reduce using rule 76 (term12 -> term13 .)
    GREATER_EQUALS  reduce using rule 76 (term12 -> term13 .)
    INCL_RANGE      reduce using rule 76 (term12 -> term13 .)
    EXCL_RANGE      reduce using rule 76 (term12 -> term13 .)
    LOGICAL_OR      reduce using rule 76 (term12 -> term13 .)
    SEMI_COLON      reduce using rule 76 (term12 -> term13 .)
    NEWLINE         reduce using rule 76 (term12 -> term13 .)
    puts            reduce using rule 76 (term12 -> term13 .)
    print           reduce using rule 76 (term12 -> term13 .)
    gets            reduce using rule 76 (term12 -> term13 .)
    class           reduce using rule 76 (term12 -> term13 .)
    break           reduce using rule 76 (term12 -> term13 .)
    def             reduce using rule 76 (term12 -> term13 .)
    if              reduce using rule 76 (term12 -> term13 .)
    while           reduce using rule 76 (term12 -> term13 .)
    until           reduce using rule 76 (term12 -> term13 .)
    case            reduce using rule 76 (term12 -> term13 .)
    for             reduce using rule 76 (term12 -> term13 .)
    return          reduce using rule 76 (term12 -> term13 .)
    IDENTIFIER      reduce using rule 76 (term12 -> term13 .)
    nil             reduce using rule 76 (term12 -> term13 .)
    self            reduce using rule 76 (term12 -> term13 .)
    GLOBAL          reduce using rule 76 (term12 -> term13 .)
    AT_THE_RATE     reduce using rule 76 (term12 -> term13 .)
    OPEN_BRACKET    reduce using rule 76 (term12 -> term13 .)
    Array           reduce using rule 76 (term12 -> term13 .)
    NUMBER          reduce using rule 76 (term12 -> term13 .)
    FLOAT           reduce using rule 76 (term12 -> term13 .)
    STRING          reduce using rule 76 (term12 -> term13 .)
    true            reduce using rule 76 (term12 -> term13 .)
    false           reduce using rule 76 (term12 -> term13 .)
    $end            reduce using rule 76 (term12 -> term13 .)
    CLOSE_BRACKET   reduce using rule 76 (term12 -> term13 .)
    then            reduce using rule 76 (term12 -> term13 .)
    do              reduce using rule 76 (term12 -> term13 .)


state 57

    (79) primary -> arrayd .

    MULTIPLY        reduce using rule 79 (primary -> arrayd .)
    DIVIDE          reduce using rule 79 (primary -> arrayd .)
    MODULO          reduce using rule 79 (primary -> arrayd .)
    PLUS            reduce using rule 79 (primary -> arrayd .)
    MINUS           reduce using rule 79 (primary -> arrayd .)
    LEFT_SHIFT      reduce using rule 79 (primary -> arrayd .)
    RIGHT_SHIFT     reduce using rule 79 (primary -> arrayd .)
    BIT_AND         reduce using rule 79 (primary -> arrayd .)
    BIT_XOR         reduce using rule 79 (primary -> arrayd .)
    BIT_OR          reduce using rule 79 (primary -> arrayd .)
    DOUBLE_EQUALS   reduce using rule 79 (primary -> arrayd .)
    NOT_EQUALS      reduce using rule 79 (primary -> arrayd .)
    EQUAL_TILDE     reduce using rule 79 (primary -> arrayd .)
    COMPARISON      reduce using rule 79 (primary -> arrayd .)
    LESS            reduce using rule 79 (primary -> arrayd .)
    LESS_EQUALS     reduce using rule 79 (primary -> arrayd .)
    GREATER         reduce using rule 79 (primary -> arrayd .)
    GREATER_EQUALS  reduce using rule 79 (primary -> arrayd .)
    INCL_RANGE      reduce using rule 79 (primary -> arrayd .)
    EXCL_RANGE      reduce using rule 79 (primary -> arrayd .)
    LOGICAL_OR      reduce using rule 79 (primary -> arrayd .)
    SEMI_COLON      reduce using rule 79 (primary -> arrayd .)
    NEWLINE         reduce using rule 79 (primary -> arrayd .)
    puts            reduce using rule 79 (primary -> arrayd .)
    print           reduce using rule 79 (primary -> arrayd .)
    gets            reduce using rule 79 (primary -> arrayd .)
    class           reduce using rule 79 (primary -> arrayd .)
    break           reduce using rule 79 (primary -> arrayd .)
    def             reduce using rule 79 (primary -> arrayd .)
    if              reduce using rule 79 (primary -> arrayd .)
    while           reduce using rule 79 (primary -> arrayd .)
    until           reduce using rule 79 (primary -> arrayd .)
    case            reduce using rule 79 (primary -> arrayd .)
    for             reduce using rule 79 (primary -> arrayd .)
    return          reduce using rule 79 (primary -> arrayd .)
    IDENTIFIER      reduce using rule 79 (primary -> arrayd .)
    nil             reduce using rule 79 (primary -> arrayd .)
    self            reduce using rule 79 (primary -> arrayd .)
    GLOBAL          reduce using rule 79 (primary -> arrayd .)
    AT_THE_RATE     reduce using rule 79 (primary -> arrayd .)
    OPEN_BRACKET    reduce using rule 79 (primary -> arrayd .)
    Array           reduce using rule 79 (primary -> arrayd .)
    NUMBER          reduce using rule 79 (primary -> arrayd .)
    FLOAT           reduce using rule 79 (primary -> arrayd .)
    STRING          reduce using rule 79 (primary -> arrayd .)
    true            reduce using rule 79 (primary -> arrayd .)
    false           reduce using rule 79 (primary -> arrayd .)
    $end            reduce using rule 79 (primary -> arrayd .)
    CLOSE_BRACKET   reduce using rule 79 (primary -> arrayd .)
    then            reduce using rule 79 (primary -> arrayd .)
    do              reduce using rule 79 (primary -> arrayd .)
    COMMA           reduce using rule 79 (primary -> arrayd .)
    CLOSE_SQUARE    reduce using rule 79 (primary -> arrayd .)


state 58

    (80) primary -> arraya .

    MULTIPLY        reduce using rule 80 (primary -> arraya .)
    DIVIDE          reduce using rule 80 (primary -> arraya .)
    MODULO          reduce using rule 80 (primary -> arraya .)
    PLUS            reduce using rule 80 (primary -> arraya .)
    MINUS           reduce using rule 80 (primary -> arraya .)
    LEFT_SHIFT      reduce using rule 80 (primary -> arraya .)
    RIGHT_SHIFT     reduce using rule 80 (primary -> arraya .)
    BIT_AND         reduce using rule 80 (primary -> arraya .)
    BIT_XOR         reduce using rule 80 (primary -> arraya .)
    BIT_OR          reduce using rule 80 (primary -> arraya .)
    DOUBLE_EQUALS   reduce using rule 80 (primary -> arraya .)
    NOT_EQUALS      reduce using rule 80 (primary -> arraya .)
    EQUAL_TILDE     reduce using rule 80 (primary -> arraya .)
    COMPARISON      reduce using rule 80 (primary -> arraya .)
    LESS            reduce using rule 80 (primary -> arraya .)
    LESS_EQUALS     reduce using rule 80 (primary -> arraya .)
    GREATER         reduce using rule 80 (primary -> arraya .)
    GREATER_EQUALS  reduce using rule 80 (primary -> arraya .)
    INCL_RANGE      reduce using rule 80 (primary -> arraya .)
    EXCL_RANGE      reduce using rule 80 (primary -> arraya .)
    LOGICAL_OR      reduce using rule 80 (primary -> arraya .)
    SEMI_COLON      reduce using rule 80 (primary -> arraya .)
    NEWLINE         reduce using rule 80 (primary -> arraya .)
    puts            reduce using rule 80 (primary -> arraya .)
    print           reduce using rule 80 (primary -> arraya .)
    gets            reduce using rule 80 (primary -> arraya .)
    class           reduce using rule 80 (primary -> arraya .)
    break           reduce using rule 80 (primary -> arraya .)
    def             reduce using rule 80 (primary -> arraya .)
    if              reduce using rule 80 (primary -> arraya .)
    while           reduce using rule 80 (primary -> arraya .)
    until           reduce using rule 80 (primary -> arraya .)
    case            reduce using rule 80 (primary -> arraya .)
    for             reduce using rule 80 (primary -> arraya .)
    return          reduce using rule 80 (primary -> arraya .)
    IDENTIFIER      reduce using rule 80 (primary -> arraya .)
    nil             reduce using rule 80 (primary -> arraya .)
    self            reduce using rule 80 (primary -> arraya .)
    GLOBAL          reduce using rule 80 (primary -> arraya .)
    AT_THE_RATE     reduce using rule 80 (primary -> arraya .)
    OPEN_BRACKET    reduce using rule 80 (primary -> arraya .)
    Array           reduce using rule 80 (primary -> arraya .)
    NUMBER          reduce using rule 80 (primary -> arraya .)
    FLOAT           reduce using rule 80 (primary -> arraya .)
    STRING          reduce using rule 80 (primary -> arraya .)
    true            reduce using rule 80 (primary -> arraya .)
    false           reduce using rule 80 (primary -> arraya .)
    $end            reduce using rule 80 (primary -> arraya .)
    CLOSE_BRACKET   reduce using rule 80 (primary -> arraya .)
    then            reduce using rule 80 (primary -> arraya .)
    do              reduce using rule 80 (primary -> arraya .)
    COMMA           reduce using rule 80 (primary -> arraya .)
    CLOSE_SQUARE    reduce using rule 80 (primary -> arraya .)


state 59

    (81) primary -> literal .

    MULTIPLY        reduce using rule 81 (primary -> literal .)
    DIVIDE          reduce using rule 81 (primary -> literal .)
    MODULO          reduce using rule 81 (primary -> literal .)
    PLUS            reduce using rule 81 (primary -> literal .)
    MINUS           reduce using rule 81 (primary -> literal .)
    LEFT_SHIFT      reduce using rule 81 (primary -> literal .)
    RIGHT_SHIFT     reduce using rule 81 (primary -> literal .)
    BIT_AND         reduce using rule 81 (primary -> literal .)
    BIT_XOR         reduce using rule 81 (primary -> literal .)
    BIT_OR          reduce using rule 81 (primary -> literal .)
    DOUBLE_EQUALS   reduce using rule 81 (primary -> literal .)
    NOT_EQUALS      reduce using rule 81 (primary -> literal .)
    EQUAL_TILDE     reduce using rule 81 (primary -> literal .)
    COMPARISON      reduce using rule 81 (primary -> literal .)
    LESS            reduce using rule 81 (primary -> literal .)
    LESS_EQUALS     reduce using rule 81 (primary -> literal .)
    GREATER         reduce using rule 81 (primary -> literal .)
    GREATER_EQUALS  reduce using rule 81 (primary -> literal .)
    INCL_RANGE      reduce using rule 81 (primary -> literal .)
    EXCL_RANGE      reduce using rule 81 (primary -> literal .)
    LOGICAL_OR      reduce using rule 81 (primary -> literal .)
    SEMI_COLON      reduce using rule 81 (primary -> literal .)
    NEWLINE         reduce using rule 81 (primary -> literal .)
    puts            reduce using rule 81 (primary -> literal .)
    print           reduce using rule 81 (primary -> literal .)
    gets            reduce using rule 81 (primary -> literal .)
    class           reduce using rule 81 (primary -> literal .)
    break           reduce using rule 81 (primary -> literal .)
    def             reduce using rule 81 (primary -> literal .)
    if              reduce using rule 81 (primary -> literal .)
    while           reduce using rule 81 (primary -> literal .)
    until           reduce using rule 81 (primary -> literal .)
    case            reduce using rule 81 (primary -> literal .)
    for             reduce using rule 81 (primary -> literal .)
    return          reduce using rule 81 (primary -> literal .)
    IDENTIFIER      reduce using rule 81 (primary -> literal .)
    nil             reduce using rule 81 (primary -> literal .)
    self            reduce using rule 81 (primary -> literal .)
    GLOBAL          reduce using rule 81 (primary -> literal .)
    AT_THE_RATE     reduce using rule 81 (primary -> literal .)
    OPEN_BRACKET    reduce using rule 81 (primary -> literal .)
    Array           reduce using rule 81 (primary -> literal .)
    NUMBER          reduce using rule 81 (primary -> literal .)
    FLOAT           reduce using rule 81 (primary -> literal .)
    STRING          reduce using rule 81 (primary -> literal .)
    true            reduce using rule 81 (primary -> literal .)
    false           reduce using rule 81 (primary -> literal .)
    $end            reduce using rule 81 (primary -> literal .)
    CLOSE_BRACKET   reduce using rule 81 (primary -> literal .)
    then            reduce using rule 81 (primary -> literal .)
    do              reduce using rule 81 (primary -> literal .)
    COMMA           reduce using rule 81 (primary -> literal .)
    CLOSE_SQUARE    reduce using rule 81 (primary -> literal .)


state 60

    (83) arrayd -> Array . OPEN_BRACKET array_size CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 125


state 61

    (95) literal -> NUMBER .

    MULTIPLY        reduce using rule 95 (literal -> NUMBER .)
    DIVIDE          reduce using rule 95 (literal -> NUMBER .)
    MODULO          reduce using rule 95 (literal -> NUMBER .)
    PLUS            reduce using rule 95 (literal -> NUMBER .)
    MINUS           reduce using rule 95 (literal -> NUMBER .)
    LEFT_SHIFT      reduce using rule 95 (literal -> NUMBER .)
    RIGHT_SHIFT     reduce using rule 95 (literal -> NUMBER .)
    BIT_AND         reduce using rule 95 (literal -> NUMBER .)
    BIT_XOR         reduce using rule 95 (literal -> NUMBER .)
    BIT_OR          reduce using rule 95 (literal -> NUMBER .)
    DOUBLE_EQUALS   reduce using rule 95 (literal -> NUMBER .)
    NOT_EQUALS      reduce using rule 95 (literal -> NUMBER .)
    EQUAL_TILDE     reduce using rule 95 (literal -> NUMBER .)
    COMPARISON      reduce using rule 95 (literal -> NUMBER .)
    LESS            reduce using rule 95 (literal -> NUMBER .)
    LESS_EQUALS     reduce using rule 95 (literal -> NUMBER .)
    GREATER         reduce using rule 95 (literal -> NUMBER .)
    GREATER_EQUALS  reduce using rule 95 (literal -> NUMBER .)
    INCL_RANGE      reduce using rule 95 (literal -> NUMBER .)
    EXCL_RANGE      reduce using rule 95 (literal -> NUMBER .)
    LOGICAL_OR      reduce using rule 95 (literal -> NUMBER .)
    SEMI_COLON      reduce using rule 95 (literal -> NUMBER .)
    NEWLINE         reduce using rule 95 (literal -> NUMBER .)
    puts            reduce using rule 95 (literal -> NUMBER .)
    print           reduce using rule 95 (literal -> NUMBER .)
    gets            reduce using rule 95 (literal -> NUMBER .)
    class           reduce using rule 95 (literal -> NUMBER .)
    break           reduce using rule 95 (literal -> NUMBER .)
    def             reduce using rule 95 (literal -> NUMBER .)
    if              reduce using rule 95 (literal -> NUMBER .)
    while           reduce using rule 95 (literal -> NUMBER .)
    until           reduce using rule 95 (literal -> NUMBER .)
    case            reduce using rule 95 (literal -> NUMBER .)
    for             reduce using rule 95 (literal -> NUMBER .)
    return          reduce using rule 95 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 95 (literal -> NUMBER .)
    nil             reduce using rule 95 (literal -> NUMBER .)
    self            reduce using rule 95 (literal -> NUMBER .)
    GLOBAL          reduce using rule 95 (literal -> NUMBER .)
    AT_THE_RATE     reduce using rule 95 (literal -> NUMBER .)
    OPEN_BRACKET    reduce using rule 95 (literal -> NUMBER .)
    Array           reduce using rule 95 (literal -> NUMBER .)
    NUMBER          reduce using rule 95 (literal -> NUMBER .)
    FLOAT           reduce using rule 95 (literal -> NUMBER .)
    STRING          reduce using rule 95 (literal -> NUMBER .)
    true            reduce using rule 95 (literal -> NUMBER .)
    false           reduce using rule 95 (literal -> NUMBER .)
    $end            reduce using rule 95 (literal -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 95 (literal -> NUMBER .)
    then            reduce using rule 95 (literal -> NUMBER .)
    do              reduce using rule 95 (literal -> NUMBER .)
    COMMA           reduce using rule 95 (literal -> NUMBER .)
    CLOSE_SQUARE    reduce using rule 95 (literal -> NUMBER .)


state 62

    (96) literal -> FLOAT .

    MULTIPLY        reduce using rule 96 (literal -> FLOAT .)
    DIVIDE          reduce using rule 96 (literal -> FLOAT .)
    MODULO          reduce using rule 96 (literal -> FLOAT .)
    PLUS            reduce using rule 96 (literal -> FLOAT .)
    MINUS           reduce using rule 96 (literal -> FLOAT .)
    LEFT_SHIFT      reduce using rule 96 (literal -> FLOAT .)
    RIGHT_SHIFT     reduce using rule 96 (literal -> FLOAT .)
    BIT_AND         reduce using rule 96 (literal -> FLOAT .)
    BIT_XOR         reduce using rule 96 (literal -> FLOAT .)
    BIT_OR          reduce using rule 96 (literal -> FLOAT .)
    DOUBLE_EQUALS   reduce using rule 96 (literal -> FLOAT .)
    NOT_EQUALS      reduce using rule 96 (literal -> FLOAT .)
    EQUAL_TILDE     reduce using rule 96 (literal -> FLOAT .)
    COMPARISON      reduce using rule 96 (literal -> FLOAT .)
    LESS            reduce using rule 96 (literal -> FLOAT .)
    LESS_EQUALS     reduce using rule 96 (literal -> FLOAT .)
    GREATER         reduce using rule 96 (literal -> FLOAT .)
    GREATER_EQUALS  reduce using rule 96 (literal -> FLOAT .)
    INCL_RANGE      reduce using rule 96 (literal -> FLOAT .)
    EXCL_RANGE      reduce using rule 96 (literal -> FLOAT .)
    LOGICAL_OR      reduce using rule 96 (literal -> FLOAT .)
    SEMI_COLON      reduce using rule 96 (literal -> FLOAT .)
    NEWLINE         reduce using rule 96 (literal -> FLOAT .)
    puts            reduce using rule 96 (literal -> FLOAT .)
    print           reduce using rule 96 (literal -> FLOAT .)
    gets            reduce using rule 96 (literal -> FLOAT .)
    class           reduce using rule 96 (literal -> FLOAT .)
    break           reduce using rule 96 (literal -> FLOAT .)
    def             reduce using rule 96 (literal -> FLOAT .)
    if              reduce using rule 96 (literal -> FLOAT .)
    while           reduce using rule 96 (literal -> FLOAT .)
    until           reduce using rule 96 (literal -> FLOAT .)
    case            reduce using rule 96 (literal -> FLOAT .)
    for             reduce using rule 96 (literal -> FLOAT .)
    return          reduce using rule 96 (literal -> FLOAT .)
    IDENTIFIER      reduce using rule 96 (literal -> FLOAT .)
    nil             reduce using rule 96 (literal -> FLOAT .)
    self            reduce using rule 96 (literal -> FLOAT .)
    GLOBAL          reduce using rule 96 (literal -> FLOAT .)
    AT_THE_RATE     reduce using rule 96 (literal -> FLOAT .)
    OPEN_BRACKET    reduce using rule 96 (literal -> FLOAT .)
    Array           reduce using rule 96 (literal -> FLOAT .)
    NUMBER          reduce using rule 96 (literal -> FLOAT .)
    FLOAT           reduce using rule 96 (literal -> FLOAT .)
    STRING          reduce using rule 96 (literal -> FLOAT .)
    true            reduce using rule 96 (literal -> FLOAT .)
    false           reduce using rule 96 (literal -> FLOAT .)
    $end            reduce using rule 96 (literal -> FLOAT .)
    CLOSE_BRACKET   reduce using rule 96 (literal -> FLOAT .)
    then            reduce using rule 96 (literal -> FLOAT .)
    do              reduce using rule 96 (literal -> FLOAT .)
    COMMA           reduce using rule 96 (literal -> FLOAT .)
    CLOSE_SQUARE    reduce using rule 96 (literal -> FLOAT .)


state 63

    (98) literal -> true .

    MULTIPLY        reduce using rule 98 (literal -> true .)
    DIVIDE          reduce using rule 98 (literal -> true .)
    MODULO          reduce using rule 98 (literal -> true .)
    PLUS            reduce using rule 98 (literal -> true .)
    MINUS           reduce using rule 98 (literal -> true .)
    LEFT_SHIFT      reduce using rule 98 (literal -> true .)
    RIGHT_SHIFT     reduce using rule 98 (literal -> true .)
    BIT_AND         reduce using rule 98 (literal -> true .)
    BIT_XOR         reduce using rule 98 (literal -> true .)
    BIT_OR          reduce using rule 98 (literal -> true .)
    DOUBLE_EQUALS   reduce using rule 98 (literal -> true .)
    NOT_EQUALS      reduce using rule 98 (literal -> true .)
    EQUAL_TILDE     reduce using rule 98 (literal -> true .)
    COMPARISON      reduce using rule 98 (literal -> true .)
    LESS            reduce using rule 98 (literal -> true .)
    LESS_EQUALS     reduce using rule 98 (literal -> true .)
    GREATER         reduce using rule 98 (literal -> true .)
    GREATER_EQUALS  reduce using rule 98 (literal -> true .)
    INCL_RANGE      reduce using rule 98 (literal -> true .)
    EXCL_RANGE      reduce using rule 98 (literal -> true .)
    LOGICAL_OR      reduce using rule 98 (literal -> true .)
    SEMI_COLON      reduce using rule 98 (literal -> true .)
    NEWLINE         reduce using rule 98 (literal -> true .)
    puts            reduce using rule 98 (literal -> true .)
    print           reduce using rule 98 (literal -> true .)
    gets            reduce using rule 98 (literal -> true .)
    class           reduce using rule 98 (literal -> true .)
    break           reduce using rule 98 (literal -> true .)
    def             reduce using rule 98 (literal -> true .)
    if              reduce using rule 98 (literal -> true .)
    while           reduce using rule 98 (literal -> true .)
    until           reduce using rule 98 (literal -> true .)
    case            reduce using rule 98 (literal -> true .)
    for             reduce using rule 98 (literal -> true .)
    return          reduce using rule 98 (literal -> true .)
    IDENTIFIER      reduce using rule 98 (literal -> true .)
    nil             reduce using rule 98 (literal -> true .)
    self            reduce using rule 98 (literal -> true .)
    GLOBAL          reduce using rule 98 (literal -> true .)
    AT_THE_RATE     reduce using rule 98 (literal -> true .)
    OPEN_BRACKET    reduce using rule 98 (literal -> true .)
    Array           reduce using rule 98 (literal -> true .)
    NUMBER          reduce using rule 98 (literal -> true .)
    FLOAT           reduce using rule 98 (literal -> true .)
    STRING          reduce using rule 98 (literal -> true .)
    true            reduce using rule 98 (literal -> true .)
    false           reduce using rule 98 (literal -> true .)
    $end            reduce using rule 98 (literal -> true .)
    CLOSE_BRACKET   reduce using rule 98 (literal -> true .)
    then            reduce using rule 98 (literal -> true .)
    do              reduce using rule 98 (literal -> true .)
    COMMA           reduce using rule 98 (literal -> true .)
    CLOSE_SQUARE    reduce using rule 98 (literal -> true .)


state 64

    (99) literal -> false .

    MULTIPLY        reduce using rule 99 (literal -> false .)
    DIVIDE          reduce using rule 99 (literal -> false .)
    MODULO          reduce using rule 99 (literal -> false .)
    PLUS            reduce using rule 99 (literal -> false .)
    MINUS           reduce using rule 99 (literal -> false .)
    LEFT_SHIFT      reduce using rule 99 (literal -> false .)
    RIGHT_SHIFT     reduce using rule 99 (literal -> false .)
    BIT_AND         reduce using rule 99 (literal -> false .)
    BIT_XOR         reduce using rule 99 (literal -> false .)
    BIT_OR          reduce using rule 99 (literal -> false .)
    DOUBLE_EQUALS   reduce using rule 99 (literal -> false .)
    NOT_EQUALS      reduce using rule 99 (literal -> false .)
    EQUAL_TILDE     reduce using rule 99 (literal -> false .)
    COMPARISON      reduce using rule 99 (literal -> false .)
    LESS            reduce using rule 99 (literal -> false .)
    LESS_EQUALS     reduce using rule 99 (literal -> false .)
    GREATER         reduce using rule 99 (literal -> false .)
    GREATER_EQUALS  reduce using rule 99 (literal -> false .)
    INCL_RANGE      reduce using rule 99 (literal -> false .)
    EXCL_RANGE      reduce using rule 99 (literal -> false .)
    LOGICAL_OR      reduce using rule 99 (literal -> false .)
    SEMI_COLON      reduce using rule 99 (literal -> false .)
    NEWLINE         reduce using rule 99 (literal -> false .)
    puts            reduce using rule 99 (literal -> false .)
    print           reduce using rule 99 (literal -> false .)
    gets            reduce using rule 99 (literal -> false .)
    class           reduce using rule 99 (literal -> false .)
    break           reduce using rule 99 (literal -> false .)
    def             reduce using rule 99 (literal -> false .)
    if              reduce using rule 99 (literal -> false .)
    while           reduce using rule 99 (literal -> false .)
    until           reduce using rule 99 (literal -> false .)
    case            reduce using rule 99 (literal -> false .)
    for             reduce using rule 99 (literal -> false .)
    return          reduce using rule 99 (literal -> false .)
    IDENTIFIER      reduce using rule 99 (literal -> false .)
    nil             reduce using rule 99 (literal -> false .)
    self            reduce using rule 99 (literal -> false .)
    GLOBAL          reduce using rule 99 (literal -> false .)
    AT_THE_RATE     reduce using rule 99 (literal -> false .)
    OPEN_BRACKET    reduce using rule 99 (literal -> false .)
    Array           reduce using rule 99 (literal -> false .)
    NUMBER          reduce using rule 99 (literal -> false .)
    FLOAT           reduce using rule 99 (literal -> false .)
    STRING          reduce using rule 99 (literal -> false .)
    true            reduce using rule 99 (literal -> false .)
    false           reduce using rule 99 (literal -> false .)
    $end            reduce using rule 99 (literal -> false .)
    CLOSE_BRACKET   reduce using rule 99 (literal -> false .)
    then            reduce using rule 99 (literal -> false .)
    do              reduce using rule 99 (literal -> false .)
    COMMA           reduce using rule 99 (literal -> false .)
    CLOSE_SQUARE    reduce using rule 99 (literal -> false .)


state 65

    (2) multcompstmt -> newline stmt1 . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (5) multcompstmt -> . empty
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE
    (6) stmt1 -> . stmt
    (141) empty -> .
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7
    $end            reduce using rule 141 (empty -> .)
    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    newline                        shift and go to state 3
    stmt1                          shift and go to state 4
    multcompstmt                   shift and go to state 126
    empty                          shift and go to state 5
    stmt                           shift and go to state 8
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 66

    (3) multcompstmt -> stmt1 multcompstmt .

    $end            reduce using rule 3 (multcompstmt -> stmt1 multcompstmt .)


state 67

    (7) stmt -> keydef argdecl . newline multstmt keyend
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 127

state 68

    (110) argdecl -> OPEN_BRACKET . arglist CLOSE_BRACKET
    (111) arglist -> . IDENTIFIER multarglist
    (112) arglist -> . empty
    (141) empty -> .

    IDENTIFIER      shift and go to state 129
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    arglist                        shift and go to state 128
    empty                          shift and go to state 130

state 69

    (8) stmt -> puts OPEN_BRACKET . STRING CLOSE_BRACKET

    STRING          shift and go to state 131


state 70

    (78) primary -> OPEN_BRACKET expr2 . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 132


state 71

    (9) stmt -> print OPEN_BRACKET . primary CLOSE_BRACKET
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    primary                        shift and go to state 133
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 72

    (10) stmt -> gets OPEN_BRACKET . IDENTIFIER CLOSE_BRACKET

    IDENTIFIER      shift and go to state 134


state 73

    (34) function -> IDENTIFIER OPEN_BRACKET . callargs CLOSE_BRACKET
    (35) function -> IDENTIFIER OPEN_BRACKET . CLOSE_BRACKET
    (105) callargs -> . callarglist
    (106) callarglist -> . primary callmultarglist
    (107) callarglist -> . empty
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (141) empty -> .
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

  ! shift/reduce conflict for CLOSE_BRACKET resolved as shift
    CLOSE_BRACKET   shift and go to state 136
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

  ! CLOSE_BRACKET   [ reduce using rule 141 (empty -> .) ]

    callargs                       shift and go to state 135
    callarglist                    shift and go to state 137
    primary                        shift and go to state 138
    empty                          shift and go to state 139
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 74

    (11) stmt -> class IDENTIFIER . newline multstmt end
    (12) stmt -> class IDENTIFIER . LESS IDENTIFIER newline multstmt end
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    LESS            shift and go to state 141
    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 140

state 75

    (15) keydef -> def IDENTIFIER .

    OPEN_BRACKET    reduce using rule 15 (keydef -> def IDENTIFIER .)


state 76

    (19) expr -> if expr1 . pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> if expr1 . pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> if expr1 . pthen M_1 multstmt end M_1
    (118) pthen -> . newline
    (119) pthen -> . then
    (120) pthen -> . newline then
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    then            shift and go to state 144
    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    pthen                          shift and go to state 142
    newline                        shift and go to state 143

state 77

    (22) expr -> while M_1 . expr1 pdo M_1 multstmt end M_1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 145
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    mlhs                           shift and go to state 27
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 78

    (27) M_1 -> empty .

    return          reduce using rule 27 (M_1 -> empty .)
    IDENTIFIER      reduce using rule 27 (M_1 -> empty .)
    nil             reduce using rule 27 (M_1 -> empty .)
    self            reduce using rule 27 (M_1 -> empty .)
    GLOBAL          reduce using rule 27 (M_1 -> empty .)
    AT_THE_RATE     reduce using rule 27 (M_1 -> empty .)
    MINUS           reduce using rule 27 (M_1 -> empty .)
    PLUS            reduce using rule 27 (M_1 -> empty .)
    OPEN_BRACKET    reduce using rule 27 (M_1 -> empty .)
    Array           reduce using rule 27 (M_1 -> empty .)
    NUMBER          reduce using rule 27 (M_1 -> empty .)
    FLOAT           reduce using rule 27 (M_1 -> empty .)
    STRING          reduce using rule 27 (M_1 -> empty .)
    true            reduce using rule 27 (M_1 -> empty .)
    false           reduce using rule 27 (M_1 -> empty .)
    puts            reduce using rule 27 (M_1 -> empty .)
    print           reduce using rule 27 (M_1 -> empty .)
    gets            reduce using rule 27 (M_1 -> empty .)
    class           reduce using rule 27 (M_1 -> empty .)
    break           reduce using rule 27 (M_1 -> empty .)
    def             reduce using rule 27 (M_1 -> empty .)
    if              reduce using rule 27 (M_1 -> empty .)
    while           reduce using rule 27 (M_1 -> empty .)
    until           reduce using rule 27 (M_1 -> empty .)
    case            reduce using rule 27 (M_1 -> empty .)
    for             reduce using rule 27 (M_1 -> empty .)
    else            reduce using rule 27 (M_1 -> empty .)
    end             reduce using rule 27 (M_1 -> empty .)
    elsif           reduce using rule 27 (M_1 -> empty .)
    SEMI_COLON      reduce using rule 27 (M_1 -> empty .)
    NEWLINE         reduce using rule 27 (M_1 -> empty .)
    $end            reduce using rule 27 (M_1 -> empty .)
    then            reduce using rule 27 (M_1 -> empty .)
    when            reduce using rule 27 (M_1 -> empty .)


state 79

    (23) expr -> until M_1 . expr1 pdo M_1 multstmt end M_1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 146
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    mlhs                           shift and go to state 27
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 80

    (24) expr -> case expr1 . newline multcase end M_1
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 147

state 81

    (25) expr -> for M_1 . mlhs in expr1 pdo M_1 multstmt end M_1
    (101) mlhs -> . mlhsitem
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER

    IDENTIFIER      shift and go to state 149
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46

    mlhs                           shift and go to state 148
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    variable                       shift and go to state 150
    varname                        shift and go to state 151

state 82

    (37) term0 -> mlhs EQUALS . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> mlhs EQUALS . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (40) term1 -> mlhs EQUALS . mrhs
    (104) mrhs -> . term2
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    IDENTIFIER      shift and go to state 152
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    nil             shift and go to state 42
    self            shift and go to state 43

    mrhs                           shift and go to state 153
    term2                          shift and go to state 154
    term3                          shift and go to state 38
    term4                          shift and go to state 40
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 83

    (41) term1 -> mlhs opasgn . mrhs
    (104) mrhs -> . term2
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    mrhs                           shift and go to state 155
    term2                          shift and go to state 154
    term3                          shift and go to state 38
    term4                          shift and go to state 40
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 84

    (124) opasgn -> MODULO_EQUALS .

    MINUS           reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    PLUS            reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    OPEN_BRACKET    reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    Array           reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    NUMBER          reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    FLOAT           reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    STRING          reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    true            reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    false           reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    GLOBAL          reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    AT_THE_RATE     reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    IDENTIFIER      reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    nil             reduce using rule 124 (opasgn -> MODULO_EQUALS .)
    self            reduce using rule 124 (opasgn -> MODULO_EQUALS .)


state 85

    (125) opasgn -> DIVIDE_EQUALS .

    MINUS           reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    PLUS            reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    OPEN_BRACKET    reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    Array           reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    NUMBER          reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    STRING          reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    true            reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    false           reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    GLOBAL          reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    AT_THE_RATE     reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    IDENTIFIER      reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    nil             reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)
    self            reduce using rule 125 (opasgn -> DIVIDE_EQUALS .)


state 86

    (126) opasgn -> MINUS_EQUALS .

    MINUS           reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    PLUS            reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    OPEN_BRACKET    reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    Array           reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    NUMBER          reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    FLOAT           reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    STRING          reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    true            reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    false           reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    GLOBAL          reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    AT_THE_RATE     reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    IDENTIFIER      reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    nil             reduce using rule 126 (opasgn -> MINUS_EQUALS .)
    self            reduce using rule 126 (opasgn -> MINUS_EQUALS .)


state 87

    (127) opasgn -> PLUS_EQUALS .

    MINUS           reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    PLUS            reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    OPEN_BRACKET    reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    Array           reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    NUMBER          reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    FLOAT           reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    STRING          reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    true            reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    false           reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    GLOBAL          reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    AT_THE_RATE     reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    IDENTIFIER      reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    nil             reduce using rule 127 (opasgn -> PLUS_EQUALS .)
    self            reduce using rule 127 (opasgn -> PLUS_EQUALS .)


state 88

    (128) opasgn -> OR_EQUALS .

    MINUS           reduce using rule 128 (opasgn -> OR_EQUALS .)
    PLUS            reduce using rule 128 (opasgn -> OR_EQUALS .)
    OPEN_BRACKET    reduce using rule 128 (opasgn -> OR_EQUALS .)
    Array           reduce using rule 128 (opasgn -> OR_EQUALS .)
    NUMBER          reduce using rule 128 (opasgn -> OR_EQUALS .)
    FLOAT           reduce using rule 128 (opasgn -> OR_EQUALS .)
    STRING          reduce using rule 128 (opasgn -> OR_EQUALS .)
    true            reduce using rule 128 (opasgn -> OR_EQUALS .)
    false           reduce using rule 128 (opasgn -> OR_EQUALS .)
    GLOBAL          reduce using rule 128 (opasgn -> OR_EQUALS .)
    AT_THE_RATE     reduce using rule 128 (opasgn -> OR_EQUALS .)
    IDENTIFIER      reduce using rule 128 (opasgn -> OR_EQUALS .)
    nil             reduce using rule 128 (opasgn -> OR_EQUALS .)
    self            reduce using rule 128 (opasgn -> OR_EQUALS .)


state 89

    (129) opasgn -> AND_EQUALS .

    MINUS           reduce using rule 129 (opasgn -> AND_EQUALS .)
    PLUS            reduce using rule 129 (opasgn -> AND_EQUALS .)
    OPEN_BRACKET    reduce using rule 129 (opasgn -> AND_EQUALS .)
    Array           reduce using rule 129 (opasgn -> AND_EQUALS .)
    NUMBER          reduce using rule 129 (opasgn -> AND_EQUALS .)
    FLOAT           reduce using rule 129 (opasgn -> AND_EQUALS .)
    STRING          reduce using rule 129 (opasgn -> AND_EQUALS .)
    true            reduce using rule 129 (opasgn -> AND_EQUALS .)
    false           reduce using rule 129 (opasgn -> AND_EQUALS .)
    GLOBAL          reduce using rule 129 (opasgn -> AND_EQUALS .)
    AT_THE_RATE     reduce using rule 129 (opasgn -> AND_EQUALS .)
    IDENTIFIER      reduce using rule 129 (opasgn -> AND_EQUALS .)
    nil             reduce using rule 129 (opasgn -> AND_EQUALS .)
    self            reduce using rule 129 (opasgn -> AND_EQUALS .)


state 90

    (130) opasgn -> XOR_EQUALS .

    MINUS           reduce using rule 130 (opasgn -> XOR_EQUALS .)
    PLUS            reduce using rule 130 (opasgn -> XOR_EQUALS .)
    OPEN_BRACKET    reduce using rule 130 (opasgn -> XOR_EQUALS .)
    Array           reduce using rule 130 (opasgn -> XOR_EQUALS .)
    NUMBER          reduce using rule 130 (opasgn -> XOR_EQUALS .)
    FLOAT           reduce using rule 130 (opasgn -> XOR_EQUALS .)
    STRING          reduce using rule 130 (opasgn -> XOR_EQUALS .)
    true            reduce using rule 130 (opasgn -> XOR_EQUALS .)
    false           reduce using rule 130 (opasgn -> XOR_EQUALS .)
    GLOBAL          reduce using rule 130 (opasgn -> XOR_EQUALS .)
    AT_THE_RATE     reduce using rule 130 (opasgn -> XOR_EQUALS .)
    IDENTIFIER      reduce using rule 130 (opasgn -> XOR_EQUALS .)
    nil             reduce using rule 130 (opasgn -> XOR_EQUALS .)
    self            reduce using rule 130 (opasgn -> XOR_EQUALS .)


state 91

    (131) opasgn -> RIGHT_SHIFT_EQUALS .

    MINUS           reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    PLUS            reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    OPEN_BRACKET    reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    Array           reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    NUMBER          reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    FLOAT           reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    STRING          reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    true            reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    false           reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    GLOBAL          reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    AT_THE_RATE     reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    IDENTIFIER      reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    nil             reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)
    self            reduce using rule 131 (opasgn -> RIGHT_SHIFT_EQUALS .)


state 92

    (132) opasgn -> LEFT_SHIFT_EQUALS .

    MINUS           reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    PLUS            reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    OPEN_BRACKET    reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    Array           reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    NUMBER          reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    FLOAT           reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    STRING          reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    true            reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    false           reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    GLOBAL          reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    AT_THE_RATE     reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    IDENTIFIER      reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    nil             reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)
    self            reduce using rule 132 (opasgn -> LEFT_SHIFT_EQUALS .)


state 93

    (133) opasgn -> MULTIPLY_EQUALS .

    MINUS           reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    PLUS            reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    OPEN_BRACKET    reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    Array           reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    NUMBER          reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    FLOAT           reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    STRING          reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    true            reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    false           reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    GLOBAL          reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    AT_THE_RATE     reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    IDENTIFIER      reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    nil             reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)
    self            reduce using rule 133 (opasgn -> MULTIPLY_EQUALS .)


state 94

    (134) opasgn -> LOGICAL_AND_EQUALS .

    MINUS           reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    PLUS            reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    OPEN_BRACKET    reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    Array           reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    NUMBER          reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    FLOAT           reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    STRING          reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    true            reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    false           reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    GLOBAL          reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    AT_THE_RATE     reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    IDENTIFIER      reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    nil             reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)
    self            reduce using rule 134 (opasgn -> LOGICAL_AND_EQUALS .)


state 95

    (135) opasgn -> LOGICAL_OR_EQUALS .

    MINUS           reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    PLUS            reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    OPEN_BRACKET    reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    Array           reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    NUMBER          reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    FLOAT           reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    STRING          reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    true            reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    false           reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    GLOBAL          reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    AT_THE_RATE     reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    IDENTIFIER      reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    nil             reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)
    self            reduce using rule 135 (opasgn -> LOGICAL_OR_EQUALS .)


state 96

    (28) expr1 -> return term2 .

    SEMI_COLON      reduce using rule 28 (expr1 -> return term2 .)
    NEWLINE         reduce using rule 28 (expr1 -> return term2 .)
    puts            reduce using rule 28 (expr1 -> return term2 .)
    print           reduce using rule 28 (expr1 -> return term2 .)
    gets            reduce using rule 28 (expr1 -> return term2 .)
    class           reduce using rule 28 (expr1 -> return term2 .)
    break           reduce using rule 28 (expr1 -> return term2 .)
    def             reduce using rule 28 (expr1 -> return term2 .)
    if              reduce using rule 28 (expr1 -> return term2 .)
    while           reduce using rule 28 (expr1 -> return term2 .)
    until           reduce using rule 28 (expr1 -> return term2 .)
    case            reduce using rule 28 (expr1 -> return term2 .)
    for             reduce using rule 28 (expr1 -> return term2 .)
    return          reduce using rule 28 (expr1 -> return term2 .)
    IDENTIFIER      reduce using rule 28 (expr1 -> return term2 .)
    nil             reduce using rule 28 (expr1 -> return term2 .)
    self            reduce using rule 28 (expr1 -> return term2 .)
    GLOBAL          reduce using rule 28 (expr1 -> return term2 .)
    AT_THE_RATE     reduce using rule 28 (expr1 -> return term2 .)
    MINUS           reduce using rule 28 (expr1 -> return term2 .)
    PLUS            reduce using rule 28 (expr1 -> return term2 .)
    OPEN_BRACKET    reduce using rule 28 (expr1 -> return term2 .)
    Array           reduce using rule 28 (expr1 -> return term2 .)
    NUMBER          reduce using rule 28 (expr1 -> return term2 .)
    FLOAT           reduce using rule 28 (expr1 -> return term2 .)
    STRING          reduce using rule 28 (expr1 -> return term2 .)
    true            reduce using rule 28 (expr1 -> return term2 .)
    false           reduce using rule 28 (expr1 -> return term2 .)
    $end            reduce using rule 28 (expr1 -> return term2 .)
    then            reduce using rule 28 (expr1 -> return term2 .)
    do              reduce using rule 28 (expr1 -> return term2 .)


state 97

    (82) primary -> varname .
    (115) variable -> varname .

    MULTIPLY        reduce using rule 82 (primary -> varname .)
    DIVIDE          reduce using rule 82 (primary -> varname .)
    MODULO          reduce using rule 82 (primary -> varname .)
    PLUS            reduce using rule 82 (primary -> varname .)
    MINUS           reduce using rule 82 (primary -> varname .)
    LEFT_SHIFT      reduce using rule 82 (primary -> varname .)
    RIGHT_SHIFT     reduce using rule 82 (primary -> varname .)
    BIT_AND         reduce using rule 82 (primary -> varname .)
    BIT_XOR         reduce using rule 82 (primary -> varname .)
    BIT_OR          reduce using rule 82 (primary -> varname .)
    DOUBLE_EQUALS   reduce using rule 82 (primary -> varname .)
    NOT_EQUALS      reduce using rule 82 (primary -> varname .)
    EQUAL_TILDE     reduce using rule 82 (primary -> varname .)
    COMPARISON      reduce using rule 82 (primary -> varname .)
    LESS            reduce using rule 82 (primary -> varname .)
    LESS_EQUALS     reduce using rule 82 (primary -> varname .)
    GREATER         reduce using rule 82 (primary -> varname .)
    GREATER_EQUALS  reduce using rule 82 (primary -> varname .)
    INCL_RANGE      reduce using rule 82 (primary -> varname .)
    EXCL_RANGE      reduce using rule 82 (primary -> varname .)
    LOGICAL_OR      reduce using rule 82 (primary -> varname .)
    SEMI_COLON      reduce using rule 82 (primary -> varname .)
    NEWLINE         reduce using rule 82 (primary -> varname .)
    puts            reduce using rule 82 (primary -> varname .)
    print           reduce using rule 82 (primary -> varname .)
    gets            reduce using rule 82 (primary -> varname .)
    class           reduce using rule 82 (primary -> varname .)
    break           reduce using rule 82 (primary -> varname .)
    def             reduce using rule 82 (primary -> varname .)
    if              reduce using rule 82 (primary -> varname .)
    while           reduce using rule 82 (primary -> varname .)
    until           reduce using rule 82 (primary -> varname .)
    case            reduce using rule 82 (primary -> varname .)
    for             reduce using rule 82 (primary -> varname .)
    return          reduce using rule 82 (primary -> varname .)
    IDENTIFIER      reduce using rule 82 (primary -> varname .)
    nil             reduce using rule 82 (primary -> varname .)
    self            reduce using rule 82 (primary -> varname .)
    GLOBAL          reduce using rule 82 (primary -> varname .)
    AT_THE_RATE     reduce using rule 82 (primary -> varname .)
    OPEN_BRACKET    reduce using rule 82 (primary -> varname .)
    Array           reduce using rule 82 (primary -> varname .)
    NUMBER          reduce using rule 82 (primary -> varname .)
    FLOAT           reduce using rule 82 (primary -> varname .)
    STRING          reduce using rule 82 (primary -> varname .)
    true            reduce using rule 82 (primary -> varname .)
    false           reduce using rule 82 (primary -> varname .)
    $end            reduce using rule 82 (primary -> varname .)
    then            reduce using rule 82 (primary -> varname .)
    do              reduce using rule 82 (primary -> varname .)
    CLOSE_BRACKET   reduce using rule 82 (primary -> varname .)
    COMMA           reduce using rule 82 (primary -> varname .)
    CLOSE_SQUARE    reduce using rule 82 (primary -> varname .)
    OPEN_SQUARE     reduce using rule 115 (variable -> varname .)


state 98

    (87) arraya -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 156


state 99

    (138) varname -> IDENTIFIER .

    MULTIPLY        reduce using rule 138 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 138 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 138 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 138 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 138 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 138 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 138 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 138 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 138 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 138 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 138 (varname -> IDENTIFIER .)
    LESS            reduce using rule 138 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 138 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 138 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 138 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 138 (varname -> IDENTIFIER .)
    puts            reduce using rule 138 (varname -> IDENTIFIER .)
    print           reduce using rule 138 (varname -> IDENTIFIER .)
    gets            reduce using rule 138 (varname -> IDENTIFIER .)
    class           reduce using rule 138 (varname -> IDENTIFIER .)
    break           reduce using rule 138 (varname -> IDENTIFIER .)
    def             reduce using rule 138 (varname -> IDENTIFIER .)
    if              reduce using rule 138 (varname -> IDENTIFIER .)
    while           reduce using rule 138 (varname -> IDENTIFIER .)
    until           reduce using rule 138 (varname -> IDENTIFIER .)
    case            reduce using rule 138 (varname -> IDENTIFIER .)
    for             reduce using rule 138 (varname -> IDENTIFIER .)
    return          reduce using rule 138 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 138 (varname -> IDENTIFIER .)
    nil             reduce using rule 138 (varname -> IDENTIFIER .)
    self            reduce using rule 138 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 138 (varname -> IDENTIFIER .)
    AT_THE_RATE     reduce using rule 138 (varname -> IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 138 (varname -> IDENTIFIER .)
    Array           reduce using rule 138 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 138 (varname -> IDENTIFIER .)
    FLOAT           reduce using rule 138 (varname -> IDENTIFIER .)
    STRING          reduce using rule 138 (varname -> IDENTIFIER .)
    true            reduce using rule 138 (varname -> IDENTIFIER .)
    false           reduce using rule 138 (varname -> IDENTIFIER .)
    $end            reduce using rule 138 (varname -> IDENTIFIER .)
    then            reduce using rule 138 (varname -> IDENTIFIER .)
    do              reduce using rule 138 (varname -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 138 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 138 (varname -> IDENTIFIER .)
    COMMA           reduce using rule 138 (varname -> IDENTIFIER .)
    CLOSE_SQUARE    reduce using rule 138 (varname -> IDENTIFIER .)


state 100

    (43) term2 -> term3 INCL_RANGE . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term3                          shift and go to state 157
    term4                          shift and go to state 40
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 101

    (44) term2 -> term3 EXCL_RANGE . term3
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term3                          shift and go to state 158
    term4                          shift and go to state 40
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 102

    (46) term3 -> term3 LOGICAL_OR . term4
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term4                          shift and go to state 159
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 103

    (86) arrayal -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (87) arraya -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (88) array_args -> . primary COMMA array_args
    (89) array_args -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    variable                       shift and go to state 98
    array_args                     shift and go to state 160
    primary                        shift and go to state 161
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97

state 104

    (48) term4 -> term5 DOUBLE_EQUALS . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term5                          shift and go to state 162
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 105

    (49) term4 -> term5 NOT_EQUALS . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term5                          shift and go to state 163
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 106

    (50) term4 -> term5 EQUAL_TILDE . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term5                          shift and go to state 164
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 107

    (51) term4 -> term5 COMPARISON . term5
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term5                          shift and go to state 165
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 108

    (53) term5 -> term5 LESS . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term6                          shift and go to state 166
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 109

    (54) term5 -> term5 LESS_EQUALS . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term6                          shift and go to state 167
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 110

    (55) term5 -> term5 GREATER . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term6                          shift and go to state 168
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 111

    (56) term5 -> term5 GREATER_EQUALS . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term6                          shift and go to state 169
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 112

    (137) varname -> AT_THE_RATE IDENTIFIER .

    OPEN_SQUARE     reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    MULTIPLY        reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    DIVIDE          reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    MODULO          reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    PLUS            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    MINUS           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    BIT_AND         reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    BIT_XOR         reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    BIT_OR          reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    NOT_EQUALS      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    COMPARISON      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    LESS            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    LESS_EQUALS     reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    GREATER         reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    INCL_RANGE      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    EXCL_RANGE      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    LOGICAL_OR      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    SEMI_COLON      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    NEWLINE         reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    puts            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    print           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    gets            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    class           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    break           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    def             reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    if              reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    while           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    until           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    case            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    for             reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    return          reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    IDENTIFIER      reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    nil             reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    self            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    GLOBAL          reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    AT_THE_RATE     reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    Array           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    NUMBER          reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    FLOAT           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    STRING          reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    true            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    false           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    $end            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    then            reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    do              reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    COMMA           reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)
    CLOSE_SQUARE    reduce using rule 137 (varname -> AT_THE_RATE IDENTIFIER .)


state 113

    (58) term6 -> term6 BIT_XOR . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term7                          shift and go to state 170
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 114

    (59) term6 -> term6 BIT_OR . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term7                          shift and go to state 171
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 115

    (61) term7 -> term7 BIT_AND . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term8                          shift and go to state 172
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 116

    (63) term8 -> term8 LEFT_SHIFT . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term9                          shift and go to state 173
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 117

    (64) term8 -> term8 RIGHT_SHIFT . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term9                          shift and go to state 174
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 118

    (66) term9 -> term9 PLUS . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term10                         shift and go to state 175
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 119

    (67) term9 -> term9 MINUS . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term10                         shift and go to state 176
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 120

    (75) term12 -> PLUS term12 .

    MULTIPLY        reduce using rule 75 (term12 -> PLUS term12 .)
    DIVIDE          reduce using rule 75 (term12 -> PLUS term12 .)
    MODULO          reduce using rule 75 (term12 -> PLUS term12 .)
    PLUS            reduce using rule 75 (term12 -> PLUS term12 .)
    MINUS           reduce using rule 75 (term12 -> PLUS term12 .)
    LEFT_SHIFT      reduce using rule 75 (term12 -> PLUS term12 .)
    RIGHT_SHIFT     reduce using rule 75 (term12 -> PLUS term12 .)
    BIT_AND         reduce using rule 75 (term12 -> PLUS term12 .)
    BIT_XOR         reduce using rule 75 (term12 -> PLUS term12 .)
    BIT_OR          reduce using rule 75 (term12 -> PLUS term12 .)
    DOUBLE_EQUALS   reduce using rule 75 (term12 -> PLUS term12 .)
    NOT_EQUALS      reduce using rule 75 (term12 -> PLUS term12 .)
    EQUAL_TILDE     reduce using rule 75 (term12 -> PLUS term12 .)
    COMPARISON      reduce using rule 75 (term12 -> PLUS term12 .)
    LESS            reduce using rule 75 (term12 -> PLUS term12 .)
    LESS_EQUALS     reduce using rule 75 (term12 -> PLUS term12 .)
    GREATER         reduce using rule 75 (term12 -> PLUS term12 .)
    GREATER_EQUALS  reduce using rule 75 (term12 -> PLUS term12 .)
    INCL_RANGE      reduce using rule 75 (term12 -> PLUS term12 .)
    EXCL_RANGE      reduce using rule 75 (term12 -> PLUS term12 .)
    LOGICAL_OR      reduce using rule 75 (term12 -> PLUS term12 .)
    SEMI_COLON      reduce using rule 75 (term12 -> PLUS term12 .)
    NEWLINE         reduce using rule 75 (term12 -> PLUS term12 .)
    puts            reduce using rule 75 (term12 -> PLUS term12 .)
    print           reduce using rule 75 (term12 -> PLUS term12 .)
    gets            reduce using rule 75 (term12 -> PLUS term12 .)
    class           reduce using rule 75 (term12 -> PLUS term12 .)
    break           reduce using rule 75 (term12 -> PLUS term12 .)
    def             reduce using rule 75 (term12 -> PLUS term12 .)
    if              reduce using rule 75 (term12 -> PLUS term12 .)
    while           reduce using rule 75 (term12 -> PLUS term12 .)
    until           reduce using rule 75 (term12 -> PLUS term12 .)
    case            reduce using rule 75 (term12 -> PLUS term12 .)
    for             reduce using rule 75 (term12 -> PLUS term12 .)
    return          reduce using rule 75 (term12 -> PLUS term12 .)
    IDENTIFIER      reduce using rule 75 (term12 -> PLUS term12 .)
    nil             reduce using rule 75 (term12 -> PLUS term12 .)
    self            reduce using rule 75 (term12 -> PLUS term12 .)
    GLOBAL          reduce using rule 75 (term12 -> PLUS term12 .)
    AT_THE_RATE     reduce using rule 75 (term12 -> PLUS term12 .)
    OPEN_BRACKET    reduce using rule 75 (term12 -> PLUS term12 .)
    Array           reduce using rule 75 (term12 -> PLUS term12 .)
    NUMBER          reduce using rule 75 (term12 -> PLUS term12 .)
    FLOAT           reduce using rule 75 (term12 -> PLUS term12 .)
    STRING          reduce using rule 75 (term12 -> PLUS term12 .)
    true            reduce using rule 75 (term12 -> PLUS term12 .)
    false           reduce using rule 75 (term12 -> PLUS term12 .)
    $end            reduce using rule 75 (term12 -> PLUS term12 .)
    CLOSE_BRACKET   reduce using rule 75 (term12 -> PLUS term12 .)
    then            reduce using rule 75 (term12 -> PLUS term12 .)
    do              reduce using rule 75 (term12 -> PLUS term12 .)


state 121

    (69) term10 -> term10 MULTIPLY . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term11                         shift and go to state 177
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 122

    (70) term10 -> term10 DIVIDE . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term11                         shift and go to state 178
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 123

    (71) term10 -> term10 MODULO . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    term11                         shift and go to state 179
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 124

    (73) term11 -> MINUS term11 .

    MULTIPLY        reduce using rule 73 (term11 -> MINUS term11 .)
    DIVIDE          reduce using rule 73 (term11 -> MINUS term11 .)
    MODULO          reduce using rule 73 (term11 -> MINUS term11 .)
    PLUS            reduce using rule 73 (term11 -> MINUS term11 .)
    MINUS           reduce using rule 73 (term11 -> MINUS term11 .)
    LEFT_SHIFT      reduce using rule 73 (term11 -> MINUS term11 .)
    RIGHT_SHIFT     reduce using rule 73 (term11 -> MINUS term11 .)
    BIT_AND         reduce using rule 73 (term11 -> MINUS term11 .)
    BIT_XOR         reduce using rule 73 (term11 -> MINUS term11 .)
    BIT_OR          reduce using rule 73 (term11 -> MINUS term11 .)
    DOUBLE_EQUALS   reduce using rule 73 (term11 -> MINUS term11 .)
    NOT_EQUALS      reduce using rule 73 (term11 -> MINUS term11 .)
    EQUAL_TILDE     reduce using rule 73 (term11 -> MINUS term11 .)
    COMPARISON      reduce using rule 73 (term11 -> MINUS term11 .)
    LESS            reduce using rule 73 (term11 -> MINUS term11 .)
    LESS_EQUALS     reduce using rule 73 (term11 -> MINUS term11 .)
    GREATER         reduce using rule 73 (term11 -> MINUS term11 .)
    GREATER_EQUALS  reduce using rule 73 (term11 -> MINUS term11 .)
    INCL_RANGE      reduce using rule 73 (term11 -> MINUS term11 .)
    EXCL_RANGE      reduce using rule 73 (term11 -> MINUS term11 .)
    LOGICAL_OR      reduce using rule 73 (term11 -> MINUS term11 .)
    SEMI_COLON      reduce using rule 73 (term11 -> MINUS term11 .)
    NEWLINE         reduce using rule 73 (term11 -> MINUS term11 .)
    puts            reduce using rule 73 (term11 -> MINUS term11 .)
    print           reduce using rule 73 (term11 -> MINUS term11 .)
    gets            reduce using rule 73 (term11 -> MINUS term11 .)
    class           reduce using rule 73 (term11 -> MINUS term11 .)
    break           reduce using rule 73 (term11 -> MINUS term11 .)
    def             reduce using rule 73 (term11 -> MINUS term11 .)
    if              reduce using rule 73 (term11 -> MINUS term11 .)
    while           reduce using rule 73 (term11 -> MINUS term11 .)
    until           reduce using rule 73 (term11 -> MINUS term11 .)
    case            reduce using rule 73 (term11 -> MINUS term11 .)
    for             reduce using rule 73 (term11 -> MINUS term11 .)
    return          reduce using rule 73 (term11 -> MINUS term11 .)
    IDENTIFIER      reduce using rule 73 (term11 -> MINUS term11 .)
    nil             reduce using rule 73 (term11 -> MINUS term11 .)
    self            reduce using rule 73 (term11 -> MINUS term11 .)
    GLOBAL          reduce using rule 73 (term11 -> MINUS term11 .)
    AT_THE_RATE     reduce using rule 73 (term11 -> MINUS term11 .)
    OPEN_BRACKET    reduce using rule 73 (term11 -> MINUS term11 .)
    Array           reduce using rule 73 (term11 -> MINUS term11 .)
    NUMBER          reduce using rule 73 (term11 -> MINUS term11 .)
    FLOAT           reduce using rule 73 (term11 -> MINUS term11 .)
    STRING          reduce using rule 73 (term11 -> MINUS term11 .)
    true            reduce using rule 73 (term11 -> MINUS term11 .)
    false           reduce using rule 73 (term11 -> MINUS term11 .)
    $end            reduce using rule 73 (term11 -> MINUS term11 .)
    CLOSE_BRACKET   reduce using rule 73 (term11 -> MINUS term11 .)
    then            reduce using rule 73 (term11 -> MINUS term11 .)
    do              reduce using rule 73 (term11 -> MINUS term11 .)


state 125

    (83) arrayd -> Array OPEN_BRACKET . array_size CLOSE_BRACKET
    (84) array_size -> . primary COMMA array_size
    (85) array_size -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    array_size                     shift and go to state 180
    primary                        shift and go to state 181
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 126

    (2) multcompstmt -> newline stmt1 multcompstmt .

    $end            reduce using rule 2 (multcompstmt -> newline stmt1 multcompstmt .)


state 127

    (7) stmt -> keydef argdecl newline . multstmt keyend
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    keydef                         shift and go to state 9
    multstmt                       shift and go to state 182
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 128

    (110) argdecl -> OPEN_BRACKET arglist . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 185


state 129

    (111) arglist -> IDENTIFIER . multarglist
    (113) multarglist -> . COMMA IDENTIFIER multarglist
    (114) multarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 187
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    multarglist                    shift and go to state 186
    empty                          shift and go to state 188

state 130

    (112) arglist -> empty .

    CLOSE_BRACKET   reduce using rule 112 (arglist -> empty .)


state 131

    (8) stmt -> puts OPEN_BRACKET STRING . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 189


state 132

    (78) primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .

    MULTIPLY        reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    DIVIDE          reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    MODULO          reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    PLUS            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    MINUS           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LEFT_SHIFT      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    RIGHT_SHIFT     reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_AND         reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_XOR         reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_OR          reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    DOUBLE_EQUALS   reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NOT_EQUALS      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    EQUAL_TILDE     reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    COMPARISON      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LESS            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LESS_EQUALS     reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GREATER         reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GREATER_EQUALS  reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    INCL_RANGE      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    EXCL_RANGE      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LOGICAL_OR      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    SEMI_COLON      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NEWLINE         reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    puts            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    print           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    gets            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    class           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    break           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    def             reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    if              reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    while           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    until           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    case            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    for             reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    return          reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    nil             reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    self            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GLOBAL          reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    Array           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NUMBER          reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    FLOAT           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    STRING          reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    true            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    false           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    $end            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    then            reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    do              reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    COMMA           reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    CLOSE_SQUARE    reduce using rule 78 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)


state 133

    (9) stmt -> print OPEN_BRACKET primary . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 190


state 134

    (10) stmt -> gets OPEN_BRACKET IDENTIFIER . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 191


state 135

    (34) function -> IDENTIFIER OPEN_BRACKET callargs . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 192


state 136

    (35) function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NEWLINE         reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    puts            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    print           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    gets            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    class           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    break           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    def             reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    if              reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    while           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    until           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    case            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    for             reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    return          reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    nil             reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    self            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    GLOBAL          reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    MINUS           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    PLUS            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    Array           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NUMBER          reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    FLOAT           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    STRING          reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    true            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    false           reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    $end            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    then            reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    do              reduce using rule 35 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)


state 137

    (105) callargs -> callarglist .

    CLOSE_BRACKET   reduce using rule 105 (callargs -> callarglist .)


state 138

    (106) callarglist -> primary . callmultarglist
    (108) callmultarglist -> . COMMA primary callmultarglist
    (109) callmultarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 194
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    callmultarglist                shift and go to state 193
    empty                          shift and go to state 195

state 139

    (107) callarglist -> empty .

    CLOSE_BRACKET   reduce using rule 107 (callarglist -> empty .)


state 140

    (11) stmt -> class IDENTIFIER newline . multstmt end
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    multstmt                       shift and go to state 196
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 141

    (12) stmt -> class IDENTIFIER LESS . IDENTIFIER newline multstmt end

    IDENTIFIER      shift and go to state 197


state 142

    (19) expr -> if expr1 pthen . M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> if expr1 pthen . M_1 multstmt M_1 multelsif end M_1
    (21) expr -> if expr1 pthen . M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 198
    empty                          shift and go to state 78

state 143

    (118) pthen -> newline .
    (120) pthen -> newline . then

    puts            reduce using rule 118 (pthen -> newline .)
    print           reduce using rule 118 (pthen -> newline .)
    gets            reduce using rule 118 (pthen -> newline .)
    class           reduce using rule 118 (pthen -> newline .)
    break           reduce using rule 118 (pthen -> newline .)
    def             reduce using rule 118 (pthen -> newline .)
    if              reduce using rule 118 (pthen -> newline .)
    while           reduce using rule 118 (pthen -> newline .)
    until           reduce using rule 118 (pthen -> newline .)
    case            reduce using rule 118 (pthen -> newline .)
    for             reduce using rule 118 (pthen -> newline .)
    return          reduce using rule 118 (pthen -> newline .)
    IDENTIFIER      reduce using rule 118 (pthen -> newline .)
    nil             reduce using rule 118 (pthen -> newline .)
    self            reduce using rule 118 (pthen -> newline .)
    GLOBAL          reduce using rule 118 (pthen -> newline .)
    AT_THE_RATE     reduce using rule 118 (pthen -> newline .)
    MINUS           reduce using rule 118 (pthen -> newline .)
    PLUS            reduce using rule 118 (pthen -> newline .)
    OPEN_BRACKET    reduce using rule 118 (pthen -> newline .)
    Array           reduce using rule 118 (pthen -> newline .)
    NUMBER          reduce using rule 118 (pthen -> newline .)
    FLOAT           reduce using rule 118 (pthen -> newline .)
    STRING          reduce using rule 118 (pthen -> newline .)
    true            reduce using rule 118 (pthen -> newline .)
    false           reduce using rule 118 (pthen -> newline .)
    else            reduce using rule 118 (pthen -> newline .)
    end             reduce using rule 118 (pthen -> newline .)
    elsif           reduce using rule 118 (pthen -> newline .)
    when            reduce using rule 118 (pthen -> newline .)
    then            shift and go to state 199


state 144

    (119) pthen -> then .

    puts            reduce using rule 119 (pthen -> then .)
    print           reduce using rule 119 (pthen -> then .)
    gets            reduce using rule 119 (pthen -> then .)
    class           reduce using rule 119 (pthen -> then .)
    break           reduce using rule 119 (pthen -> then .)
    def             reduce using rule 119 (pthen -> then .)
    if              reduce using rule 119 (pthen -> then .)
    while           reduce using rule 119 (pthen -> then .)
    until           reduce using rule 119 (pthen -> then .)
    case            reduce using rule 119 (pthen -> then .)
    for             reduce using rule 119 (pthen -> then .)
    return          reduce using rule 119 (pthen -> then .)
    IDENTIFIER      reduce using rule 119 (pthen -> then .)
    nil             reduce using rule 119 (pthen -> then .)
    self            reduce using rule 119 (pthen -> then .)
    GLOBAL          reduce using rule 119 (pthen -> then .)
    AT_THE_RATE     reduce using rule 119 (pthen -> then .)
    MINUS           reduce using rule 119 (pthen -> then .)
    PLUS            reduce using rule 119 (pthen -> then .)
    OPEN_BRACKET    reduce using rule 119 (pthen -> then .)
    Array           reduce using rule 119 (pthen -> then .)
    NUMBER          reduce using rule 119 (pthen -> then .)
    FLOAT           reduce using rule 119 (pthen -> then .)
    STRING          reduce using rule 119 (pthen -> then .)
    true            reduce using rule 119 (pthen -> then .)
    false           reduce using rule 119 (pthen -> then .)
    else            reduce using rule 119 (pthen -> then .)
    end             reduce using rule 119 (pthen -> then .)
    elsif           reduce using rule 119 (pthen -> then .)
    when            reduce using rule 119 (pthen -> then .)


state 145

    (22) expr -> while M_1 expr1 . pdo M_1 multstmt end M_1
    (121) pdo -> . newline
    (122) pdo -> . do newline
    (123) pdo -> . newline do
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    do              shift and go to state 202
    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    pdo                            shift and go to state 200
    newline                        shift and go to state 201

state 146

    (23) expr -> until M_1 expr1 . pdo M_1 multstmt end M_1
    (121) pdo -> . newline
    (122) pdo -> . do newline
    (123) pdo -> . newline do
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    do              shift and go to state 202
    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    pdo                            shift and go to state 203
    newline                        shift and go to state 201

state 147

    (24) expr -> case expr1 newline . multcase end M_1
    (90) multcase -> . when whenargs pthen M_1 multstmt M_1 multcase
    (91) multcase -> . when whenargs pthen M_1 multstmt M_1

    when            shift and go to state 205

    multcase                       shift and go to state 204

state 148

    (25) expr -> for M_1 mlhs . in expr1 pdo M_1 multstmt end M_1

    in              shift and go to state 206


state 149

    (102) mlhsitem -> IDENTIFIER .
    (138) varname -> IDENTIFIER .

    in              reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    EQUALS          reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    OR_EQUALS       reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    AND_EQUALS      reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    XOR_EQUALS      reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    LOGICAL_AND_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    LOGICAL_OR_EQUALS reduce using rule 102 (mlhsitem -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 138 (varname -> IDENTIFIER .)
    MULTIPLY        reduce using rule 138 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 138 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 138 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 138 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 138 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 138 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 138 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 138 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 138 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 138 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 138 (varname -> IDENTIFIER .)
    LESS            reduce using rule 138 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 138 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 138 (varname -> IDENTIFIER .)
    then            reduce using rule 138 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 138 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 138 (varname -> IDENTIFIER .)


state 150

    (86) arrayal -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 207


state 151

    (115) variable -> varname .

    OPEN_SQUARE     reduce using rule 115 (variable -> varname .)


state 152

    (37) term0 -> mlhs EQUALS IDENTIFIER . OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> mlhs EQUALS IDENTIFIER . OPEN_BRACKET callargs CLOSE_BRACKET
    (138) varname -> IDENTIFIER .

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    OPEN_BRACKET    shift and go to state 208
    MULTIPLY        reduce using rule 138 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 138 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 138 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 138 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 138 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 138 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 138 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 138 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 138 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 138 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 138 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 138 (varname -> IDENTIFIER .)
    LESS            reduce using rule 138 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 138 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 138 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 138 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 138 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 138 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 138 (varname -> IDENTIFIER .)
    puts            reduce using rule 138 (varname -> IDENTIFIER .)
    print           reduce using rule 138 (varname -> IDENTIFIER .)
    gets            reduce using rule 138 (varname -> IDENTIFIER .)
    class           reduce using rule 138 (varname -> IDENTIFIER .)
    break           reduce using rule 138 (varname -> IDENTIFIER .)
    def             reduce using rule 138 (varname -> IDENTIFIER .)
    if              reduce using rule 138 (varname -> IDENTIFIER .)
    while           reduce using rule 138 (varname -> IDENTIFIER .)
    until           reduce using rule 138 (varname -> IDENTIFIER .)
    case            reduce using rule 138 (varname -> IDENTIFIER .)
    for             reduce using rule 138 (varname -> IDENTIFIER .)
    return          reduce using rule 138 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 138 (varname -> IDENTIFIER .)
    nil             reduce using rule 138 (varname -> IDENTIFIER .)
    self            reduce using rule 138 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 138 (varname -> IDENTIFIER .)
    AT_THE_RATE     reduce using rule 138 (varname -> IDENTIFIER .)
    Array           reduce using rule 138 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 138 (varname -> IDENTIFIER .)
    FLOAT           reduce using rule 138 (varname -> IDENTIFIER .)
    STRING          reduce using rule 138 (varname -> IDENTIFIER .)
    true            reduce using rule 138 (varname -> IDENTIFIER .)
    false           reduce using rule 138 (varname -> IDENTIFIER .)
    $end            reduce using rule 138 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 138 (varname -> IDENTIFIER .)
    then            reduce using rule 138 (varname -> IDENTIFIER .)
    do              reduce using rule 138 (varname -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 138 (varname -> IDENTIFIER .)

  ! OPEN_BRACKET    [ reduce using rule 138 (varname -> IDENTIFIER .) ]


state 153

    (40) term1 -> mlhs EQUALS mrhs .

    SEMI_COLON      reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    NEWLINE         reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    puts            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    print           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    gets            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    class           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    break           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    def             reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    if              reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    while           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    until           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    case            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    for             reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    return          reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    IDENTIFIER      reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    nil             reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    self            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    GLOBAL          reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    AT_THE_RATE     reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    MINUS           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    PLUS            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    OPEN_BRACKET    reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    Array           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    NUMBER          reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    FLOAT           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    STRING          reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    true            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    false           reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    $end            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    CLOSE_BRACKET   reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    then            reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)
    do              reduce using rule 40 (term1 -> mlhs EQUALS mrhs .)


state 154

    (104) mrhs -> term2 .

    SEMI_COLON      reduce using rule 104 (mrhs -> term2 .)
    NEWLINE         reduce using rule 104 (mrhs -> term2 .)
    puts            reduce using rule 104 (mrhs -> term2 .)
    print           reduce using rule 104 (mrhs -> term2 .)
    gets            reduce using rule 104 (mrhs -> term2 .)
    class           reduce using rule 104 (mrhs -> term2 .)
    break           reduce using rule 104 (mrhs -> term2 .)
    def             reduce using rule 104 (mrhs -> term2 .)
    if              reduce using rule 104 (mrhs -> term2 .)
    while           reduce using rule 104 (mrhs -> term2 .)
    until           reduce using rule 104 (mrhs -> term2 .)
    case            reduce using rule 104 (mrhs -> term2 .)
    for             reduce using rule 104 (mrhs -> term2 .)
    return          reduce using rule 104 (mrhs -> term2 .)
    IDENTIFIER      reduce using rule 104 (mrhs -> term2 .)
    nil             reduce using rule 104 (mrhs -> term2 .)
    self            reduce using rule 104 (mrhs -> term2 .)
    GLOBAL          reduce using rule 104 (mrhs -> term2 .)
    AT_THE_RATE     reduce using rule 104 (mrhs -> term2 .)
    MINUS           reduce using rule 104 (mrhs -> term2 .)
    PLUS            reduce using rule 104 (mrhs -> term2 .)
    OPEN_BRACKET    reduce using rule 104 (mrhs -> term2 .)
    Array           reduce using rule 104 (mrhs -> term2 .)
    NUMBER          reduce using rule 104 (mrhs -> term2 .)
    FLOAT           reduce using rule 104 (mrhs -> term2 .)
    STRING          reduce using rule 104 (mrhs -> term2 .)
    true            reduce using rule 104 (mrhs -> term2 .)
    false           reduce using rule 104 (mrhs -> term2 .)
    $end            reduce using rule 104 (mrhs -> term2 .)
    CLOSE_BRACKET   reduce using rule 104 (mrhs -> term2 .)
    then            reduce using rule 104 (mrhs -> term2 .)
    do              reduce using rule 104 (mrhs -> term2 .)


state 155

    (41) term1 -> mlhs opasgn mrhs .

    SEMI_COLON      reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    NEWLINE         reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    puts            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    print           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    gets            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    class           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    break           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    def             reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    if              reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    while           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    until           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    case            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    for             reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    return          reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    IDENTIFIER      reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    nil             reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    self            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    GLOBAL          reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    AT_THE_RATE     reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    MINUS           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    PLUS            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    OPEN_BRACKET    reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    Array           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    NUMBER          reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    FLOAT           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    STRING          reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    true            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    false           reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    $end            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    CLOSE_BRACKET   reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    then            reduce using rule 41 (term1 -> mlhs opasgn mrhs .)
    do              reduce using rule 41 (term1 -> mlhs opasgn mrhs .)


state 156

    (87) arraya -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (88) array_args -> . primary COMMA array_args
    (89) array_args -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    variable                       shift and go to state 98
    array_args                     shift and go to state 209
    primary                        shift and go to state 161
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97

state 157

    (43) term2 -> term3 INCL_RANGE term3 .
    (46) term3 -> term3 . LOGICAL_OR term4

    SEMI_COLON      reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    NEWLINE         reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    puts            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    print           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    gets            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    class           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    break           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    def             reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    if              reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    while           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    until           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    case            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    for             reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    return          reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    IDENTIFIER      reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    nil             reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    self            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    GLOBAL          reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    AT_THE_RATE     reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    MINUS           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    PLUS            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    OPEN_BRACKET    reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    Array           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    NUMBER          reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    FLOAT           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    STRING          reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    true            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    false           reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    $end            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    CLOSE_BRACKET   reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    then            reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    do              reduce using rule 43 (term2 -> term3 INCL_RANGE term3 .)
    LOGICAL_OR      shift and go to state 102


state 158

    (44) term2 -> term3 EXCL_RANGE term3 .
    (46) term3 -> term3 . LOGICAL_OR term4

    SEMI_COLON      reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    NEWLINE         reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    puts            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    print           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    gets            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    class           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    break           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    def             reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    if              reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    while           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    until           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    case            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    for             reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    return          reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    IDENTIFIER      reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    nil             reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    self            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    GLOBAL          reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    AT_THE_RATE     reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    MINUS           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    PLUS            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    OPEN_BRACKET    reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    Array           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    NUMBER          reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    FLOAT           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    STRING          reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    true            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    false           reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    $end            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    CLOSE_BRACKET   reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    then            reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    do              reduce using rule 44 (term2 -> term3 EXCL_RANGE term3 .)
    LOGICAL_OR      shift and go to state 102


state 159

    (46) term3 -> term3 LOGICAL_OR term4 .

    INCL_RANGE      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    EXCL_RANGE      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    LOGICAL_OR      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    SEMI_COLON      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    NEWLINE         reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    puts            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    print           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    gets            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    class           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    break           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    def             reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    if              reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    while           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    until           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    case            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    for             reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    return          reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    IDENTIFIER      reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    nil             reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    self            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    GLOBAL          reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    AT_THE_RATE     reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    MINUS           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    PLUS            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    OPEN_BRACKET    reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    Array           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    NUMBER          reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    FLOAT           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    STRING          reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    true            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    false           reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    $end            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    CLOSE_BRACKET   reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    then            reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)
    do              reduce using rule 46 (term3 -> term3 LOGICAL_OR term4 .)


state 160

    (86) arrayal -> variable OPEN_SQUARE array_args . CLOSE_SQUARE
    (87) arraya -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 210


state 161

    (88) array_args -> primary . COMMA array_args
    (89) array_args -> primary .

    COMMA           shift and go to state 211
    CLOSE_SQUARE    reduce using rule 89 (array_args -> primary .)


state 162

    (48) term4 -> term5 DOUBLE_EQUALS term5 .
    (53) term5 -> term5 . LESS term6
    (54) term5 -> term5 . LESS_EQUALS term6
    (55) term5 -> term5 . GREATER term6
    (56) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    EXCL_RANGE      reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    LOGICAL_OR      reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    SEMI_COLON      reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    NEWLINE         reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    puts            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    print           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    gets            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    class           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    break           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    def             reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    if              reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    while           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    until           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    case            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    for             reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    return          reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    IDENTIFIER      reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    nil             reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    self            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    GLOBAL          reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    AT_THE_RATE     reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    MINUS           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    PLUS            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    OPEN_BRACKET    reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    Array           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    NUMBER          reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    FLOAT           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    STRING          reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    true            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    false           reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    $end            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    CLOSE_BRACKET   reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    then            reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    do              reduce using rule 48 (term4 -> term5 DOUBLE_EQUALS term5 .)
    LESS            shift and go to state 108
    LESS_EQUALS     shift and go to state 109
    GREATER         shift and go to state 110
    GREATER_EQUALS  shift and go to state 111


state 163

    (49) term4 -> term5 NOT_EQUALS term5 .
    (53) term5 -> term5 . LESS term6
    (54) term5 -> term5 . LESS_EQUALS term6
    (55) term5 -> term5 . GREATER term6
    (56) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    EXCL_RANGE      reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    LOGICAL_OR      reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    SEMI_COLON      reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    NEWLINE         reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    puts            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    print           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    gets            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    class           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    break           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    def             reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    if              reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    while           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    until           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    case            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    for             reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    return          reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    IDENTIFIER      reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    nil             reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    self            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    GLOBAL          reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    AT_THE_RATE     reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    MINUS           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    PLUS            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    OPEN_BRACKET    reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    Array           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    NUMBER          reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    FLOAT           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    STRING          reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    true            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    false           reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    $end            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    CLOSE_BRACKET   reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    then            reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    do              reduce using rule 49 (term4 -> term5 NOT_EQUALS term5 .)
    LESS            shift and go to state 108
    LESS_EQUALS     shift and go to state 109
    GREATER         shift and go to state 110
    GREATER_EQUALS  shift and go to state 111


state 164

    (50) term4 -> term5 EQUAL_TILDE term5 .
    (53) term5 -> term5 . LESS term6
    (54) term5 -> term5 . LESS_EQUALS term6
    (55) term5 -> term5 . GREATER term6
    (56) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    EXCL_RANGE      reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    LOGICAL_OR      reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    SEMI_COLON      reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    NEWLINE         reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    puts            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    print           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    gets            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    class           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    break           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    def             reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    if              reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    while           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    until           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    case            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    for             reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    return          reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    IDENTIFIER      reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    nil             reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    self            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    GLOBAL          reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    AT_THE_RATE     reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    MINUS           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    PLUS            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    OPEN_BRACKET    reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    Array           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    NUMBER          reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    FLOAT           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    STRING          reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    true            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    false           reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    $end            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    CLOSE_BRACKET   reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    then            reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    do              reduce using rule 50 (term4 -> term5 EQUAL_TILDE term5 .)
    LESS            shift and go to state 108
    LESS_EQUALS     shift and go to state 109
    GREATER         shift and go to state 110
    GREATER_EQUALS  shift and go to state 111


state 165

    (51) term4 -> term5 COMPARISON term5 .
    (53) term5 -> term5 . LESS term6
    (54) term5 -> term5 . LESS_EQUALS term6
    (55) term5 -> term5 . GREATER term6
    (56) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    EXCL_RANGE      reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    LOGICAL_OR      reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    SEMI_COLON      reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    NEWLINE         reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    puts            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    print           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    gets            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    class           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    break           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    def             reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    if              reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    while           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    until           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    case            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    for             reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    return          reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    IDENTIFIER      reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    nil             reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    self            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    GLOBAL          reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    AT_THE_RATE     reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    MINUS           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    PLUS            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    OPEN_BRACKET    reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    Array           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    NUMBER          reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    FLOAT           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    STRING          reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    true            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    false           reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    $end            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    CLOSE_BRACKET   reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    then            reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    do              reduce using rule 51 (term4 -> term5 COMPARISON term5 .)
    LESS            shift and go to state 108
    LESS_EQUALS     shift and go to state 109
    GREATER         shift and go to state 110
    GREATER_EQUALS  shift and go to state 111


state 166

    (53) term5 -> term5 LESS term6 .
    (58) term6 -> term6 . BIT_XOR term7
    (59) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 53 (term5 -> term5 LESS term6 .)
    NOT_EQUALS      reduce using rule 53 (term5 -> term5 LESS term6 .)
    EQUAL_TILDE     reduce using rule 53 (term5 -> term5 LESS term6 .)
    COMPARISON      reduce using rule 53 (term5 -> term5 LESS term6 .)
    LESS            reduce using rule 53 (term5 -> term5 LESS term6 .)
    LESS_EQUALS     reduce using rule 53 (term5 -> term5 LESS term6 .)
    GREATER         reduce using rule 53 (term5 -> term5 LESS term6 .)
    GREATER_EQUALS  reduce using rule 53 (term5 -> term5 LESS term6 .)
    INCL_RANGE      reduce using rule 53 (term5 -> term5 LESS term6 .)
    EXCL_RANGE      reduce using rule 53 (term5 -> term5 LESS term6 .)
    LOGICAL_OR      reduce using rule 53 (term5 -> term5 LESS term6 .)
    SEMI_COLON      reduce using rule 53 (term5 -> term5 LESS term6 .)
    NEWLINE         reduce using rule 53 (term5 -> term5 LESS term6 .)
    puts            reduce using rule 53 (term5 -> term5 LESS term6 .)
    print           reduce using rule 53 (term5 -> term5 LESS term6 .)
    gets            reduce using rule 53 (term5 -> term5 LESS term6 .)
    class           reduce using rule 53 (term5 -> term5 LESS term6 .)
    break           reduce using rule 53 (term5 -> term5 LESS term6 .)
    def             reduce using rule 53 (term5 -> term5 LESS term6 .)
    if              reduce using rule 53 (term5 -> term5 LESS term6 .)
    while           reduce using rule 53 (term5 -> term5 LESS term6 .)
    until           reduce using rule 53 (term5 -> term5 LESS term6 .)
    case            reduce using rule 53 (term5 -> term5 LESS term6 .)
    for             reduce using rule 53 (term5 -> term5 LESS term6 .)
    return          reduce using rule 53 (term5 -> term5 LESS term6 .)
    IDENTIFIER      reduce using rule 53 (term5 -> term5 LESS term6 .)
    nil             reduce using rule 53 (term5 -> term5 LESS term6 .)
    self            reduce using rule 53 (term5 -> term5 LESS term6 .)
    GLOBAL          reduce using rule 53 (term5 -> term5 LESS term6 .)
    AT_THE_RATE     reduce using rule 53 (term5 -> term5 LESS term6 .)
    MINUS           reduce using rule 53 (term5 -> term5 LESS term6 .)
    PLUS            reduce using rule 53 (term5 -> term5 LESS term6 .)
    OPEN_BRACKET    reduce using rule 53 (term5 -> term5 LESS term6 .)
    Array           reduce using rule 53 (term5 -> term5 LESS term6 .)
    NUMBER          reduce using rule 53 (term5 -> term5 LESS term6 .)
    FLOAT           reduce using rule 53 (term5 -> term5 LESS term6 .)
    STRING          reduce using rule 53 (term5 -> term5 LESS term6 .)
    true            reduce using rule 53 (term5 -> term5 LESS term6 .)
    false           reduce using rule 53 (term5 -> term5 LESS term6 .)
    $end            reduce using rule 53 (term5 -> term5 LESS term6 .)
    CLOSE_BRACKET   reduce using rule 53 (term5 -> term5 LESS term6 .)
    then            reduce using rule 53 (term5 -> term5 LESS term6 .)
    do              reduce using rule 53 (term5 -> term5 LESS term6 .)
    BIT_XOR         shift and go to state 113
    BIT_OR          shift and go to state 114


state 167

    (54) term5 -> term5 LESS_EQUALS term6 .
    (58) term6 -> term6 . BIT_XOR term7
    (59) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    NOT_EQUALS      reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    EQUAL_TILDE     reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    COMPARISON      reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    LESS            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    LESS_EQUALS     reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    GREATER         reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    GREATER_EQUALS  reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    INCL_RANGE      reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    EXCL_RANGE      reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    LOGICAL_OR      reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    SEMI_COLON      reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    NEWLINE         reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    puts            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    print           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    gets            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    class           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    break           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    def             reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    if              reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    while           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    until           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    case            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    for             reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    return          reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    IDENTIFIER      reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    nil             reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    self            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    GLOBAL          reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    AT_THE_RATE     reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    MINUS           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    PLUS            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    OPEN_BRACKET    reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    Array           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    NUMBER          reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    FLOAT           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    STRING          reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    true            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    false           reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    $end            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    CLOSE_BRACKET   reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    then            reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    do              reduce using rule 54 (term5 -> term5 LESS_EQUALS term6 .)
    BIT_XOR         shift and go to state 113
    BIT_OR          shift and go to state 114


state 168

    (55) term5 -> term5 GREATER term6 .
    (58) term6 -> term6 . BIT_XOR term7
    (59) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 55 (term5 -> term5 GREATER term6 .)
    NOT_EQUALS      reduce using rule 55 (term5 -> term5 GREATER term6 .)
    EQUAL_TILDE     reduce using rule 55 (term5 -> term5 GREATER term6 .)
    COMPARISON      reduce using rule 55 (term5 -> term5 GREATER term6 .)
    LESS            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    LESS_EQUALS     reduce using rule 55 (term5 -> term5 GREATER term6 .)
    GREATER         reduce using rule 55 (term5 -> term5 GREATER term6 .)
    GREATER_EQUALS  reduce using rule 55 (term5 -> term5 GREATER term6 .)
    INCL_RANGE      reduce using rule 55 (term5 -> term5 GREATER term6 .)
    EXCL_RANGE      reduce using rule 55 (term5 -> term5 GREATER term6 .)
    LOGICAL_OR      reduce using rule 55 (term5 -> term5 GREATER term6 .)
    SEMI_COLON      reduce using rule 55 (term5 -> term5 GREATER term6 .)
    NEWLINE         reduce using rule 55 (term5 -> term5 GREATER term6 .)
    puts            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    print           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    gets            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    class           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    break           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    def             reduce using rule 55 (term5 -> term5 GREATER term6 .)
    if              reduce using rule 55 (term5 -> term5 GREATER term6 .)
    while           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    until           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    case            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    for             reduce using rule 55 (term5 -> term5 GREATER term6 .)
    return          reduce using rule 55 (term5 -> term5 GREATER term6 .)
    IDENTIFIER      reduce using rule 55 (term5 -> term5 GREATER term6 .)
    nil             reduce using rule 55 (term5 -> term5 GREATER term6 .)
    self            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    GLOBAL          reduce using rule 55 (term5 -> term5 GREATER term6 .)
    AT_THE_RATE     reduce using rule 55 (term5 -> term5 GREATER term6 .)
    MINUS           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    PLUS            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    OPEN_BRACKET    reduce using rule 55 (term5 -> term5 GREATER term6 .)
    Array           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    NUMBER          reduce using rule 55 (term5 -> term5 GREATER term6 .)
    FLOAT           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    STRING          reduce using rule 55 (term5 -> term5 GREATER term6 .)
    true            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    false           reduce using rule 55 (term5 -> term5 GREATER term6 .)
    $end            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    CLOSE_BRACKET   reduce using rule 55 (term5 -> term5 GREATER term6 .)
    then            reduce using rule 55 (term5 -> term5 GREATER term6 .)
    do              reduce using rule 55 (term5 -> term5 GREATER term6 .)
    BIT_XOR         shift and go to state 113
    BIT_OR          shift and go to state 114


state 169

    (56) term5 -> term5 GREATER_EQUALS term6 .
    (58) term6 -> term6 . BIT_XOR term7
    (59) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    NOT_EQUALS      reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    EQUAL_TILDE     reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    COMPARISON      reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    LESS            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    LESS_EQUALS     reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    GREATER         reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    GREATER_EQUALS  reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    INCL_RANGE      reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    EXCL_RANGE      reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    LOGICAL_OR      reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    SEMI_COLON      reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    NEWLINE         reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    puts            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    print           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    gets            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    class           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    break           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    def             reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    if              reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    while           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    until           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    case            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    for             reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    return          reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    IDENTIFIER      reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    nil             reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    self            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    GLOBAL          reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    AT_THE_RATE     reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    MINUS           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    PLUS            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    OPEN_BRACKET    reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    Array           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    NUMBER          reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    FLOAT           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    STRING          reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    true            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    false           reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    $end            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    CLOSE_BRACKET   reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    then            reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    do              reduce using rule 56 (term5 -> term5 GREATER_EQUALS term6 .)
    BIT_XOR         shift and go to state 113
    BIT_OR          shift and go to state 114


state 170

    (58) term6 -> term6 BIT_XOR term7 .
    (61) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    BIT_OR          reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    DOUBLE_EQUALS   reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    NOT_EQUALS      reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    EQUAL_TILDE     reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    COMPARISON      reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    LESS            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    LESS_EQUALS     reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    GREATER         reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    GREATER_EQUALS  reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    INCL_RANGE      reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    EXCL_RANGE      reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    LOGICAL_OR      reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    SEMI_COLON      reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    NEWLINE         reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    puts            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    print           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    gets            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    class           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    break           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    def             reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    if              reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    while           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    until           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    case            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    for             reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    return          reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    IDENTIFIER      reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    nil             reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    self            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    GLOBAL          reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    AT_THE_RATE     reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    MINUS           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    PLUS            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    OPEN_BRACKET    reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    Array           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    NUMBER          reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    FLOAT           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    STRING          reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    true            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    false           reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    $end            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    CLOSE_BRACKET   reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    then            reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    do              reduce using rule 58 (term6 -> term6 BIT_XOR term7 .)
    BIT_AND         shift and go to state 115


state 171

    (59) term6 -> term6 BIT_OR term7 .
    (61) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    BIT_OR          reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    DOUBLE_EQUALS   reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    NOT_EQUALS      reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    EQUAL_TILDE     reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    COMPARISON      reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    LESS            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    LESS_EQUALS     reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    GREATER         reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    GREATER_EQUALS  reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    INCL_RANGE      reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    EXCL_RANGE      reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    LOGICAL_OR      reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    SEMI_COLON      reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    NEWLINE         reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    puts            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    print           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    gets            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    class           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    break           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    def             reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    if              reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    while           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    until           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    case            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    for             reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    return          reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    IDENTIFIER      reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    nil             reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    self            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    GLOBAL          reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    AT_THE_RATE     reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    MINUS           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    PLUS            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    OPEN_BRACKET    reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    Array           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    NUMBER          reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    FLOAT           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    STRING          reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    true            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    false           reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    $end            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    CLOSE_BRACKET   reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    then            reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    do              reduce using rule 59 (term6 -> term6 BIT_OR term7 .)
    BIT_AND         shift and go to state 115


state 172

    (61) term7 -> term7 BIT_AND term8 .
    (63) term8 -> term8 . LEFT_SHIFT term9
    (64) term8 -> term8 . RIGHT_SHIFT term9

    BIT_AND         reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    BIT_XOR         reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    BIT_OR          reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    DOUBLE_EQUALS   reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    NOT_EQUALS      reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    EQUAL_TILDE     reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    COMPARISON      reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    LESS            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    LESS_EQUALS     reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    GREATER         reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    GREATER_EQUALS  reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    INCL_RANGE      reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    EXCL_RANGE      reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    LOGICAL_OR      reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    SEMI_COLON      reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    NEWLINE         reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    puts            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    print           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    gets            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    class           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    break           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    def             reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    if              reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    while           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    until           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    case            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    for             reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    return          reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    IDENTIFIER      reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    nil             reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    self            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    GLOBAL          reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    AT_THE_RATE     reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    MINUS           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    PLUS            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    OPEN_BRACKET    reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    Array           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    NUMBER          reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    FLOAT           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    STRING          reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    true            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    false           reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    $end            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    CLOSE_BRACKET   reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    then            reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    do              reduce using rule 61 (term7 -> term7 BIT_AND term8 .)
    LEFT_SHIFT      shift and go to state 116
    RIGHT_SHIFT     shift and go to state 117


state 173

    (63) term8 -> term8 LEFT_SHIFT term9 .
    (66) term9 -> term9 . PLUS term10
    (67) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    RIGHT_SHIFT     reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_AND         reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_XOR         reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_OR          reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    DOUBLE_EQUALS   reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    NOT_EQUALS      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    EQUAL_TILDE     reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    COMPARISON      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    LESS            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    LESS_EQUALS     reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    GREATER         reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    GREATER_EQUALS  reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    INCL_RANGE      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    EXCL_RANGE      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    LOGICAL_OR      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    SEMI_COLON      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    NEWLINE         reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    puts            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    print           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    gets            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    class           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    break           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    def             reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    if              reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    while           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    until           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    case            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    for             reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    return          reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    IDENTIFIER      reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    nil             reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    self            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    GLOBAL          reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    AT_THE_RATE     reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    OPEN_BRACKET    reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    Array           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    NUMBER          reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    FLOAT           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    STRING          reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    true            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    false           reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    $end            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    CLOSE_BRACKET   reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    then            reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    do              reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119

  ! MINUS           [ reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .) ]
  ! PLUS            [ reduce using rule 63 (term8 -> term8 LEFT_SHIFT term9 .) ]


state 174

    (64) term8 -> term8 RIGHT_SHIFT term9 .
    (66) term9 -> term9 . PLUS term10
    (67) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    RIGHT_SHIFT     reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_AND         reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_XOR         reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_OR          reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    DOUBLE_EQUALS   reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    NOT_EQUALS      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    EQUAL_TILDE     reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    COMPARISON      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    LESS            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    LESS_EQUALS     reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    GREATER         reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    GREATER_EQUALS  reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    INCL_RANGE      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    EXCL_RANGE      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    LOGICAL_OR      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    SEMI_COLON      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    NEWLINE         reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    puts            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    print           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    gets            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    class           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    break           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    def             reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    if              reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    while           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    until           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    case            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    for             reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    return          reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    IDENTIFIER      reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    nil             reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    self            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    GLOBAL          reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    AT_THE_RATE     reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    OPEN_BRACKET    reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    Array           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    NUMBER          reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    FLOAT           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    STRING          reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    true            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    false           reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    $end            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    CLOSE_BRACKET   reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    then            reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    do              reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119

  ! MINUS           [ reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .) ]
  ! PLUS            [ reduce using rule 64 (term8 -> term8 RIGHT_SHIFT term9 .) ]


state 175

    (66) term9 -> term9 PLUS term10 .
    (69) term10 -> term10 . MULTIPLY term11
    (70) term10 -> term10 . DIVIDE term11
    (71) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    MINUS           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    LEFT_SHIFT      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    RIGHT_SHIFT     reduce using rule 66 (term9 -> term9 PLUS term10 .)
    BIT_AND         reduce using rule 66 (term9 -> term9 PLUS term10 .)
    BIT_XOR         reduce using rule 66 (term9 -> term9 PLUS term10 .)
    BIT_OR          reduce using rule 66 (term9 -> term9 PLUS term10 .)
    DOUBLE_EQUALS   reduce using rule 66 (term9 -> term9 PLUS term10 .)
    NOT_EQUALS      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    EQUAL_TILDE     reduce using rule 66 (term9 -> term9 PLUS term10 .)
    COMPARISON      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    LESS            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    LESS_EQUALS     reduce using rule 66 (term9 -> term9 PLUS term10 .)
    GREATER         reduce using rule 66 (term9 -> term9 PLUS term10 .)
    GREATER_EQUALS  reduce using rule 66 (term9 -> term9 PLUS term10 .)
    INCL_RANGE      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    EXCL_RANGE      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    LOGICAL_OR      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    SEMI_COLON      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    NEWLINE         reduce using rule 66 (term9 -> term9 PLUS term10 .)
    puts            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    print           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    gets            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    class           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    break           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    def             reduce using rule 66 (term9 -> term9 PLUS term10 .)
    if              reduce using rule 66 (term9 -> term9 PLUS term10 .)
    while           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    until           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    case            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    for             reduce using rule 66 (term9 -> term9 PLUS term10 .)
    return          reduce using rule 66 (term9 -> term9 PLUS term10 .)
    IDENTIFIER      reduce using rule 66 (term9 -> term9 PLUS term10 .)
    nil             reduce using rule 66 (term9 -> term9 PLUS term10 .)
    self            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    GLOBAL          reduce using rule 66 (term9 -> term9 PLUS term10 .)
    AT_THE_RATE     reduce using rule 66 (term9 -> term9 PLUS term10 .)
    OPEN_BRACKET    reduce using rule 66 (term9 -> term9 PLUS term10 .)
    Array           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    NUMBER          reduce using rule 66 (term9 -> term9 PLUS term10 .)
    FLOAT           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    STRING          reduce using rule 66 (term9 -> term9 PLUS term10 .)
    true            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    false           reduce using rule 66 (term9 -> term9 PLUS term10 .)
    $end            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    CLOSE_BRACKET   reduce using rule 66 (term9 -> term9 PLUS term10 .)
    then            reduce using rule 66 (term9 -> term9 PLUS term10 .)
    do              reduce using rule 66 (term9 -> term9 PLUS term10 .)
    MULTIPLY        shift and go to state 121
    DIVIDE          shift and go to state 122
    MODULO          shift and go to state 123


state 176

    (67) term9 -> term9 MINUS term10 .
    (69) term10 -> term10 . MULTIPLY term11
    (70) term10 -> term10 . DIVIDE term11
    (71) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    MINUS           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    LEFT_SHIFT      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    RIGHT_SHIFT     reduce using rule 67 (term9 -> term9 MINUS term10 .)
    BIT_AND         reduce using rule 67 (term9 -> term9 MINUS term10 .)
    BIT_XOR         reduce using rule 67 (term9 -> term9 MINUS term10 .)
    BIT_OR          reduce using rule 67 (term9 -> term9 MINUS term10 .)
    DOUBLE_EQUALS   reduce using rule 67 (term9 -> term9 MINUS term10 .)
    NOT_EQUALS      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    EQUAL_TILDE     reduce using rule 67 (term9 -> term9 MINUS term10 .)
    COMPARISON      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    LESS            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    LESS_EQUALS     reduce using rule 67 (term9 -> term9 MINUS term10 .)
    GREATER         reduce using rule 67 (term9 -> term9 MINUS term10 .)
    GREATER_EQUALS  reduce using rule 67 (term9 -> term9 MINUS term10 .)
    INCL_RANGE      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    EXCL_RANGE      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    LOGICAL_OR      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    SEMI_COLON      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    NEWLINE         reduce using rule 67 (term9 -> term9 MINUS term10 .)
    puts            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    print           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    gets            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    class           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    break           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    def             reduce using rule 67 (term9 -> term9 MINUS term10 .)
    if              reduce using rule 67 (term9 -> term9 MINUS term10 .)
    while           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    until           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    case            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    for             reduce using rule 67 (term9 -> term9 MINUS term10 .)
    return          reduce using rule 67 (term9 -> term9 MINUS term10 .)
    IDENTIFIER      reduce using rule 67 (term9 -> term9 MINUS term10 .)
    nil             reduce using rule 67 (term9 -> term9 MINUS term10 .)
    self            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    GLOBAL          reduce using rule 67 (term9 -> term9 MINUS term10 .)
    AT_THE_RATE     reduce using rule 67 (term9 -> term9 MINUS term10 .)
    OPEN_BRACKET    reduce using rule 67 (term9 -> term9 MINUS term10 .)
    Array           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    NUMBER          reduce using rule 67 (term9 -> term9 MINUS term10 .)
    FLOAT           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    STRING          reduce using rule 67 (term9 -> term9 MINUS term10 .)
    true            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    false           reduce using rule 67 (term9 -> term9 MINUS term10 .)
    $end            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    CLOSE_BRACKET   reduce using rule 67 (term9 -> term9 MINUS term10 .)
    then            reduce using rule 67 (term9 -> term9 MINUS term10 .)
    do              reduce using rule 67 (term9 -> term9 MINUS term10 .)
    MULTIPLY        shift and go to state 121
    DIVIDE          shift and go to state 122
    MODULO          shift and go to state 123


state 177

    (69) term10 -> term10 MULTIPLY term11 .

    MULTIPLY        reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    DIVIDE          reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    MODULO          reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    PLUS            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    MINUS           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    LEFT_SHIFT      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    RIGHT_SHIFT     reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    BIT_AND         reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    BIT_XOR         reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    BIT_OR          reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    DOUBLE_EQUALS   reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    NOT_EQUALS      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    EQUAL_TILDE     reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    COMPARISON      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    LESS            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    LESS_EQUALS     reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    GREATER         reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    GREATER_EQUALS  reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    INCL_RANGE      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    EXCL_RANGE      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    LOGICAL_OR      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    SEMI_COLON      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    NEWLINE         reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    puts            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    print           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    gets            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    class           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    break           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    def             reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    if              reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    while           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    until           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    case            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    for             reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    return          reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    IDENTIFIER      reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    nil             reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    self            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    GLOBAL          reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    AT_THE_RATE     reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    OPEN_BRACKET    reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    Array           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    NUMBER          reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    FLOAT           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    STRING          reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    true            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    false           reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    $end            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    CLOSE_BRACKET   reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    then            reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)
    do              reduce using rule 69 (term10 -> term10 MULTIPLY term11 .)


state 178

    (70) term10 -> term10 DIVIDE term11 .

    MULTIPLY        reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    DIVIDE          reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    MODULO          reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    PLUS            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    MINUS           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    LEFT_SHIFT      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    RIGHT_SHIFT     reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    BIT_AND         reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    BIT_XOR         reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    BIT_OR          reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    DOUBLE_EQUALS   reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    NOT_EQUALS      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    EQUAL_TILDE     reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    COMPARISON      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    LESS            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    LESS_EQUALS     reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    GREATER         reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    GREATER_EQUALS  reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    INCL_RANGE      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    EXCL_RANGE      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    LOGICAL_OR      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    SEMI_COLON      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    NEWLINE         reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    puts            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    print           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    gets            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    class           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    break           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    def             reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    if              reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    while           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    until           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    case            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    for             reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    return          reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    IDENTIFIER      reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    nil             reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    self            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    GLOBAL          reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    AT_THE_RATE     reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    OPEN_BRACKET    reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    Array           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    NUMBER          reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    FLOAT           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    STRING          reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    true            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    false           reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    $end            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    CLOSE_BRACKET   reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    then            reduce using rule 70 (term10 -> term10 DIVIDE term11 .)
    do              reduce using rule 70 (term10 -> term10 DIVIDE term11 .)


state 179

    (71) term10 -> term10 MODULO term11 .

    MULTIPLY        reduce using rule 71 (term10 -> term10 MODULO term11 .)
    DIVIDE          reduce using rule 71 (term10 -> term10 MODULO term11 .)
    MODULO          reduce using rule 71 (term10 -> term10 MODULO term11 .)
    PLUS            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    MINUS           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    LEFT_SHIFT      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    RIGHT_SHIFT     reduce using rule 71 (term10 -> term10 MODULO term11 .)
    BIT_AND         reduce using rule 71 (term10 -> term10 MODULO term11 .)
    BIT_XOR         reduce using rule 71 (term10 -> term10 MODULO term11 .)
    BIT_OR          reduce using rule 71 (term10 -> term10 MODULO term11 .)
    DOUBLE_EQUALS   reduce using rule 71 (term10 -> term10 MODULO term11 .)
    NOT_EQUALS      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    EQUAL_TILDE     reduce using rule 71 (term10 -> term10 MODULO term11 .)
    COMPARISON      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    LESS            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    LESS_EQUALS     reduce using rule 71 (term10 -> term10 MODULO term11 .)
    GREATER         reduce using rule 71 (term10 -> term10 MODULO term11 .)
    GREATER_EQUALS  reduce using rule 71 (term10 -> term10 MODULO term11 .)
    INCL_RANGE      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    EXCL_RANGE      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    LOGICAL_OR      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    SEMI_COLON      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    NEWLINE         reduce using rule 71 (term10 -> term10 MODULO term11 .)
    puts            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    print           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    gets            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    class           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    break           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    def             reduce using rule 71 (term10 -> term10 MODULO term11 .)
    if              reduce using rule 71 (term10 -> term10 MODULO term11 .)
    while           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    until           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    case            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    for             reduce using rule 71 (term10 -> term10 MODULO term11 .)
    return          reduce using rule 71 (term10 -> term10 MODULO term11 .)
    IDENTIFIER      reduce using rule 71 (term10 -> term10 MODULO term11 .)
    nil             reduce using rule 71 (term10 -> term10 MODULO term11 .)
    self            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    GLOBAL          reduce using rule 71 (term10 -> term10 MODULO term11 .)
    AT_THE_RATE     reduce using rule 71 (term10 -> term10 MODULO term11 .)
    OPEN_BRACKET    reduce using rule 71 (term10 -> term10 MODULO term11 .)
    Array           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    NUMBER          reduce using rule 71 (term10 -> term10 MODULO term11 .)
    FLOAT           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    STRING          reduce using rule 71 (term10 -> term10 MODULO term11 .)
    true            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    false           reduce using rule 71 (term10 -> term10 MODULO term11 .)
    $end            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    CLOSE_BRACKET   reduce using rule 71 (term10 -> term10 MODULO term11 .)
    then            reduce using rule 71 (term10 -> term10 MODULO term11 .)
    do              reduce using rule 71 (term10 -> term10 MODULO term11 .)


state 180

    (83) arrayd -> Array OPEN_BRACKET array_size . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 212


state 181

    (84) array_size -> primary . COMMA array_size
    (85) array_size -> primary .

    COMMA           shift and go to state 213
    CLOSE_BRACKET   reduce using rule 85 (array_size -> primary .)


state 182

    (7) stmt -> keydef argdecl newline multstmt . keyend
    (16) keyend -> . end

    end             shift and go to state 215

    keyend                         shift and go to state 214

state 183

    (17) multstmt -> stmt . newline multstmt
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 216

state 184

    (18) multstmt -> empty .

    end             reduce using rule 18 (multstmt -> empty .)
    else            reduce using rule 18 (multstmt -> empty .)
    elsif           reduce using rule 18 (multstmt -> empty .)
    when            reduce using rule 18 (multstmt -> empty .)


state 185

    (110) argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 110 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    NEWLINE         reduce using rule 110 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)


state 186

    (111) arglist -> IDENTIFIER multarglist .

    CLOSE_BRACKET   reduce using rule 111 (arglist -> IDENTIFIER multarglist .)


state 187

    (113) multarglist -> COMMA . IDENTIFIER multarglist

    IDENTIFIER      shift and go to state 217


state 188

    (114) multarglist -> empty .

    CLOSE_BRACKET   reduce using rule 114 (multarglist -> empty .)


state 189

    (8) stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    NEWLINE         reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    puts            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    print           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    gets            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    class           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    break           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    def             reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    if              reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    while           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    until           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    case            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    for             reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    return          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    nil             reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    self            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    GLOBAL          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    MINUS           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    PLUS            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    Array           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    NUMBER          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    FLOAT           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    STRING          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    true            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    false           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    $end            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)


state 190

    (9) stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    NEWLINE         reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    puts            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    print           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    gets            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    class           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    break           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    def             reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    if              reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    while           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    until           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    case            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    for             reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    return          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    nil             reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    self            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    GLOBAL          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    MINUS           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    PLUS            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    Array           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    NUMBER          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    FLOAT           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    STRING          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    true            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    false           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    $end            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)


state 191

    (10) stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    NEWLINE         reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    puts            reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    print           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    gets            reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    class           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    break           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    def             reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    if              reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    while           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    until           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    case            reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    for             reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    return          reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    nil             reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    self            reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    GLOBAL          reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    MINUS           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    PLUS            reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    Array           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    NUMBER          reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    FLOAT           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    STRING          reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    true            reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    false           reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)
    $end            reduce using rule 10 (stmt -> gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET .)


state 192

    (34) function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NEWLINE         reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    puts            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    print           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    gets            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    class           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    break           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    def             reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    if              reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    while           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    until           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    case            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    for             reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    return          reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    nil             reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    self            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    GLOBAL          reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    MINUS           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    PLUS            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    Array           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NUMBER          reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    FLOAT           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    STRING          reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    true            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    false           reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    $end            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    then            reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    do              reduce using rule 34 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)


state 193

    (106) callarglist -> primary callmultarglist .

    CLOSE_BRACKET   reduce using rule 106 (callarglist -> primary callmultarglist .)


state 194

    (108) callmultarglist -> COMMA . primary callmultarglist
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    primary                        shift and go to state 218
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 195

    (109) callmultarglist -> empty .

    CLOSE_BRACKET   reduce using rule 109 (callmultarglist -> empty .)


state 196

    (11) stmt -> class IDENTIFIER newline multstmt . end

    end             shift and go to state 219


state 197

    (12) stmt -> class IDENTIFIER LESS IDENTIFIER . newline multstmt end
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 220

state 198

    (19) expr -> if expr1 pthen M_1 . multstmt else newline M_1 multstmt end M_1
    (20) expr -> if expr1 pthen M_1 . multstmt M_1 multelsif end M_1
    (21) expr -> if expr1 pthen M_1 . multstmt end M_1
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 22
    multstmt                       shift and go to state 221
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 199

    (120) pthen -> newline then .

    puts            reduce using rule 120 (pthen -> newline then .)
    print           reduce using rule 120 (pthen -> newline then .)
    gets            reduce using rule 120 (pthen -> newline then .)
    class           reduce using rule 120 (pthen -> newline then .)
    break           reduce using rule 120 (pthen -> newline then .)
    def             reduce using rule 120 (pthen -> newline then .)
    if              reduce using rule 120 (pthen -> newline then .)
    while           reduce using rule 120 (pthen -> newline then .)
    until           reduce using rule 120 (pthen -> newline then .)
    case            reduce using rule 120 (pthen -> newline then .)
    for             reduce using rule 120 (pthen -> newline then .)
    return          reduce using rule 120 (pthen -> newline then .)
    IDENTIFIER      reduce using rule 120 (pthen -> newline then .)
    nil             reduce using rule 120 (pthen -> newline then .)
    self            reduce using rule 120 (pthen -> newline then .)
    GLOBAL          reduce using rule 120 (pthen -> newline then .)
    AT_THE_RATE     reduce using rule 120 (pthen -> newline then .)
    MINUS           reduce using rule 120 (pthen -> newline then .)
    PLUS            reduce using rule 120 (pthen -> newline then .)
    OPEN_BRACKET    reduce using rule 120 (pthen -> newline then .)
    Array           reduce using rule 120 (pthen -> newline then .)
    NUMBER          reduce using rule 120 (pthen -> newline then .)
    FLOAT           reduce using rule 120 (pthen -> newline then .)
    STRING          reduce using rule 120 (pthen -> newline then .)
    true            reduce using rule 120 (pthen -> newline then .)
    false           reduce using rule 120 (pthen -> newline then .)
    else            reduce using rule 120 (pthen -> newline then .)
    end             reduce using rule 120 (pthen -> newline then .)
    elsif           reduce using rule 120 (pthen -> newline then .)
    when            reduce using rule 120 (pthen -> newline then .)


state 200

    (22) expr -> while M_1 expr1 pdo . M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 222
    empty                          shift and go to state 78

state 201

    (121) pdo -> newline .
    (123) pdo -> newline . do

    puts            reduce using rule 121 (pdo -> newline .)
    print           reduce using rule 121 (pdo -> newline .)
    gets            reduce using rule 121 (pdo -> newline .)
    class           reduce using rule 121 (pdo -> newline .)
    break           reduce using rule 121 (pdo -> newline .)
    def             reduce using rule 121 (pdo -> newline .)
    if              reduce using rule 121 (pdo -> newline .)
    while           reduce using rule 121 (pdo -> newline .)
    until           reduce using rule 121 (pdo -> newline .)
    case            reduce using rule 121 (pdo -> newline .)
    for             reduce using rule 121 (pdo -> newline .)
    return          reduce using rule 121 (pdo -> newline .)
    IDENTIFIER      reduce using rule 121 (pdo -> newline .)
    nil             reduce using rule 121 (pdo -> newline .)
    self            reduce using rule 121 (pdo -> newline .)
    GLOBAL          reduce using rule 121 (pdo -> newline .)
    AT_THE_RATE     reduce using rule 121 (pdo -> newline .)
    MINUS           reduce using rule 121 (pdo -> newline .)
    PLUS            reduce using rule 121 (pdo -> newline .)
    OPEN_BRACKET    reduce using rule 121 (pdo -> newline .)
    Array           reduce using rule 121 (pdo -> newline .)
    NUMBER          reduce using rule 121 (pdo -> newline .)
    FLOAT           reduce using rule 121 (pdo -> newline .)
    STRING          reduce using rule 121 (pdo -> newline .)
    true            reduce using rule 121 (pdo -> newline .)
    false           reduce using rule 121 (pdo -> newline .)
    end             reduce using rule 121 (pdo -> newline .)
    do              shift and go to state 223


state 202

    (122) pdo -> do . newline
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 224

state 203

    (23) expr -> until M_1 expr1 pdo . M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 225
    empty                          shift and go to state 78

state 204

    (24) expr -> case expr1 newline multcase . end M_1

    end             shift and go to state 226


state 205

    (90) multcase -> when . whenargs pthen M_1 multstmt M_1 multcase
    (91) multcase -> when . whenargs pthen M_1 multstmt M_1
    (100) whenargs -> . arg
    (36) arg -> . term0
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    IDENTIFIER      shift and go to state 149
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    whenargs                       shift and go to state 227
    arg                            shift and go to state 228
    term0                          shift and go to state 33
    mlhs                           shift and go to state 27
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    term2                          shift and go to state 29
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 206

    (25) expr -> for M_1 mlhs in . expr1 pdo M_1 multstmt end M_1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    mlhs                           shift and go to state 27
    expr1                          shift and go to state 229
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 207

    (86) arrayal -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (88) array_args -> . primary COMMA array_args
    (89) array_args -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    variable                       shift and go to state 98
    array_args                     shift and go to state 230
    primary                        shift and go to state 161
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97

state 208

    (37) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET . CLOSE_BRACKET
    (38) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET . callargs CLOSE_BRACKET
    (105) callargs -> . callarglist
    (106) callarglist -> . primary callmultarglist
    (107) callarglist -> . empty
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (141) empty -> .
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

  ! shift/reduce conflict for CLOSE_BRACKET resolved as shift
    CLOSE_BRACKET   shift and go to state 231
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

  ! CLOSE_BRACKET   [ reduce using rule 141 (empty -> .) ]

    callargs                       shift and go to state 232
    callarglist                    shift and go to state 137
    primary                        shift and go to state 138
    empty                          shift and go to state 139
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 209

    (87) arraya -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 233


state 210

    (86) arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .
    (87) arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    EQUALS          reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO_EQUALS   reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE_EQUALS   reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS_EQUALS    reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS_EQUALS     reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OR_EQUALS       reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    AND_EQUALS      reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    XOR_EQUALS      reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT_EQUALS reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT_EQUALS reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MULTIPLY_EQUALS reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_AND_EQUALS reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR_EQUALS reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MULTIPLY        reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_AND         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_XOR         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_OR          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DOUBLE_EQUALS   reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NOT_EQUALS      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EQUAL_TILDE     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMPARISON      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS_EQUALS     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER_EQUALS  reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    INCL_RANGE      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EXCL_RANGE      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    SEMI_COLON      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NEWLINE         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    puts            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    print           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    gets            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    class           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    break           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    def             reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    if              reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    while           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    until           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    case            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    for             reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    return          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    IDENTIFIER      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    nil             reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    self            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GLOBAL          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    AT_THE_RATE     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OPEN_BRACKET    reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    Array           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NUMBER          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    FLOAT           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    STRING          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    true            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    false           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    $end            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_BRACKET   reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    then            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    do              reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 211

    (88) array_args -> primary COMMA . array_args
    (88) array_args -> . primary COMMA array_args
    (89) array_args -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    primary                        shift and go to state 161
    array_args                     shift and go to state 234
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 212

    (83) arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .

    MULTIPLY        reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    DIVIDE          reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    MODULO          reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    PLUS            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    MINUS           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LEFT_SHIFT      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    RIGHT_SHIFT     reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_AND         reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_XOR         reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_OR          reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    DOUBLE_EQUALS   reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NOT_EQUALS      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    EQUAL_TILDE     reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    COMPARISON      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LESS            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LESS_EQUALS     reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GREATER         reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GREATER_EQUALS  reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    INCL_RANGE      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    EXCL_RANGE      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LOGICAL_OR      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    SEMI_COLON      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NEWLINE         reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    puts            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    print           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    gets            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    class           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    break           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    def             reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    if              reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    while           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    until           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    case            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    for             reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    return          reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    nil             reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    self            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GLOBAL          reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    Array           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NUMBER          reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    FLOAT           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    STRING          reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    true            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    false           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    $end            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    then            reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    do              reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    COMMA           reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    CLOSE_SQUARE    reduce using rule 83 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)


state 213

    (84) array_size -> primary COMMA . array_size
    (84) array_size -> . primary COMMA array_size
    (85) array_size -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self

    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    IDENTIFIER      shift and go to state 99
    nil             shift and go to state 42
    self            shift and go to state 43

    primary                        shift and go to state 181
    array_size                     shift and go to state 235
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59
    varname                        shift and go to state 97
    variable                       shift and go to state 98

state 214

    (7) stmt -> keydef argdecl newline multstmt keyend .

    SEMI_COLON      reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    NEWLINE         reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    puts            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    print           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    gets            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    class           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    break           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    def             reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    if              reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    while           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    until           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    case            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    for             reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    return          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    IDENTIFIER      reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    nil             reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    self            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    GLOBAL          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    AT_THE_RATE     reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    MINUS           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    PLUS            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    OPEN_BRACKET    reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    Array           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    NUMBER          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    FLOAT           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    STRING          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    true            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    false           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    $end            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)


state 215

    (16) keyend -> end .

    SEMI_COLON      reduce using rule 16 (keyend -> end .)
    NEWLINE         reduce using rule 16 (keyend -> end .)
    puts            reduce using rule 16 (keyend -> end .)
    print           reduce using rule 16 (keyend -> end .)
    gets            reduce using rule 16 (keyend -> end .)
    class           reduce using rule 16 (keyend -> end .)
    break           reduce using rule 16 (keyend -> end .)
    def             reduce using rule 16 (keyend -> end .)
    if              reduce using rule 16 (keyend -> end .)
    while           reduce using rule 16 (keyend -> end .)
    until           reduce using rule 16 (keyend -> end .)
    case            reduce using rule 16 (keyend -> end .)
    for             reduce using rule 16 (keyend -> end .)
    return          reduce using rule 16 (keyend -> end .)
    IDENTIFIER      reduce using rule 16 (keyend -> end .)
    nil             reduce using rule 16 (keyend -> end .)
    self            reduce using rule 16 (keyend -> end .)
    GLOBAL          reduce using rule 16 (keyend -> end .)
    AT_THE_RATE     reduce using rule 16 (keyend -> end .)
    MINUS           reduce using rule 16 (keyend -> end .)
    PLUS            reduce using rule 16 (keyend -> end .)
    OPEN_BRACKET    reduce using rule 16 (keyend -> end .)
    Array           reduce using rule 16 (keyend -> end .)
    NUMBER          reduce using rule 16 (keyend -> end .)
    FLOAT           reduce using rule 16 (keyend -> end .)
    STRING          reduce using rule 16 (keyend -> end .)
    true            reduce using rule 16 (keyend -> end .)
    false           reduce using rule 16 (keyend -> end .)
    $end            reduce using rule 16 (keyend -> end .)


state 216

    (17) multstmt -> stmt newline . multstmt
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    stmt                           shift and go to state 183
    multstmt                       shift and go to state 236
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 217

    (113) multarglist -> COMMA IDENTIFIER . multarglist
    (113) multarglist -> . COMMA IDENTIFIER multarglist
    (114) multarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 187
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    multarglist                    shift and go to state 237
    empty                          shift and go to state 188

state 218

    (108) callmultarglist -> COMMA primary . callmultarglist
    (108) callmultarglist -> . COMMA primary callmultarglist
    (109) callmultarglist -> . empty
    (141) empty -> .

    COMMA           shift and go to state 194
    CLOSE_BRACKET   reduce using rule 141 (empty -> .)

    callmultarglist                shift and go to state 238
    empty                          shift and go to state 195

state 219

    (11) stmt -> class IDENTIFIER newline multstmt end .

    SEMI_COLON      reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    NEWLINE         reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    puts            reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    print           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    gets            reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    class           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    break           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    def             reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    if              reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    while           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    until           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    case            reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    for             reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    return          reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    IDENTIFIER      reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    nil             reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    self            reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    GLOBAL          reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    AT_THE_RATE     reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    MINUS           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    PLUS            reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    OPEN_BRACKET    reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    Array           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    NUMBER          reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    FLOAT           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    STRING          reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    true            reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    false           reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)
    $end            reduce using rule 11 (stmt -> class IDENTIFIER newline multstmt end .)


state 220

    (12) stmt -> class IDENTIFIER LESS IDENTIFIER newline . multstmt end
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    multstmt                       shift and go to state 239
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 221

    (19) expr -> if expr1 pthen M_1 multstmt . else newline M_1 multstmt end M_1
    (20) expr -> if expr1 pthen M_1 multstmt . M_1 multelsif end M_1
    (21) expr -> if expr1 pthen M_1 multstmt . end M_1
    (27) M_1 -> . empty
    (141) empty -> .

  ! shift/reduce conflict for else resolved as shift
  ! shift/reduce conflict for end resolved as shift
    else            shift and go to state 241
    end             shift and go to state 242
    elsif           reduce using rule 141 (empty -> .)

  ! else            [ reduce using rule 141 (empty -> .) ]
  ! end             [ reduce using rule 141 (empty -> .) ]

    M_1                            shift and go to state 240
    empty                          shift and go to state 78

state 222

    (22) expr -> while M_1 expr1 pdo M_1 . multstmt end M_1
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 22
    multstmt                       shift and go to state 243
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 223

    (123) pdo -> newline do .

    puts            reduce using rule 123 (pdo -> newline do .)
    print           reduce using rule 123 (pdo -> newline do .)
    gets            reduce using rule 123 (pdo -> newline do .)
    class           reduce using rule 123 (pdo -> newline do .)
    break           reduce using rule 123 (pdo -> newline do .)
    def             reduce using rule 123 (pdo -> newline do .)
    if              reduce using rule 123 (pdo -> newline do .)
    while           reduce using rule 123 (pdo -> newline do .)
    until           reduce using rule 123 (pdo -> newline do .)
    case            reduce using rule 123 (pdo -> newline do .)
    for             reduce using rule 123 (pdo -> newline do .)
    return          reduce using rule 123 (pdo -> newline do .)
    IDENTIFIER      reduce using rule 123 (pdo -> newline do .)
    nil             reduce using rule 123 (pdo -> newline do .)
    self            reduce using rule 123 (pdo -> newline do .)
    GLOBAL          reduce using rule 123 (pdo -> newline do .)
    AT_THE_RATE     reduce using rule 123 (pdo -> newline do .)
    MINUS           reduce using rule 123 (pdo -> newline do .)
    PLUS            reduce using rule 123 (pdo -> newline do .)
    OPEN_BRACKET    reduce using rule 123 (pdo -> newline do .)
    Array           reduce using rule 123 (pdo -> newline do .)
    NUMBER          reduce using rule 123 (pdo -> newline do .)
    FLOAT           reduce using rule 123 (pdo -> newline do .)
    STRING          reduce using rule 123 (pdo -> newline do .)
    true            reduce using rule 123 (pdo -> newline do .)
    false           reduce using rule 123 (pdo -> newline do .)
    end             reduce using rule 123 (pdo -> newline do .)


state 224

    (122) pdo -> do newline .

    puts            reduce using rule 122 (pdo -> do newline .)
    print           reduce using rule 122 (pdo -> do newline .)
    gets            reduce using rule 122 (pdo -> do newline .)
    class           reduce using rule 122 (pdo -> do newline .)
    break           reduce using rule 122 (pdo -> do newline .)
    def             reduce using rule 122 (pdo -> do newline .)
    if              reduce using rule 122 (pdo -> do newline .)
    while           reduce using rule 122 (pdo -> do newline .)
    until           reduce using rule 122 (pdo -> do newline .)
    case            reduce using rule 122 (pdo -> do newline .)
    for             reduce using rule 122 (pdo -> do newline .)
    return          reduce using rule 122 (pdo -> do newline .)
    IDENTIFIER      reduce using rule 122 (pdo -> do newline .)
    nil             reduce using rule 122 (pdo -> do newline .)
    self            reduce using rule 122 (pdo -> do newline .)
    GLOBAL          reduce using rule 122 (pdo -> do newline .)
    AT_THE_RATE     reduce using rule 122 (pdo -> do newline .)
    MINUS           reduce using rule 122 (pdo -> do newline .)
    PLUS            reduce using rule 122 (pdo -> do newline .)
    OPEN_BRACKET    reduce using rule 122 (pdo -> do newline .)
    Array           reduce using rule 122 (pdo -> do newline .)
    NUMBER          reduce using rule 122 (pdo -> do newline .)
    FLOAT           reduce using rule 122 (pdo -> do newline .)
    STRING          reduce using rule 122 (pdo -> do newline .)
    true            reduce using rule 122 (pdo -> do newline .)
    false           reduce using rule 122 (pdo -> do newline .)
    end             reduce using rule 122 (pdo -> do newline .)


state 225

    (23) expr -> until M_1 expr1 pdo M_1 . multstmt end M_1
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 22
    multstmt                       shift and go to state 244
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 226

    (24) expr -> case expr1 newline multcase end . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 245
    empty                          shift and go to state 78

state 227

    (90) multcase -> when whenargs . pthen M_1 multstmt M_1 multcase
    (91) multcase -> when whenargs . pthen M_1 multstmt M_1
    (118) pthen -> . newline
    (119) pthen -> . then
    (120) pthen -> . newline then
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    then            shift and go to state 144
    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    pthen                          shift and go to state 246
    newline                        shift and go to state 143

state 228

    (100) whenargs -> arg .

    then            reduce using rule 100 (whenargs -> arg .)
    SEMI_COLON      reduce using rule 100 (whenargs -> arg .)
    NEWLINE         reduce using rule 100 (whenargs -> arg .)


state 229

    (25) expr -> for M_1 mlhs in expr1 . pdo M_1 multstmt end M_1
    (121) pdo -> . newline
    (122) pdo -> . do newline
    (123) pdo -> . newline do
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    do              shift and go to state 202
    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    pdo                            shift and go to state 247
    newline                        shift and go to state 201

state 230

    (86) arrayal -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 248


state 231

    (37) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NEWLINE         reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    puts            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    print           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    gets            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    class           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    break           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    def             reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    if              reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    while           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    until           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    case            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    for             reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    return          reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    nil             reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    self            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    GLOBAL          reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    MINUS           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    PLUS            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    Array           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NUMBER          reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    FLOAT           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    STRING          reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    true            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    false           reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    $end            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    then            reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    do              reduce using rule 37 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)


state 232

    (38) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 249


state 233

    (87) arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    MULTIPLY        reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_AND         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_XOR         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_OR          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DOUBLE_EQUALS   reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NOT_EQUALS      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EQUAL_TILDE     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMPARISON      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS_EQUALS     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER_EQUALS  reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    INCL_RANGE      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EXCL_RANGE      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    SEMI_COLON      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NEWLINE         reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    puts            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    print           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    gets            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    class           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    break           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    def             reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    if              reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    while           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    until           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    case            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    for             reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    return          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    IDENTIFIER      reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    nil             reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    self            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GLOBAL          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    AT_THE_RATE     reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OPEN_BRACKET    reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    Array           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NUMBER          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    FLOAT           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    STRING          reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    true            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    false           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    $end            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    then            reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    do              reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_BRACKET   reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMMA           reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_SQUARE    reduce using rule 87 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 234

    (88) array_args -> primary COMMA array_args .

    CLOSE_SQUARE    reduce using rule 88 (array_args -> primary COMMA array_args .)


state 235

    (84) array_size -> primary COMMA array_size .

    CLOSE_BRACKET   reduce using rule 84 (array_size -> primary COMMA array_size .)


state 236

    (17) multstmt -> stmt newline multstmt .

    end             reduce using rule 17 (multstmt -> stmt newline multstmt .)
    else            reduce using rule 17 (multstmt -> stmt newline multstmt .)
    elsif           reduce using rule 17 (multstmt -> stmt newline multstmt .)
    when            reduce using rule 17 (multstmt -> stmt newline multstmt .)


state 237

    (113) multarglist -> COMMA IDENTIFIER multarglist .

    CLOSE_BRACKET   reduce using rule 113 (multarglist -> COMMA IDENTIFIER multarglist .)


state 238

    (108) callmultarglist -> COMMA primary callmultarglist .

    CLOSE_BRACKET   reduce using rule 108 (callmultarglist -> COMMA primary callmultarglist .)


state 239

    (12) stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt . end

    end             shift and go to state 250


state 240

    (20) expr -> if expr1 pthen M_1 multstmt M_1 . multelsif end M_1
    (92) multelsif -> . elsif expr pthen M_1 multstmt M_1 multelsif M_1
    (93) multelsif -> . else newline multstmt
    (94) multelsif -> . empty
    (141) empty -> .

    elsif           shift and go to state 252
    else            shift and go to state 253
    end             reduce using rule 141 (empty -> .)

    multelsif                      shift and go to state 251
    empty                          shift and go to state 254

state 241

    (19) expr -> if expr1 pthen M_1 multstmt else . newline M_1 multstmt end M_1
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 255

state 242

    (21) expr -> if expr1 pthen M_1 multstmt end . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 256
    empty                          shift and go to state 78

state 243

    (22) expr -> while M_1 expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 257


state 244

    (23) expr -> until M_1 expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 258


state 245

    (24) expr -> case expr1 newline multcase end M_1 .

    SEMI_COLON      reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    NEWLINE         reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    puts            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    print           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    gets            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    class           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    break           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    def             reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    if              reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    while           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    until           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    case            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    for             reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    return          reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    IDENTIFIER      reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    nil             reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    self            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    GLOBAL          reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    AT_THE_RATE     reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    MINUS           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    PLUS            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    OPEN_BRACKET    reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    Array           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    NUMBER          reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    FLOAT           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    STRING          reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    true            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    false           reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    $end            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)
    then            reduce using rule 24 (expr -> case expr1 newline multcase end M_1 .)


state 246

    (90) multcase -> when whenargs pthen . M_1 multstmt M_1 multcase
    (91) multcase -> when whenargs pthen . M_1 multstmt M_1
    (27) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    when            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 259
    empty                          shift and go to state 78

state 247

    (25) expr -> for M_1 mlhs in expr1 pdo . M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 260
    empty                          shift and go to state 78

state 248

    (86) arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    in              reduce using rule 86 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 249

    (38) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NEWLINE         reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    puts            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    print           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    gets            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    class           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    break           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    def             reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    if              reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    while           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    until           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    case            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    for             reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    return          reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    nil             reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    self            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    GLOBAL          reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    MINUS           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    PLUS            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    Array           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NUMBER          reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    FLOAT           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    STRING          reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    true            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    false           reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    $end            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    then            reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    do              reduce using rule 38 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)


state 250

    (12) stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .

    SEMI_COLON      reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    NEWLINE         reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    puts            reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    print           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    gets            reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    class           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    break           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    def             reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    if              reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    while           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    until           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    case            reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    for             reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    return          reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    IDENTIFIER      reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    nil             reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    self            reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    GLOBAL          reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    AT_THE_RATE     reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    MINUS           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    PLUS            reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    OPEN_BRACKET    reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    Array           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    NUMBER          reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    FLOAT           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    STRING          reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    true            reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    false           reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)
    $end            reduce using rule 12 (stmt -> class IDENTIFIER LESS IDENTIFIER newline multstmt end .)


state 251

    (20) expr -> if expr1 pthen M_1 multstmt M_1 multelsif . end M_1

    end             shift and go to state 261


state 252

    (92) multelsif -> elsif . expr pthen M_1 multstmt M_1 multelsif M_1
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr                           shift and go to state 262
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    primary                        shift and go to state 14
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 253

    (93) multelsif -> else . newline multstmt
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    newline                        shift and go to state 263

state 254

    (94) multelsif -> empty .

    end             reduce using rule 94 (multelsif -> empty .)


state 255

    (19) expr -> if expr1 pthen M_1 multstmt else newline . M_1 multstmt end M_1
    (27) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 264
    empty                          shift and go to state 78

state 256

    (21) expr -> if expr1 pthen M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    puts            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    print           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    gets            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    class           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    break           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    def             reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    if              reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    while           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    until           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    case            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    for             reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    return          reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    nil             reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    self            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    MINUS           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    PLUS            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    Array           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    STRING          reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    true            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    false           reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    $end            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    then            reduce using rule 21 (expr -> if expr1 pthen M_1 multstmt end M_1 .)


state 257

    (22) expr -> while M_1 expr1 pdo M_1 multstmt end . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 265
    empty                          shift and go to state 78

state 258

    (23) expr -> until M_1 expr1 pdo M_1 multstmt end . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 266
    empty                          shift and go to state 78

state 259

    (90) multcase -> when whenargs pthen M_1 . multstmt M_1 multcase
    (91) multcase -> when whenargs pthen M_1 . multstmt M_1
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    when            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    multstmt                       shift and go to state 267
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 260

    (25) expr -> for M_1 mlhs in expr1 pdo M_1 . multstmt end M_1
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    mlhs                           shift and go to state 27
    expr1                          shift and go to state 22
    multstmt                       shift and go to state 268
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 261

    (20) expr -> if expr1 pthen M_1 multstmt M_1 multelsif end . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 269
    empty                          shift and go to state 78

state 262

    (92) multelsif -> elsif expr . pthen M_1 multstmt M_1 multelsif M_1
    (118) pthen -> . newline
    (119) pthen -> . then
    (120) pthen -> . newline then
    (139) newline -> . SEMI_COLON
    (140) newline -> . NEWLINE

    then            shift and go to state 144
    SEMI_COLON      shift and go to state 6
    NEWLINE         shift and go to state 7

    pthen                          shift and go to state 270
    newline                        shift and go to state 143

state 263

    (93) multelsif -> else newline . multstmt
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    multstmt                       shift and go to state 271
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 264

    (19) expr -> if expr1 pthen M_1 multstmt else newline M_1 . multstmt end M_1
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr1                          shift and go to state 22
    multstmt                       shift and go to state 272
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr                           shift and go to state 19
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 265

    (22) expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    gets            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    class           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    STRING          reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 22 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)


state 266

    (23) expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    gets            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    class           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    STRING          reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 23 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)


state 267

    (90) multcase -> when whenargs pthen M_1 multstmt . M_1 multcase
    (91) multcase -> when whenargs pthen M_1 multstmt . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    when            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 273
    empty                          shift and go to state 78

state 268

    (25) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 274


state 269

    (20) expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .

    SEMI_COLON      reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    NEWLINE         reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    puts            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    print           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    gets            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    class           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    break           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    def             reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    if              reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    while           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    until           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    case            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    for             reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    return          reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    IDENTIFIER      reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    nil             reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    self            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    GLOBAL          reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    AT_THE_RATE     reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    MINUS           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    PLUS            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    OPEN_BRACKET    reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    Array           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    NUMBER          reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    FLOAT           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    STRING          reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    true            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    false           reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    $end            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    then            reduce using rule 20 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)


state 270

    (92) multelsif -> elsif expr pthen . M_1 multstmt M_1 multelsif M_1
    (27) M_1 -> . empty
    (141) empty -> .

    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    elsif           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 275
    empty                          shift and go to state 78

state 271

    (93) multelsif -> else newline multstmt .

    end             reduce using rule 93 (multelsif -> else newline multstmt .)


state 272

    (19) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt . end M_1

    end             shift and go to state 276


state 273

    (90) multcase -> when whenargs pthen M_1 multstmt M_1 . multcase
    (91) multcase -> when whenargs pthen M_1 multstmt M_1 .
    (90) multcase -> . when whenargs pthen M_1 multstmt M_1 multcase
    (91) multcase -> . when whenargs pthen M_1 multstmt M_1

    end             reduce using rule 91 (multcase -> when whenargs pthen M_1 multstmt M_1 .)
    when            shift and go to state 205

    multcase                       shift and go to state 277

state 274

    (25) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 278
    empty                          shift and go to state 78

state 275

    (92) multelsif -> elsif expr pthen M_1 . multstmt M_1 multelsif M_1
    (17) multstmt -> . stmt newline multstmt
    (18) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . gets OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
    (11) stmt -> . class IDENTIFIER newline multstmt end
    (12) stmt -> . class IDENTIFIER LESS IDENTIFIER newline multstmt end
    (13) stmt -> . break
    (14) stmt -> . expr
    (141) empty -> .
    (15) keydef -> . def IDENTIFIER
    (19) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (20) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (21) expr -> . if expr1 pthen M_1 multstmt end M_1
    (22) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (23) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (24) expr -> . case expr1 newline multcase end M_1
    (25) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (26) expr -> . expr1
    (28) expr1 -> . return term2
    (29) expr1 -> . return
    (30) expr1 -> . expr2
    (31) expr2 -> . arg
    (32) expr2 -> . call
    (36) arg -> . term0
    (33) call -> . function
    (37) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (38) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (39) term0 -> . term1
    (34) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (35) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (101) mlhs -> . mlhsitem
    (40) term1 -> . mlhs EQUALS mrhs
    (41) term1 -> . mlhs opasgn mrhs
    (42) term1 -> . term2
    (102) mlhsitem -> . IDENTIFIER
    (103) mlhsitem -> . arrayal
    (43) term2 -> . term3 INCL_RANGE term3
    (44) term2 -> . term3 EXCL_RANGE term3
    (45) term2 -> . term3
    (86) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (46) term3 -> . term3 LOGICAL_OR term4
    (47) term3 -> . term4
    (115) variable -> . varname
    (116) variable -> . nil
    (117) variable -> . self
    (48) term4 -> . term5 DOUBLE_EQUALS term5
    (49) term4 -> . term5 NOT_EQUALS term5
    (50) term4 -> . term5 EQUAL_TILDE term5
    (51) term4 -> . term5 COMPARISON term5
    (52) term4 -> . term5
    (136) varname -> . GLOBAL
    (137) varname -> . AT_THE_RATE IDENTIFIER
    (138) varname -> . IDENTIFIER
    (53) term5 -> . term5 LESS term6
    (54) term5 -> . term5 LESS_EQUALS term6
    (55) term5 -> . term5 GREATER term6
    (56) term5 -> . term5 GREATER_EQUALS term6
    (57) term5 -> . term6
    (58) term6 -> . term6 BIT_XOR term7
    (59) term6 -> . term6 BIT_OR term7
    (60) term6 -> . term7
    (61) term7 -> . term7 BIT_AND term8
    (62) term7 -> . term8
    (63) term8 -> . term8 LEFT_SHIFT term9
    (64) term8 -> . term8 RIGHT_SHIFT term9
    (65) term8 -> . term9
    (66) term9 -> . term9 PLUS term10
    (67) term9 -> . term9 MINUS term10
    (68) term9 -> . term10
    (69) term10 -> . term10 MULTIPLY term11
    (70) term10 -> . term10 DIVIDE term11
    (71) term10 -> . term10 MODULO term11
    (72) term10 -> . term11
    (73) term11 -> . MINUS term11
    (74) term11 -> . term12
    (75) term12 -> . PLUS term12
    (76) term12 -> . term13
    (77) term13 -> . primary
    (78) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (79) primary -> . arrayd
    (80) primary -> . arraya
    (81) primary -> . literal
    (82) primary -> . varname
    (83) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (87) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (95) literal -> . NUMBER
    (96) literal -> . FLOAT
    (97) literal -> . STRING
    (98) literal -> . true
    (99) literal -> . false

    puts            shift and go to state 10
    print           shift and go to state 13
    gets            shift and go to state 15
    class           shift and go to state 17
    break           shift and go to state 18
    elsif           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)
    def             shift and go to state 20
    if              shift and go to state 21
    while           shift and go to state 23
    until           shift and go to state 24
    case            shift and go to state 25
    for             shift and go to state 26
    return          shift and go to state 28
    IDENTIFIER      shift and go to state 16
    nil             shift and go to state 42
    self            shift and go to state 43
    GLOBAL          shift and go to state 45
    AT_THE_RATE     shift and go to state 46
    MINUS           shift and go to state 53
    PLUS            shift and go to state 51
    OPEN_BRACKET    shift and go to state 11
    Array           shift and go to state 60
    NUMBER          shift and go to state 61
    FLOAT           shift and go to state 62
    STRING          shift and go to state 12
    true            shift and go to state 63
    false           shift and go to state 64

    expr                           shift and go to state 19
    multstmt                       shift and go to state 279
    stmt                           shift and go to state 183
    empty                          shift and go to state 184
    keydef                         shift and go to state 9
    primary                        shift and go to state 14
    expr1                          shift and go to state 22
    mlhs                           shift and go to state 27
    term2                          shift and go to state 29
    expr2                          shift and go to state 30
    arg                            shift and go to state 31
    call                           shift and go to state 32
    term0                          shift and go to state 33
    function                       shift and go to state 34
    term1                          shift and go to state 35
    mlhsitem                       shift and go to state 36
    arrayal                        shift and go to state 37
    term3                          shift and go to state 38
    variable                       shift and go to state 39
    term4                          shift and go to state 40
    varname                        shift and go to state 41
    term5                          shift and go to state 44
    term6                          shift and go to state 47
    term7                          shift and go to state 48
    term8                          shift and go to state 49
    term9                          shift and go to state 50
    term10                         shift and go to state 52
    term11                         shift and go to state 54
    term12                         shift and go to state 55
    term13                         shift and go to state 56
    arrayd                         shift and go to state 57
    arraya                         shift and go to state 58
    literal                        shift and go to state 59

state 276

    (19) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    SEMI_COLON      reduce using rule 141 (empty -> .)
    NEWLINE         reduce using rule 141 (empty -> .)
    puts            reduce using rule 141 (empty -> .)
    print           reduce using rule 141 (empty -> .)
    gets            reduce using rule 141 (empty -> .)
    class           reduce using rule 141 (empty -> .)
    break           reduce using rule 141 (empty -> .)
    def             reduce using rule 141 (empty -> .)
    if              reduce using rule 141 (empty -> .)
    while           reduce using rule 141 (empty -> .)
    until           reduce using rule 141 (empty -> .)
    case            reduce using rule 141 (empty -> .)
    for             reduce using rule 141 (empty -> .)
    return          reduce using rule 141 (empty -> .)
    IDENTIFIER      reduce using rule 141 (empty -> .)
    nil             reduce using rule 141 (empty -> .)
    self            reduce using rule 141 (empty -> .)
    GLOBAL          reduce using rule 141 (empty -> .)
    AT_THE_RATE     reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    OPEN_BRACKET    reduce using rule 141 (empty -> .)
    Array           reduce using rule 141 (empty -> .)
    NUMBER          reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    STRING          reduce using rule 141 (empty -> .)
    true            reduce using rule 141 (empty -> .)
    false           reduce using rule 141 (empty -> .)
    $end            reduce using rule 141 (empty -> .)
    then            reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 280
    empty                          shift and go to state 78

state 277

    (90) multcase -> when whenargs pthen M_1 multstmt M_1 multcase .

    end             reduce using rule 90 (multcase -> when whenargs pthen M_1 multstmt M_1 multcase .)


state 278

    (25) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    gets            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    class           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    STRING          reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 25 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)


state 279

    (92) multelsif -> elsif expr pthen M_1 multstmt . M_1 multelsif M_1
    (27) M_1 -> . empty
    (141) empty -> .

    elsif           reduce using rule 141 (empty -> .)
    else            reduce using rule 141 (empty -> .)
    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 281
    empty                          shift and go to state 78

state 280

    (19) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    puts            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    print           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    gets            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    class           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    break           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    def             reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    if              reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    while           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    until           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    case            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    for             reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    return          reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    nil             reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    self            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    MINUS           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    PLUS            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    Array           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    STRING          reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    true            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    false           reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    $end            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    then            reduce using rule 19 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)


state 281

    (92) multelsif -> elsif expr pthen M_1 multstmt M_1 . multelsif M_1
    (92) multelsif -> . elsif expr pthen M_1 multstmt M_1 multelsif M_1
    (93) multelsif -> . else newline multstmt
    (94) multelsif -> . empty
    (141) empty -> .

    elsif           shift and go to state 252
    else            shift and go to state 253
    end             reduce using rule 141 (empty -> .)

    multelsif                      shift and go to state 282
    empty                          shift and go to state 254

state 282

    (92) multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif . M_1
    (27) M_1 -> . empty
    (141) empty -> .

    end             reduce using rule 141 (empty -> .)

    M_1                            shift and go to state 283
    empty                          shift and go to state 78

state 283

    (92) multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1 .

    end             reduce using rule 92 (multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OPEN_BRACKET in state 16 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 28 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 28 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 28 resolved as shift
WARNING: shift/reduce conflict for Array in state 28 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 28 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 28 resolved as shift
WARNING: shift/reduce conflict for STRING in state 28 resolved as shift
WARNING: shift/reduce conflict for true in state 28 resolved as shift
WARNING: shift/reduce conflict for false in state 28 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 28 resolved as shift
WARNING: shift/reduce conflict for AT_THE_RATE in state 28 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 28 resolved as shift
WARNING: shift/reduce conflict for nil in state 28 resolved as shift
WARNING: shift/reduce conflict for self in state 28 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 50 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 50 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACKET in state 73 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 173 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 173 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 174 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 174 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACKET in state 208 resolved as shift
WARNING: shift/reduce conflict for else in state 221 resolved as shift
WARNING: shift/reduce conflict for end in state 221 resolved as shift
