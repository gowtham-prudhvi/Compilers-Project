Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    CONSTANT_RESOLUTION
    POWER_EQUALS
    PLUS_AT
    undef
    POWER
    STRING2
    WORD_OR
    rescue
    COMPLEMENT
    not
    MAP
    yield
    SYMBOL_NOT
    module
    LOGICAL_AND
    ELEMENT_REFERENCE
    BEGIN
    retry
    COLON
    END
    REGEXP
    super
    CLOSE_FLOWER
    ensure
    or
    DOUBLE_QUOTE
    OPEN_FLOWER
    ELEMENT_SET
    next
    redo
    DOT
    WORD_AND
    QUESTION_MARK
    HEREDOC
    BANG_TILDE
    and
    defined
    MINUS_AT
    WORD_NOT
    begin
    unless
    DOLLAR
    class
    alias
    TRIPLE_EQUALS

Grammar

Rule 0     S' -> compstmt
Rule 1     compstmt -> multcompstmt
Rule 2     multcompstmt -> newline stmt1 multcompstmt
Rule 3     multcompstmt -> stmt1 multcompstmt
Rule 4     multcompstmt -> newline
Rule 5     multcompstmt -> empty
Rule 6     stmt1 -> stmt
Rule 7     stmt -> keydef argdecl newline multstmt keyend
Rule 8     stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET
Rule 9     stmt -> print OPEN_BRACKET primary CLOSE_BRACKET
Rule 10    stmt -> break
Rule 11    stmt -> expr
Rule 12    keydef -> def IDENTIFIER
Rule 13    keyend -> end
Rule 14    multstmt -> stmt newline multstmt
Rule 15    multstmt -> empty
Rule 16    expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
Rule 17    expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1
Rule 18    expr -> if expr1 pthen M_1 multstmt end M_1
Rule 19    expr -> while M_1 expr1 pdo M_1 multstmt end M_1
Rule 20    expr -> until M_1 expr1 pdo M_1 multstmt end M_1
Rule 21    expr -> case expr1 newline multcase end M_1
Rule 22    expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
Rule 23    expr -> expr1
Rule 24    M_1 -> empty
Rule 25    expr1 -> return IDENTIFIER
Rule 26    expr1 -> return
Rule 27    expr1 -> expr2
Rule 28    expr2 -> arg
Rule 29    expr2 -> call
Rule 30    call -> function
Rule 31    function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
Rule 32    function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
Rule 33    arg -> term0
Rule 34    term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
Rule 35    term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
Rule 36    term0 -> term1
Rule 37    term1 -> mlhs EQUALS mrhs
Rule 38    term1 -> mlhs opasgn mrhs
Rule 39    term1 -> term2
Rule 40    term2 -> term3 INCL_RANGE term3
Rule 41    term2 -> term3 EXCL_RANGE term3
Rule 42    term2 -> term3
Rule 43    term3 -> term3 LOGICAL_OR term4
Rule 44    term3 -> term4
Rule 45    term4 -> term5 DOUBLE_EQUALS term5
Rule 46    term4 -> term5 NOT_EQUALS term5
Rule 47    term4 -> term5 EQUAL_TILDE term5
Rule 48    term4 -> term5 COMPARISON term5
Rule 49    term4 -> term5
Rule 50    term5 -> term5 LESS term6
Rule 51    term5 -> term5 LESS_EQUALS term6
Rule 52    term5 -> term5 GREATER term6
Rule 53    term5 -> term5 GREATER_EQUALS term6
Rule 54    term5 -> term6
Rule 55    term6 -> term6 BIT_XOR term7
Rule 56    term6 -> term6 BIT_OR term7
Rule 57    term6 -> term7
Rule 58    term7 -> term7 BIT_AND term8
Rule 59    term7 -> term8
Rule 60    term8 -> term8 LEFT_SHIFT term9
Rule 61    term8 -> term8 RIGHT_SHIFT term9
Rule 62    term8 -> term9
Rule 63    term9 -> term9 PLUS term10
Rule 64    term9 -> term9 MINUS term10
Rule 65    term9 -> term10
Rule 66    term10 -> term10 MULTIPLY term11
Rule 67    term10 -> term10 DIVIDE term11
Rule 68    term10 -> term10 MODULO term11
Rule 69    term10 -> term11
Rule 70    term11 -> MINUS term11
Rule 71    term11 -> term12
Rule 72    term12 -> PLUS term12
Rule 73    term12 -> term13
Rule 74    term13 -> primary
Rule 75    primary -> OPEN_BRACKET expr2 CLOSE_BRACKET
Rule 76    primary -> arrayd
Rule 77    primary -> arraya
Rule 78    primary -> literal
Rule 79    primary -> varname
Rule 80    arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET
Rule 81    array_size -> primary COMMA array_size
Rule 82    array_size -> primary
Rule 83    arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE
Rule 84    arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE
Rule 85    array_args -> primary COMMA array_args
Rule 86    array_args -> primary
Rule 87    multcase -> when whenargs pthen M_1 multstmt M_1 multcase
Rule 88    multcase -> when whenargs pthen M_1 multstmt M_1
Rule 89    multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1
Rule 90    multelsif -> else newline multstmt
Rule 91    multelsif -> empty
Rule 92    literal -> NUMBER
Rule 93    literal -> FLOAT
Rule 94    literal -> STRING
Rule 95    literal -> true
Rule 96    literal -> false
Rule 97    whenargs -> arg
Rule 98    mlhs -> mlhsitem
Rule 99    mlhsitem -> IDENTIFIER
Rule 100   mlhsitem -> arrayal
Rule 101   arrayl -> primary2 OPEN_SQUARE array_argsl CLOSE_SQUARE
Rule 102   array_argsl -> primary2 COMMA array_argsl
Rule 103   array_argsl -> primary2
Rule 104   primary2 -> IDENTIFIER
Rule 105   primary2 -> literal
Rule 106   lhs -> variable
Rule 107   lhs -> variable OPEN_SQUARE args CLOSE_SQUARE
Rule 108   lhs -> variable OPEN_SQUARE CLOSE_SQUARE
Rule 109   mrhs -> term2
Rule 110   mrhs -> args COMMA MULTIPLY arg
Rule 111   mrhs -> MULTIPLY arg
Rule 112   callargs -> callarglist
Rule 113   callarglist -> primary callmultarglist
Rule 114   callarglist -> empty
Rule 115   callmultarglist -> COMMA primary callmultarglist
Rule 116   callmultarglist -> empty
Rule 117   args -> arg multargs
Rule 118   multargs -> COMMA arg multargs
Rule 119   multargs -> empty
Rule 120   argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET
Rule 121   arglist -> IDENTIFIER multarglist
Rule 122   arglist -> empty
Rule 123   multarglist -> COMMA IDENTIFIER multarglist
Rule 124   multarglist -> empty
Rule 125   variable -> varname
Rule 126   variable -> nil
Rule 127   variable -> self
Rule 128   pthen -> newline
Rule 129   pthen -> then
Rule 130   pthen -> newline then
Rule 131   pdo -> newline
Rule 132   pdo -> do newline
Rule 133   pdo -> newline do
Rule 134   opasgn -> MODULO_EQUALS
Rule 135   opasgn -> DIVIDE_EQUALS
Rule 136   opasgn -> MINUS_EQUALS
Rule 137   opasgn -> PLUS_EQUALS
Rule 138   opasgn -> OR_EQUALS
Rule 139   opasgn -> AND_EQUALS
Rule 140   opasgn -> XOR_EQUALS
Rule 141   opasgn -> RIGHT_SHIFT_EQUALS
Rule 142   opasgn -> LEFT_SHIFT_EQUALS
Rule 143   opasgn -> MULTIPLY_EQUALS
Rule 144   opasgn -> LOGICAL_AND_EQUALS
Rule 145   opasgn -> LOGICAL_OR_EQUALS
Rule 146   varname -> GLOBAL
Rule 147   varname -> AT_THE_RATE IDENTIFIER
Rule 148   varname -> IDENTIFIER
Rule 149   newline -> SEMI_COLON
Rule 150   newline -> NEWLINE
Rule 151   empty -> <empty>

Terminals, with rules where they appear

AND_EQUALS           : 139
AT_THE_RATE          : 147
Array                : 80
BANG_TILDE           : 
BEGIN                : 
BIT_AND              : 58
BIT_OR               : 56
BIT_XOR              : 55
CLOSE_BRACKET        : 8 9 31 32 34 35 75 80 120
CLOSE_FLOWER         : 
CLOSE_SQUARE         : 83 84 101 107 108
COLON                : 
COMMA                : 81 85 102 110 115 118 123
COMPARISON           : 48
COMPLEMENT           : 
CONSTANT_RESOLUTION  : 
DIVIDE               : 67
DIVIDE_EQUALS        : 135
DOLLAR               : 
DOT                  : 
DOUBLE_EQUALS        : 45
DOUBLE_QUOTE         : 
ELEMENT_REFERENCE    : 
ELEMENT_SET          : 
END                  : 
EQUALS               : 34 35 37
EQUAL_TILDE          : 47
EXCL_RANGE           : 41
FLOAT                : 93
GLOBAL               : 146
GREATER              : 52
GREATER_EQUALS       : 53
HEREDOC              : 
IDENTIFIER           : 12 25 31 32 34 35 99 104 121 123 147 148
INCL_RANGE           : 40
LEFT_SHIFT           : 60
LEFT_SHIFT_EQUALS    : 142
LESS                 : 50
LESS_EQUALS          : 51
LOGICAL_AND          : 
LOGICAL_AND_EQUALS   : 144
LOGICAL_OR           : 43
LOGICAL_OR_EQUALS    : 145
MAP                  : 
MINUS                : 64 70
MINUS_AT             : 
MINUS_EQUALS         : 136
MODULO               : 68
MODULO_EQUALS        : 134
MULTIPLY             : 66 110 111
MULTIPLY_EQUALS      : 143
NEWLINE              : 150
NOT_EQUALS           : 46
NUMBER               : 92
OPEN_BRACKET         : 8 9 31 32 34 35 75 80 120
OPEN_FLOWER          : 
OPEN_SQUARE          : 83 84 101 107 108
OR_EQUALS            : 138
PLUS                 : 63 72
PLUS_AT              : 
PLUS_EQUALS          : 137
POWER                : 
POWER_EQUALS         : 
QUESTION_MARK        : 
REGEXP               : 
RIGHT_SHIFT          : 61
RIGHT_SHIFT_EQUALS   : 141
SEMI_COLON           : 149
STRING               : 8 94
STRING2              : 
SYMBOL_NOT           : 
TRIPLE_EQUALS        : 
WORD_AND             : 
WORD_NOT             : 
WORD_OR              : 
XOR_EQUALS           : 140
alias                : 
and                  : 
begin                : 
break                : 10
case                 : 21
class                : 
def                  : 12
defined              : 
do                   : 132 133
else                 : 16 90
elsif                : 89
end                  : 13 16 17 18 19 20 21 22
ensure               : 
error                : 
false                : 96
for                  : 22
if                   : 16 17 18
in                   : 22
module               : 
next                 : 
nil                  : 126
not                  : 
or                   : 
print                : 9
puts                 : 8
redo                 : 
rescue               : 
retry                : 
return               : 25 26
self                 : 127
super                : 
then                 : 129 130
true                 : 95
undef                : 
unless               : 
until                : 20
when                 : 87 88
while                : 19
yield                : 

Nonterminals, with rules where they appear

M_1                  : 16 16 16 17 17 17 18 18 19 19 19 20 20 20 21 22 22 22 87 87 88 88 89 89 89
arg                  : 28 97 110 111 117 118
argdecl              : 7
arglist              : 120
args                 : 107 110
array_args           : 83 84 85
array_argsl          : 101 102
array_size           : 80 81
arraya               : 77
arrayal              : 100
arrayd               : 76
arrayl               : 
call                 : 29
callarglist          : 112
callargs             : 31 35
callmultarglist      : 113 115
compstmt             : 0
empty                : 5 15 24 91 114 116 119 122 124
expr                 : 11 89
expr1                : 16 17 18 19 20 21 22 23
expr2                : 27 75
function             : 30
keydef               : 7
keyend               : 7
lhs                  : 
literal              : 78 105
mlhs                 : 22 34 35 37 38
mlhsitem             : 98
mrhs                 : 37 38
multarglist          : 121 123
multargs             : 117 118
multcase             : 21 87
multcompstmt         : 1 2 3
multelsif            : 17 89
multstmt             : 7 14 16 16 17 18 19 20 22 87 88 89 90
newline              : 2 4 7 14 16 21 90 128 130 131 132 133
opasgn               : 38
pdo                  : 19 20 22
primary              : 9 74 81 82 85 86 113 115
primary2             : 101 102 103
pthen                : 16 17 18 87 88 89
stmt                 : 6 14
stmt1                : 2 3
term0                : 33
term1                : 36
term10               : 63 64 65 66 67 68
term11               : 66 67 68 69 70
term12               : 71 72
term13               : 73
term2                : 39 109
term3                : 40 40 41 41 42 43
term4                : 43 44
term5                : 45 45 46 46 47 47 48 48 49 50 51 52 53
term6                : 50 51 52 53 54 55 56
term7                : 55 56 57 58
term8                : 58 59 60 61
term9                : 60 61 62 63 64
variable             : 83 84 106 107 108
varname              : 79 125
whenargs             : 87 88

Parsing method: LALR

state 0

    (0) S' -> . compstmt
    (1) compstmt -> . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (5) multcompstmt -> . empty
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE
    (6) stmt1 -> . stmt
    (151) empty -> .
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3
    $end            reduce using rule 151 (empty -> .)
    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 38
    function                       shift and go to state 39
    newline                        shift and go to state 57
    multcompstmt                   shift and go to state 7
    stmt                           shift and go to state 26
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    compstmt                       shift and go to state 27
    expr                           shift and go to state 44
    stmt1                          shift and go to state 29
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 1

    (34) term0 -> mlhs . EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> mlhs . EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (37) term1 -> mlhs . EQUALS mrhs
    (38) term1 -> mlhs . opasgn mrhs
    (134) opasgn -> . MODULO_EQUALS
    (135) opasgn -> . DIVIDE_EQUALS
    (136) opasgn -> . MINUS_EQUALS
    (137) opasgn -> . PLUS_EQUALS
    (138) opasgn -> . OR_EQUALS
    (139) opasgn -> . AND_EQUALS
    (140) opasgn -> . XOR_EQUALS
    (141) opasgn -> . RIGHT_SHIFT_EQUALS
    (142) opasgn -> . LEFT_SHIFT_EQUALS
    (143) opasgn -> . MULTIPLY_EQUALS
    (144) opasgn -> . LOGICAL_AND_EQUALS
    (145) opasgn -> . LOGICAL_OR_EQUALS

    EQUALS          shift and go to state 71
    MODULO_EQUALS   shift and go to state 76
    DIVIDE_EQUALS   shift and go to state 68
    MINUS_EQUALS    shift and go to state 63
    PLUS_EQUALS     shift and go to state 64
    OR_EQUALS       shift and go to state 72
    AND_EQUALS      shift and go to state 67
    XOR_EQUALS      shift and go to state 65
    RIGHT_SHIFT_EQUALS shift and go to state 70
    LEFT_SHIFT_EQUALS shift and go to state 66
    MULTIPLY_EQUALS shift and go to state 74
    LOGICAL_AND_EQUALS shift and go to state 69
    LOGICAL_OR_EQUALS shift and go to state 75

    opasgn                         shift and go to state 73

state 2

    (70) term11 -> MINUS . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 80
    arrayd                         shift and go to state 48

state 3

    (150) newline -> NEWLINE .

    then            reduce using rule 150 (newline -> NEWLINE .)
    puts            reduce using rule 150 (newline -> NEWLINE .)
    print           reduce using rule 150 (newline -> NEWLINE .)
    break           reduce using rule 150 (newline -> NEWLINE .)
    def             reduce using rule 150 (newline -> NEWLINE .)
    if              reduce using rule 150 (newline -> NEWLINE .)
    while           reduce using rule 150 (newline -> NEWLINE .)
    until           reduce using rule 150 (newline -> NEWLINE .)
    case            reduce using rule 150 (newline -> NEWLINE .)
    for             reduce using rule 150 (newline -> NEWLINE .)
    return          reduce using rule 150 (newline -> NEWLINE .)
    IDENTIFIER      reduce using rule 150 (newline -> NEWLINE .)
    nil             reduce using rule 150 (newline -> NEWLINE .)
    self            reduce using rule 150 (newline -> NEWLINE .)
    GLOBAL          reduce using rule 150 (newline -> NEWLINE .)
    AT_THE_RATE     reduce using rule 150 (newline -> NEWLINE .)
    MINUS           reduce using rule 150 (newline -> NEWLINE .)
    PLUS            reduce using rule 150 (newline -> NEWLINE .)
    OPEN_BRACKET    reduce using rule 150 (newline -> NEWLINE .)
    Array           reduce using rule 150 (newline -> NEWLINE .)
    NUMBER          reduce using rule 150 (newline -> NEWLINE .)
    FLOAT           reduce using rule 150 (newline -> NEWLINE .)
    STRING          reduce using rule 150 (newline -> NEWLINE .)
    true            reduce using rule 150 (newline -> NEWLINE .)
    false           reduce using rule 150 (newline -> NEWLINE .)
    else            reduce using rule 150 (newline -> NEWLINE .)
    end             reduce using rule 150 (newline -> NEWLINE .)
    elsif           reduce using rule 150 (newline -> NEWLINE .)
    do              reduce using rule 150 (newline -> NEWLINE .)
    $end            reduce using rule 150 (newline -> NEWLINE .)
    when            reduce using rule 150 (newline -> NEWLINE .)


state 4

    (75) primary -> OPEN_BRACKET . expr2 CLOSE_BRACKET
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 81
    literal                        shift and go to state 34
    call                           shift and go to state 35
    function                       shift and go to state 39
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 5

    (72) term12 -> PLUS . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    term13                         shift and go to state 8
    term12                         shift and go to state 82
    arrayd                         shift and go to state 48

state 6

    (25) expr1 -> return . IDENTIFIER
    (26) expr1 -> return .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 83
    do              reduce using rule 26 (expr1 -> return .)
    SEMI_COLON      reduce using rule 26 (expr1 -> return .)
    NEWLINE         reduce using rule 26 (expr1 -> return .)
    puts            reduce using rule 26 (expr1 -> return .)
    print           reduce using rule 26 (expr1 -> return .)
    break           reduce using rule 26 (expr1 -> return .)
    def             reduce using rule 26 (expr1 -> return .)
    if              reduce using rule 26 (expr1 -> return .)
    while           reduce using rule 26 (expr1 -> return .)
    until           reduce using rule 26 (expr1 -> return .)
    case            reduce using rule 26 (expr1 -> return .)
    for             reduce using rule 26 (expr1 -> return .)
    return          reduce using rule 26 (expr1 -> return .)
    nil             reduce using rule 26 (expr1 -> return .)
    self            reduce using rule 26 (expr1 -> return .)
    GLOBAL          reduce using rule 26 (expr1 -> return .)
    AT_THE_RATE     reduce using rule 26 (expr1 -> return .)
    MINUS           reduce using rule 26 (expr1 -> return .)
    PLUS            reduce using rule 26 (expr1 -> return .)
    OPEN_BRACKET    reduce using rule 26 (expr1 -> return .)
    Array           reduce using rule 26 (expr1 -> return .)
    NUMBER          reduce using rule 26 (expr1 -> return .)
    FLOAT           reduce using rule 26 (expr1 -> return .)
    STRING          reduce using rule 26 (expr1 -> return .)
    true            reduce using rule 26 (expr1 -> return .)
    false           reduce using rule 26 (expr1 -> return .)
    $end            reduce using rule 26 (expr1 -> return .)
    then            reduce using rule 26 (expr1 -> return .)

  ! IDENTIFIER      [ reduce using rule 26 (expr1 -> return .) ]


state 7

    (1) compstmt -> multcompstmt .

    $end            reduce using rule 1 (compstmt -> multcompstmt .)


state 8

    (73) term12 -> term13 .

    MULTIPLY        reduce using rule 73 (term12 -> term13 .)
    DIVIDE          reduce using rule 73 (term12 -> term13 .)
    MODULO          reduce using rule 73 (term12 -> term13 .)
    PLUS            reduce using rule 73 (term12 -> term13 .)
    MINUS           reduce using rule 73 (term12 -> term13 .)
    LEFT_SHIFT      reduce using rule 73 (term12 -> term13 .)
    RIGHT_SHIFT     reduce using rule 73 (term12 -> term13 .)
    BIT_AND         reduce using rule 73 (term12 -> term13 .)
    BIT_XOR         reduce using rule 73 (term12 -> term13 .)
    BIT_OR          reduce using rule 73 (term12 -> term13 .)
    DOUBLE_EQUALS   reduce using rule 73 (term12 -> term13 .)
    NOT_EQUALS      reduce using rule 73 (term12 -> term13 .)
    EQUAL_TILDE     reduce using rule 73 (term12 -> term13 .)
    COMPARISON      reduce using rule 73 (term12 -> term13 .)
    LESS            reduce using rule 73 (term12 -> term13 .)
    LESS_EQUALS     reduce using rule 73 (term12 -> term13 .)
    GREATER         reduce using rule 73 (term12 -> term13 .)
    GREATER_EQUALS  reduce using rule 73 (term12 -> term13 .)
    INCL_RANGE      reduce using rule 73 (term12 -> term13 .)
    EXCL_RANGE      reduce using rule 73 (term12 -> term13 .)
    LOGICAL_OR      reduce using rule 73 (term12 -> term13 .)
    SEMI_COLON      reduce using rule 73 (term12 -> term13 .)
    NEWLINE         reduce using rule 73 (term12 -> term13 .)
    puts            reduce using rule 73 (term12 -> term13 .)
    print           reduce using rule 73 (term12 -> term13 .)
    break           reduce using rule 73 (term12 -> term13 .)
    def             reduce using rule 73 (term12 -> term13 .)
    if              reduce using rule 73 (term12 -> term13 .)
    while           reduce using rule 73 (term12 -> term13 .)
    until           reduce using rule 73 (term12 -> term13 .)
    case            reduce using rule 73 (term12 -> term13 .)
    for             reduce using rule 73 (term12 -> term13 .)
    return          reduce using rule 73 (term12 -> term13 .)
    IDENTIFIER      reduce using rule 73 (term12 -> term13 .)
    nil             reduce using rule 73 (term12 -> term13 .)
    self            reduce using rule 73 (term12 -> term13 .)
    GLOBAL          reduce using rule 73 (term12 -> term13 .)
    AT_THE_RATE     reduce using rule 73 (term12 -> term13 .)
    OPEN_BRACKET    reduce using rule 73 (term12 -> term13 .)
    Array           reduce using rule 73 (term12 -> term13 .)
    NUMBER          reduce using rule 73 (term12 -> term13 .)
    FLOAT           reduce using rule 73 (term12 -> term13 .)
    STRING          reduce using rule 73 (term12 -> term13 .)
    true            reduce using rule 73 (term12 -> term13 .)
    false           reduce using rule 73 (term12 -> term13 .)
    $end            reduce using rule 73 (term12 -> term13 .)
    CLOSE_BRACKET   reduce using rule 73 (term12 -> term13 .)
    then            reduce using rule 73 (term12 -> term13 .)
    COMMA           reduce using rule 73 (term12 -> term13 .)
    do              reduce using rule 73 (term12 -> term13 .)


state 9

    (71) term11 -> term12 .

    MULTIPLY        reduce using rule 71 (term11 -> term12 .)
    DIVIDE          reduce using rule 71 (term11 -> term12 .)
    MODULO          reduce using rule 71 (term11 -> term12 .)
    PLUS            reduce using rule 71 (term11 -> term12 .)
    MINUS           reduce using rule 71 (term11 -> term12 .)
    LEFT_SHIFT      reduce using rule 71 (term11 -> term12 .)
    RIGHT_SHIFT     reduce using rule 71 (term11 -> term12 .)
    BIT_AND         reduce using rule 71 (term11 -> term12 .)
    BIT_XOR         reduce using rule 71 (term11 -> term12 .)
    BIT_OR          reduce using rule 71 (term11 -> term12 .)
    DOUBLE_EQUALS   reduce using rule 71 (term11 -> term12 .)
    NOT_EQUALS      reduce using rule 71 (term11 -> term12 .)
    EQUAL_TILDE     reduce using rule 71 (term11 -> term12 .)
    COMPARISON      reduce using rule 71 (term11 -> term12 .)
    LESS            reduce using rule 71 (term11 -> term12 .)
    LESS_EQUALS     reduce using rule 71 (term11 -> term12 .)
    GREATER         reduce using rule 71 (term11 -> term12 .)
    GREATER_EQUALS  reduce using rule 71 (term11 -> term12 .)
    INCL_RANGE      reduce using rule 71 (term11 -> term12 .)
    EXCL_RANGE      reduce using rule 71 (term11 -> term12 .)
    LOGICAL_OR      reduce using rule 71 (term11 -> term12 .)
    SEMI_COLON      reduce using rule 71 (term11 -> term12 .)
    NEWLINE         reduce using rule 71 (term11 -> term12 .)
    puts            reduce using rule 71 (term11 -> term12 .)
    print           reduce using rule 71 (term11 -> term12 .)
    break           reduce using rule 71 (term11 -> term12 .)
    def             reduce using rule 71 (term11 -> term12 .)
    if              reduce using rule 71 (term11 -> term12 .)
    while           reduce using rule 71 (term11 -> term12 .)
    until           reduce using rule 71 (term11 -> term12 .)
    case            reduce using rule 71 (term11 -> term12 .)
    for             reduce using rule 71 (term11 -> term12 .)
    return          reduce using rule 71 (term11 -> term12 .)
    IDENTIFIER      reduce using rule 71 (term11 -> term12 .)
    nil             reduce using rule 71 (term11 -> term12 .)
    self            reduce using rule 71 (term11 -> term12 .)
    GLOBAL          reduce using rule 71 (term11 -> term12 .)
    AT_THE_RATE     reduce using rule 71 (term11 -> term12 .)
    OPEN_BRACKET    reduce using rule 71 (term11 -> term12 .)
    Array           reduce using rule 71 (term11 -> term12 .)
    NUMBER          reduce using rule 71 (term11 -> term12 .)
    FLOAT           reduce using rule 71 (term11 -> term12 .)
    STRING          reduce using rule 71 (term11 -> term12 .)
    true            reduce using rule 71 (term11 -> term12 .)
    false           reduce using rule 71 (term11 -> term12 .)
    $end            reduce using rule 71 (term11 -> term12 .)
    CLOSE_BRACKET   reduce using rule 71 (term11 -> term12 .)
    then            reduce using rule 71 (term11 -> term12 .)
    COMMA           reduce using rule 71 (term11 -> term12 .)
    do              reduce using rule 71 (term11 -> term12 .)


state 10

    (69) term10 -> term11 .

    MULTIPLY        reduce using rule 69 (term10 -> term11 .)
    DIVIDE          reduce using rule 69 (term10 -> term11 .)
    MODULO          reduce using rule 69 (term10 -> term11 .)
    PLUS            reduce using rule 69 (term10 -> term11 .)
    MINUS           reduce using rule 69 (term10 -> term11 .)
    LEFT_SHIFT      reduce using rule 69 (term10 -> term11 .)
    RIGHT_SHIFT     reduce using rule 69 (term10 -> term11 .)
    BIT_AND         reduce using rule 69 (term10 -> term11 .)
    BIT_XOR         reduce using rule 69 (term10 -> term11 .)
    BIT_OR          reduce using rule 69 (term10 -> term11 .)
    DOUBLE_EQUALS   reduce using rule 69 (term10 -> term11 .)
    NOT_EQUALS      reduce using rule 69 (term10 -> term11 .)
    EQUAL_TILDE     reduce using rule 69 (term10 -> term11 .)
    COMPARISON      reduce using rule 69 (term10 -> term11 .)
    LESS            reduce using rule 69 (term10 -> term11 .)
    LESS_EQUALS     reduce using rule 69 (term10 -> term11 .)
    GREATER         reduce using rule 69 (term10 -> term11 .)
    GREATER_EQUALS  reduce using rule 69 (term10 -> term11 .)
    INCL_RANGE      reduce using rule 69 (term10 -> term11 .)
    EXCL_RANGE      reduce using rule 69 (term10 -> term11 .)
    LOGICAL_OR      reduce using rule 69 (term10 -> term11 .)
    then            reduce using rule 69 (term10 -> term11 .)
    SEMI_COLON      reduce using rule 69 (term10 -> term11 .)
    NEWLINE         reduce using rule 69 (term10 -> term11 .)
    puts            reduce using rule 69 (term10 -> term11 .)
    print           reduce using rule 69 (term10 -> term11 .)
    break           reduce using rule 69 (term10 -> term11 .)
    def             reduce using rule 69 (term10 -> term11 .)
    if              reduce using rule 69 (term10 -> term11 .)
    while           reduce using rule 69 (term10 -> term11 .)
    until           reduce using rule 69 (term10 -> term11 .)
    case            reduce using rule 69 (term10 -> term11 .)
    for             reduce using rule 69 (term10 -> term11 .)
    return          reduce using rule 69 (term10 -> term11 .)
    IDENTIFIER      reduce using rule 69 (term10 -> term11 .)
    nil             reduce using rule 69 (term10 -> term11 .)
    self            reduce using rule 69 (term10 -> term11 .)
    GLOBAL          reduce using rule 69 (term10 -> term11 .)
    AT_THE_RATE     reduce using rule 69 (term10 -> term11 .)
    OPEN_BRACKET    reduce using rule 69 (term10 -> term11 .)
    Array           reduce using rule 69 (term10 -> term11 .)
    NUMBER          reduce using rule 69 (term10 -> term11 .)
    FLOAT           reduce using rule 69 (term10 -> term11 .)
    STRING          reduce using rule 69 (term10 -> term11 .)
    true            reduce using rule 69 (term10 -> term11 .)
    false           reduce using rule 69 (term10 -> term11 .)
    $end            reduce using rule 69 (term10 -> term11 .)
    CLOSE_BRACKET   reduce using rule 69 (term10 -> term11 .)
    COMMA           reduce using rule 69 (term10 -> term11 .)
    do              reduce using rule 69 (term10 -> term11 .)


state 11

    (65) term9 -> term10 .
    (66) term10 -> term10 . MULTIPLY term11
    (67) term10 -> term10 . DIVIDE term11
    (68) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 65 (term9 -> term10 .)
    MINUS           reduce using rule 65 (term9 -> term10 .)
    LEFT_SHIFT      reduce using rule 65 (term9 -> term10 .)
    RIGHT_SHIFT     reduce using rule 65 (term9 -> term10 .)
    BIT_AND         reduce using rule 65 (term9 -> term10 .)
    BIT_XOR         reduce using rule 65 (term9 -> term10 .)
    BIT_OR          reduce using rule 65 (term9 -> term10 .)
    LESS            reduce using rule 65 (term9 -> term10 .)
    LESS_EQUALS     reduce using rule 65 (term9 -> term10 .)
    GREATER         reduce using rule 65 (term9 -> term10 .)
    GREATER_EQUALS  reduce using rule 65 (term9 -> term10 .)
    INCL_RANGE      reduce using rule 65 (term9 -> term10 .)
    EXCL_RANGE      reduce using rule 65 (term9 -> term10 .)
    LOGICAL_OR      reduce using rule 65 (term9 -> term10 .)
    SEMI_COLON      reduce using rule 65 (term9 -> term10 .)
    NEWLINE         reduce using rule 65 (term9 -> term10 .)
    puts            reduce using rule 65 (term9 -> term10 .)
    print           reduce using rule 65 (term9 -> term10 .)
    break           reduce using rule 65 (term9 -> term10 .)
    def             reduce using rule 65 (term9 -> term10 .)
    if              reduce using rule 65 (term9 -> term10 .)
    while           reduce using rule 65 (term9 -> term10 .)
    until           reduce using rule 65 (term9 -> term10 .)
    case            reduce using rule 65 (term9 -> term10 .)
    for             reduce using rule 65 (term9 -> term10 .)
    return          reduce using rule 65 (term9 -> term10 .)
    IDENTIFIER      reduce using rule 65 (term9 -> term10 .)
    nil             reduce using rule 65 (term9 -> term10 .)
    self            reduce using rule 65 (term9 -> term10 .)
    GLOBAL          reduce using rule 65 (term9 -> term10 .)
    AT_THE_RATE     reduce using rule 65 (term9 -> term10 .)
    OPEN_BRACKET    reduce using rule 65 (term9 -> term10 .)
    Array           reduce using rule 65 (term9 -> term10 .)
    NUMBER          reduce using rule 65 (term9 -> term10 .)
    FLOAT           reduce using rule 65 (term9 -> term10 .)
    STRING          reduce using rule 65 (term9 -> term10 .)
    true            reduce using rule 65 (term9 -> term10 .)
    false           reduce using rule 65 (term9 -> term10 .)
    $end            reduce using rule 65 (term9 -> term10 .)
    CLOSE_BRACKET   reduce using rule 65 (term9 -> term10 .)
    then            reduce using rule 65 (term9 -> term10 .)
    COMMA           reduce using rule 65 (term9 -> term10 .)
    do              reduce using rule 65 (term9 -> term10 .)
    DOUBLE_EQUALS   reduce using rule 65 (term9 -> term10 .)
    NOT_EQUALS      reduce using rule 65 (term9 -> term10 .)
    EQUAL_TILDE     reduce using rule 65 (term9 -> term10 .)
    COMPARISON      reduce using rule 65 (term9 -> term10 .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 86
    MODULO          shift and go to state 85


state 12

    (57) term6 -> term7 .
    (58) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 57 (term6 -> term7 .)
    BIT_OR          reduce using rule 57 (term6 -> term7 .)
    DOUBLE_EQUALS   reduce using rule 57 (term6 -> term7 .)
    NOT_EQUALS      reduce using rule 57 (term6 -> term7 .)
    EQUAL_TILDE     reduce using rule 57 (term6 -> term7 .)
    COMPARISON      reduce using rule 57 (term6 -> term7 .)
    LESS            reduce using rule 57 (term6 -> term7 .)
    LESS_EQUALS     reduce using rule 57 (term6 -> term7 .)
    GREATER         reduce using rule 57 (term6 -> term7 .)
    GREATER_EQUALS  reduce using rule 57 (term6 -> term7 .)
    INCL_RANGE      reduce using rule 57 (term6 -> term7 .)
    EXCL_RANGE      reduce using rule 57 (term6 -> term7 .)
    LOGICAL_OR      reduce using rule 57 (term6 -> term7 .)
    SEMI_COLON      reduce using rule 57 (term6 -> term7 .)
    NEWLINE         reduce using rule 57 (term6 -> term7 .)
    puts            reduce using rule 57 (term6 -> term7 .)
    print           reduce using rule 57 (term6 -> term7 .)
    break           reduce using rule 57 (term6 -> term7 .)
    def             reduce using rule 57 (term6 -> term7 .)
    if              reduce using rule 57 (term6 -> term7 .)
    while           reduce using rule 57 (term6 -> term7 .)
    until           reduce using rule 57 (term6 -> term7 .)
    case            reduce using rule 57 (term6 -> term7 .)
    for             reduce using rule 57 (term6 -> term7 .)
    return          reduce using rule 57 (term6 -> term7 .)
    IDENTIFIER      reduce using rule 57 (term6 -> term7 .)
    nil             reduce using rule 57 (term6 -> term7 .)
    self            reduce using rule 57 (term6 -> term7 .)
    GLOBAL          reduce using rule 57 (term6 -> term7 .)
    AT_THE_RATE     reduce using rule 57 (term6 -> term7 .)
    MINUS           reduce using rule 57 (term6 -> term7 .)
    PLUS            reduce using rule 57 (term6 -> term7 .)
    OPEN_BRACKET    reduce using rule 57 (term6 -> term7 .)
    Array           reduce using rule 57 (term6 -> term7 .)
    NUMBER          reduce using rule 57 (term6 -> term7 .)
    FLOAT           reduce using rule 57 (term6 -> term7 .)
    STRING          reduce using rule 57 (term6 -> term7 .)
    true            reduce using rule 57 (term6 -> term7 .)
    false           reduce using rule 57 (term6 -> term7 .)
    $end            reduce using rule 57 (term6 -> term7 .)
    CLOSE_BRACKET   reduce using rule 57 (term6 -> term7 .)
    then            reduce using rule 57 (term6 -> term7 .)
    COMMA           reduce using rule 57 (term6 -> term7 .)
    do              reduce using rule 57 (term6 -> term7 .)
    BIT_AND         shift and go to state 87


state 13

    (54) term5 -> term6 .
    (55) term6 -> term6 . BIT_XOR term7
    (56) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 54 (term5 -> term6 .)
    NOT_EQUALS      reduce using rule 54 (term5 -> term6 .)
    EQUAL_TILDE     reduce using rule 54 (term5 -> term6 .)
    COMPARISON      reduce using rule 54 (term5 -> term6 .)
    LESS            reduce using rule 54 (term5 -> term6 .)
    LESS_EQUALS     reduce using rule 54 (term5 -> term6 .)
    GREATER         reduce using rule 54 (term5 -> term6 .)
    GREATER_EQUALS  reduce using rule 54 (term5 -> term6 .)
    INCL_RANGE      reduce using rule 54 (term5 -> term6 .)
    EXCL_RANGE      reduce using rule 54 (term5 -> term6 .)
    LOGICAL_OR      reduce using rule 54 (term5 -> term6 .)
    SEMI_COLON      reduce using rule 54 (term5 -> term6 .)
    NEWLINE         reduce using rule 54 (term5 -> term6 .)
    puts            reduce using rule 54 (term5 -> term6 .)
    print           reduce using rule 54 (term5 -> term6 .)
    break           reduce using rule 54 (term5 -> term6 .)
    def             reduce using rule 54 (term5 -> term6 .)
    if              reduce using rule 54 (term5 -> term6 .)
    while           reduce using rule 54 (term5 -> term6 .)
    until           reduce using rule 54 (term5 -> term6 .)
    case            reduce using rule 54 (term5 -> term6 .)
    for             reduce using rule 54 (term5 -> term6 .)
    return          reduce using rule 54 (term5 -> term6 .)
    IDENTIFIER      reduce using rule 54 (term5 -> term6 .)
    nil             reduce using rule 54 (term5 -> term6 .)
    self            reduce using rule 54 (term5 -> term6 .)
    GLOBAL          reduce using rule 54 (term5 -> term6 .)
    AT_THE_RATE     reduce using rule 54 (term5 -> term6 .)
    MINUS           reduce using rule 54 (term5 -> term6 .)
    PLUS            reduce using rule 54 (term5 -> term6 .)
    OPEN_BRACKET    reduce using rule 54 (term5 -> term6 .)
    Array           reduce using rule 54 (term5 -> term6 .)
    NUMBER          reduce using rule 54 (term5 -> term6 .)
    FLOAT           reduce using rule 54 (term5 -> term6 .)
    STRING          reduce using rule 54 (term5 -> term6 .)
    true            reduce using rule 54 (term5 -> term6 .)
    false           reduce using rule 54 (term5 -> term6 .)
    $end            reduce using rule 54 (term5 -> term6 .)
    CLOSE_BRACKET   reduce using rule 54 (term5 -> term6 .)
    then            reduce using rule 54 (term5 -> term6 .)
    COMMA           reduce using rule 54 (term5 -> term6 .)
    do              reduce using rule 54 (term5 -> term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 14

    (45) term4 -> term5 . DOUBLE_EQUALS term5
    (46) term4 -> term5 . NOT_EQUALS term5
    (47) term4 -> term5 . EQUAL_TILDE term5
    (48) term4 -> term5 . COMPARISON term5
    (49) term4 -> term5 .
    (50) term5 -> term5 . LESS term6
    (51) term5 -> term5 . LESS_EQUALS term6
    (52) term5 -> term5 . GREATER term6
    (53) term5 -> term5 . GREATER_EQUALS term6

    DOUBLE_EQUALS   shift and go to state 91
    NOT_EQUALS      shift and go to state 94
    EQUAL_TILDE     shift and go to state 96
    COMPARISON      shift and go to state 90
    INCL_RANGE      reduce using rule 49 (term4 -> term5 .)
    EXCL_RANGE      reduce using rule 49 (term4 -> term5 .)
    LOGICAL_OR      reduce using rule 49 (term4 -> term5 .)
    COMMA           reduce using rule 49 (term4 -> term5 .)
    SEMI_COLON      reduce using rule 49 (term4 -> term5 .)
    NEWLINE         reduce using rule 49 (term4 -> term5 .)
    puts            reduce using rule 49 (term4 -> term5 .)
    print           reduce using rule 49 (term4 -> term5 .)
    break           reduce using rule 49 (term4 -> term5 .)
    def             reduce using rule 49 (term4 -> term5 .)
    if              reduce using rule 49 (term4 -> term5 .)
    while           reduce using rule 49 (term4 -> term5 .)
    until           reduce using rule 49 (term4 -> term5 .)
    case            reduce using rule 49 (term4 -> term5 .)
    for             reduce using rule 49 (term4 -> term5 .)
    return          reduce using rule 49 (term4 -> term5 .)
    IDENTIFIER      reduce using rule 49 (term4 -> term5 .)
    nil             reduce using rule 49 (term4 -> term5 .)
    self            reduce using rule 49 (term4 -> term5 .)
    GLOBAL          reduce using rule 49 (term4 -> term5 .)
    AT_THE_RATE     reduce using rule 49 (term4 -> term5 .)
    MINUS           reduce using rule 49 (term4 -> term5 .)
    PLUS            reduce using rule 49 (term4 -> term5 .)
    OPEN_BRACKET    reduce using rule 49 (term4 -> term5 .)
    Array           reduce using rule 49 (term4 -> term5 .)
    NUMBER          reduce using rule 49 (term4 -> term5 .)
    FLOAT           reduce using rule 49 (term4 -> term5 .)
    STRING          reduce using rule 49 (term4 -> term5 .)
    true            reduce using rule 49 (term4 -> term5 .)
    false           reduce using rule 49 (term4 -> term5 .)
    $end            reduce using rule 49 (term4 -> term5 .)
    CLOSE_BRACKET   reduce using rule 49 (term4 -> term5 .)
    then            reduce using rule 49 (term4 -> term5 .)
    do              reduce using rule 49 (term4 -> term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 15

    (44) term3 -> term4 .

    INCL_RANGE      reduce using rule 44 (term3 -> term4 .)
    EXCL_RANGE      reduce using rule 44 (term3 -> term4 .)
    LOGICAL_OR      reduce using rule 44 (term3 -> term4 .)
    SEMI_COLON      reduce using rule 44 (term3 -> term4 .)
    NEWLINE         reduce using rule 44 (term3 -> term4 .)
    puts            reduce using rule 44 (term3 -> term4 .)
    print           reduce using rule 44 (term3 -> term4 .)
    break           reduce using rule 44 (term3 -> term4 .)
    def             reduce using rule 44 (term3 -> term4 .)
    if              reduce using rule 44 (term3 -> term4 .)
    while           reduce using rule 44 (term3 -> term4 .)
    until           reduce using rule 44 (term3 -> term4 .)
    case            reduce using rule 44 (term3 -> term4 .)
    for             reduce using rule 44 (term3 -> term4 .)
    return          reduce using rule 44 (term3 -> term4 .)
    IDENTIFIER      reduce using rule 44 (term3 -> term4 .)
    nil             reduce using rule 44 (term3 -> term4 .)
    self            reduce using rule 44 (term3 -> term4 .)
    GLOBAL          reduce using rule 44 (term3 -> term4 .)
    AT_THE_RATE     reduce using rule 44 (term3 -> term4 .)
    MINUS           reduce using rule 44 (term3 -> term4 .)
    PLUS            reduce using rule 44 (term3 -> term4 .)
    OPEN_BRACKET    reduce using rule 44 (term3 -> term4 .)
    Array           reduce using rule 44 (term3 -> term4 .)
    NUMBER          reduce using rule 44 (term3 -> term4 .)
    FLOAT           reduce using rule 44 (term3 -> term4 .)
    STRING          reduce using rule 44 (term3 -> term4 .)
    true            reduce using rule 44 (term3 -> term4 .)
    false           reduce using rule 44 (term3 -> term4 .)
    $end            reduce using rule 44 (term3 -> term4 .)
    CLOSE_BRACKET   reduce using rule 44 (term3 -> term4 .)
    then            reduce using rule 44 (term3 -> term4 .)
    COMMA           reduce using rule 44 (term3 -> term4 .)
    do              reduce using rule 44 (term3 -> term4 .)


state 16

    (40) term2 -> term3 . INCL_RANGE term3
    (41) term2 -> term3 . EXCL_RANGE term3
    (42) term2 -> term3 .
    (43) term3 -> term3 . LOGICAL_OR term4

    INCL_RANGE      shift and go to state 98
    EXCL_RANGE      shift and go to state 99
    SEMI_COLON      reduce using rule 42 (term2 -> term3 .)
    NEWLINE         reduce using rule 42 (term2 -> term3 .)
    puts            reduce using rule 42 (term2 -> term3 .)
    print           reduce using rule 42 (term2 -> term3 .)
    break           reduce using rule 42 (term2 -> term3 .)
    def             reduce using rule 42 (term2 -> term3 .)
    if              reduce using rule 42 (term2 -> term3 .)
    while           reduce using rule 42 (term2 -> term3 .)
    until           reduce using rule 42 (term2 -> term3 .)
    case            reduce using rule 42 (term2 -> term3 .)
    for             reduce using rule 42 (term2 -> term3 .)
    return          reduce using rule 42 (term2 -> term3 .)
    IDENTIFIER      reduce using rule 42 (term2 -> term3 .)
    nil             reduce using rule 42 (term2 -> term3 .)
    self            reduce using rule 42 (term2 -> term3 .)
    GLOBAL          reduce using rule 42 (term2 -> term3 .)
    AT_THE_RATE     reduce using rule 42 (term2 -> term3 .)
    MINUS           reduce using rule 42 (term2 -> term3 .)
    PLUS            reduce using rule 42 (term2 -> term3 .)
    OPEN_BRACKET    reduce using rule 42 (term2 -> term3 .)
    Array           reduce using rule 42 (term2 -> term3 .)
    NUMBER          reduce using rule 42 (term2 -> term3 .)
    FLOAT           reduce using rule 42 (term2 -> term3 .)
    STRING          reduce using rule 42 (term2 -> term3 .)
    true            reduce using rule 42 (term2 -> term3 .)
    false           reduce using rule 42 (term2 -> term3 .)
    $end            reduce using rule 42 (term2 -> term3 .)
    CLOSE_BRACKET   reduce using rule 42 (term2 -> term3 .)
    then            reduce using rule 42 (term2 -> term3 .)
    COMMA           reduce using rule 42 (term2 -> term3 .)
    do              reduce using rule 42 (term2 -> term3 .)
    LOGICAL_OR      shift and go to state 100


state 17

    (39) term1 -> term2 .

    SEMI_COLON      reduce using rule 39 (term1 -> term2 .)
    NEWLINE         reduce using rule 39 (term1 -> term2 .)
    COMMA           reduce using rule 39 (term1 -> term2 .)
    then            reduce using rule 39 (term1 -> term2 .)
    do              reduce using rule 39 (term1 -> term2 .)
    puts            reduce using rule 39 (term1 -> term2 .)
    print           reduce using rule 39 (term1 -> term2 .)
    break           reduce using rule 39 (term1 -> term2 .)
    def             reduce using rule 39 (term1 -> term2 .)
    if              reduce using rule 39 (term1 -> term2 .)
    while           reduce using rule 39 (term1 -> term2 .)
    until           reduce using rule 39 (term1 -> term2 .)
    case            reduce using rule 39 (term1 -> term2 .)
    for             reduce using rule 39 (term1 -> term2 .)
    return          reduce using rule 39 (term1 -> term2 .)
    IDENTIFIER      reduce using rule 39 (term1 -> term2 .)
    nil             reduce using rule 39 (term1 -> term2 .)
    self            reduce using rule 39 (term1 -> term2 .)
    GLOBAL          reduce using rule 39 (term1 -> term2 .)
    AT_THE_RATE     reduce using rule 39 (term1 -> term2 .)
    MINUS           reduce using rule 39 (term1 -> term2 .)
    PLUS            reduce using rule 39 (term1 -> term2 .)
    OPEN_BRACKET    reduce using rule 39 (term1 -> term2 .)
    Array           reduce using rule 39 (term1 -> term2 .)
    NUMBER          reduce using rule 39 (term1 -> term2 .)
    FLOAT           reduce using rule 39 (term1 -> term2 .)
    STRING          reduce using rule 39 (term1 -> term2 .)
    true            reduce using rule 39 (term1 -> term2 .)
    false           reduce using rule 39 (term1 -> term2 .)
    $end            reduce using rule 39 (term1 -> term2 .)
    CLOSE_BRACKET   reduce using rule 39 (term1 -> term2 .)


state 18

    (36) term0 -> term1 .

    SEMI_COLON      reduce using rule 36 (term0 -> term1 .)
    NEWLINE         reduce using rule 36 (term0 -> term1 .)
    do              reduce using rule 36 (term0 -> term1 .)
    then            reduce using rule 36 (term0 -> term1 .)
    COMMA           reduce using rule 36 (term0 -> term1 .)
    puts            reduce using rule 36 (term0 -> term1 .)
    print           reduce using rule 36 (term0 -> term1 .)
    break           reduce using rule 36 (term0 -> term1 .)
    def             reduce using rule 36 (term0 -> term1 .)
    if              reduce using rule 36 (term0 -> term1 .)
    while           reduce using rule 36 (term0 -> term1 .)
    until           reduce using rule 36 (term0 -> term1 .)
    case            reduce using rule 36 (term0 -> term1 .)
    for             reduce using rule 36 (term0 -> term1 .)
    return          reduce using rule 36 (term0 -> term1 .)
    IDENTIFIER      reduce using rule 36 (term0 -> term1 .)
    nil             reduce using rule 36 (term0 -> term1 .)
    self            reduce using rule 36 (term0 -> term1 .)
    GLOBAL          reduce using rule 36 (term0 -> term1 .)
    AT_THE_RATE     reduce using rule 36 (term0 -> term1 .)
    MINUS           reduce using rule 36 (term0 -> term1 .)
    PLUS            reduce using rule 36 (term0 -> term1 .)
    OPEN_BRACKET    reduce using rule 36 (term0 -> term1 .)
    Array           reduce using rule 36 (term0 -> term1 .)
    NUMBER          reduce using rule 36 (term0 -> term1 .)
    FLOAT           reduce using rule 36 (term0 -> term1 .)
    STRING          reduce using rule 36 (term0 -> term1 .)
    true            reduce using rule 36 (term0 -> term1 .)
    false           reduce using rule 36 (term0 -> term1 .)
    $end            reduce using rule 36 (term0 -> term1 .)
    CLOSE_BRACKET   reduce using rule 36 (term0 -> term1 .)


state 19

    (33) arg -> term0 .

    do              reduce using rule 33 (arg -> term0 .)
    SEMI_COLON      reduce using rule 33 (arg -> term0 .)
    NEWLINE         reduce using rule 33 (arg -> term0 .)
    COMMA           reduce using rule 33 (arg -> term0 .)
    then            reduce using rule 33 (arg -> term0 .)
    puts            reduce using rule 33 (arg -> term0 .)
    print           reduce using rule 33 (arg -> term0 .)
    break           reduce using rule 33 (arg -> term0 .)
    def             reduce using rule 33 (arg -> term0 .)
    if              reduce using rule 33 (arg -> term0 .)
    while           reduce using rule 33 (arg -> term0 .)
    until           reduce using rule 33 (arg -> term0 .)
    case            reduce using rule 33 (arg -> term0 .)
    for             reduce using rule 33 (arg -> term0 .)
    return          reduce using rule 33 (arg -> term0 .)
    IDENTIFIER      reduce using rule 33 (arg -> term0 .)
    nil             reduce using rule 33 (arg -> term0 .)
    self            reduce using rule 33 (arg -> term0 .)
    GLOBAL          reduce using rule 33 (arg -> term0 .)
    AT_THE_RATE     reduce using rule 33 (arg -> term0 .)
    MINUS           reduce using rule 33 (arg -> term0 .)
    PLUS            reduce using rule 33 (arg -> term0 .)
    OPEN_BRACKET    reduce using rule 33 (arg -> term0 .)
    Array           reduce using rule 33 (arg -> term0 .)
    NUMBER          reduce using rule 33 (arg -> term0 .)
    FLOAT           reduce using rule 33 (arg -> term0 .)
    STRING          reduce using rule 33 (arg -> term0 .)
    true            reduce using rule 33 (arg -> term0 .)
    false           reduce using rule 33 (arg -> term0 .)
    $end            reduce using rule 33 (arg -> term0 .)
    CLOSE_BRACKET   reduce using rule 33 (arg -> term0 .)


state 20

    (62) term8 -> term9 .
    (63) term9 -> term9 . PLUS term10
    (64) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 62 (term8 -> term9 .)
    RIGHT_SHIFT     reduce using rule 62 (term8 -> term9 .)
    BIT_AND         reduce using rule 62 (term8 -> term9 .)
    BIT_XOR         reduce using rule 62 (term8 -> term9 .)
    BIT_OR          reduce using rule 62 (term8 -> term9 .)
    DOUBLE_EQUALS   reduce using rule 62 (term8 -> term9 .)
    NOT_EQUALS      reduce using rule 62 (term8 -> term9 .)
    EQUAL_TILDE     reduce using rule 62 (term8 -> term9 .)
    COMPARISON      reduce using rule 62 (term8 -> term9 .)
    LESS            reduce using rule 62 (term8 -> term9 .)
    LESS_EQUALS     reduce using rule 62 (term8 -> term9 .)
    GREATER         reduce using rule 62 (term8 -> term9 .)
    GREATER_EQUALS  reduce using rule 62 (term8 -> term9 .)
    INCL_RANGE      reduce using rule 62 (term8 -> term9 .)
    EXCL_RANGE      reduce using rule 62 (term8 -> term9 .)
    LOGICAL_OR      reduce using rule 62 (term8 -> term9 .)
    SEMI_COLON      reduce using rule 62 (term8 -> term9 .)
    NEWLINE         reduce using rule 62 (term8 -> term9 .)
    puts            reduce using rule 62 (term8 -> term9 .)
    print           reduce using rule 62 (term8 -> term9 .)
    break           reduce using rule 62 (term8 -> term9 .)
    def             reduce using rule 62 (term8 -> term9 .)
    if              reduce using rule 62 (term8 -> term9 .)
    while           reduce using rule 62 (term8 -> term9 .)
    until           reduce using rule 62 (term8 -> term9 .)
    case            reduce using rule 62 (term8 -> term9 .)
    for             reduce using rule 62 (term8 -> term9 .)
    return          reduce using rule 62 (term8 -> term9 .)
    IDENTIFIER      reduce using rule 62 (term8 -> term9 .)
    nil             reduce using rule 62 (term8 -> term9 .)
    self            reduce using rule 62 (term8 -> term9 .)
    GLOBAL          reduce using rule 62 (term8 -> term9 .)
    AT_THE_RATE     reduce using rule 62 (term8 -> term9 .)
    OPEN_BRACKET    reduce using rule 62 (term8 -> term9 .)
    Array           reduce using rule 62 (term8 -> term9 .)
    NUMBER          reduce using rule 62 (term8 -> term9 .)
    FLOAT           reduce using rule 62 (term8 -> term9 .)
    STRING          reduce using rule 62 (term8 -> term9 .)
    true            reduce using rule 62 (term8 -> term9 .)
    false           reduce using rule 62 (term8 -> term9 .)
    $end            reduce using rule 62 (term8 -> term9 .)
    CLOSE_BRACKET   reduce using rule 62 (term8 -> term9 .)
    then            reduce using rule 62 (term8 -> term9 .)
    COMMA           reduce using rule 62 (term8 -> term9 .)
    do              reduce using rule 62 (term8 -> term9 .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102

  ! MINUS           [ reduce using rule 62 (term8 -> term9 .) ]
  ! PLUS            [ reduce using rule 62 (term8 -> term9 .) ]


state 21

    (147) varname -> AT_THE_RATE . IDENTIFIER

    IDENTIFIER      shift and go to state 103


state 22

    (149) newline -> SEMI_COLON .

    then            reduce using rule 149 (newline -> SEMI_COLON .)
    puts            reduce using rule 149 (newline -> SEMI_COLON .)
    print           reduce using rule 149 (newline -> SEMI_COLON .)
    break           reduce using rule 149 (newline -> SEMI_COLON .)
    def             reduce using rule 149 (newline -> SEMI_COLON .)
    if              reduce using rule 149 (newline -> SEMI_COLON .)
    while           reduce using rule 149 (newline -> SEMI_COLON .)
    until           reduce using rule 149 (newline -> SEMI_COLON .)
    case            reduce using rule 149 (newline -> SEMI_COLON .)
    for             reduce using rule 149 (newline -> SEMI_COLON .)
    return          reduce using rule 149 (newline -> SEMI_COLON .)
    IDENTIFIER      reduce using rule 149 (newline -> SEMI_COLON .)
    nil             reduce using rule 149 (newline -> SEMI_COLON .)
    self            reduce using rule 149 (newline -> SEMI_COLON .)
    GLOBAL          reduce using rule 149 (newline -> SEMI_COLON .)
    AT_THE_RATE     reduce using rule 149 (newline -> SEMI_COLON .)
    MINUS           reduce using rule 149 (newline -> SEMI_COLON .)
    PLUS            reduce using rule 149 (newline -> SEMI_COLON .)
    OPEN_BRACKET    reduce using rule 149 (newline -> SEMI_COLON .)
    Array           reduce using rule 149 (newline -> SEMI_COLON .)
    NUMBER          reduce using rule 149 (newline -> SEMI_COLON .)
    FLOAT           reduce using rule 149 (newline -> SEMI_COLON .)
    STRING          reduce using rule 149 (newline -> SEMI_COLON .)
    true            reduce using rule 149 (newline -> SEMI_COLON .)
    false           reduce using rule 149 (newline -> SEMI_COLON .)
    else            reduce using rule 149 (newline -> SEMI_COLON .)
    end             reduce using rule 149 (newline -> SEMI_COLON .)
    elsif           reduce using rule 149 (newline -> SEMI_COLON .)
    do              reduce using rule 149 (newline -> SEMI_COLON .)
    $end            reduce using rule 149 (newline -> SEMI_COLON .)
    when            reduce using rule 149 (newline -> SEMI_COLON .)


state 23

    (28) expr2 -> arg .

    SEMI_COLON      reduce using rule 28 (expr2 -> arg .)
    NEWLINE         reduce using rule 28 (expr2 -> arg .)
    then            reduce using rule 28 (expr2 -> arg .)
    puts            reduce using rule 28 (expr2 -> arg .)
    print           reduce using rule 28 (expr2 -> arg .)
    break           reduce using rule 28 (expr2 -> arg .)
    def             reduce using rule 28 (expr2 -> arg .)
    if              reduce using rule 28 (expr2 -> arg .)
    while           reduce using rule 28 (expr2 -> arg .)
    until           reduce using rule 28 (expr2 -> arg .)
    case            reduce using rule 28 (expr2 -> arg .)
    for             reduce using rule 28 (expr2 -> arg .)
    return          reduce using rule 28 (expr2 -> arg .)
    IDENTIFIER      reduce using rule 28 (expr2 -> arg .)
    nil             reduce using rule 28 (expr2 -> arg .)
    self            reduce using rule 28 (expr2 -> arg .)
    GLOBAL          reduce using rule 28 (expr2 -> arg .)
    AT_THE_RATE     reduce using rule 28 (expr2 -> arg .)
    MINUS           reduce using rule 28 (expr2 -> arg .)
    PLUS            reduce using rule 28 (expr2 -> arg .)
    OPEN_BRACKET    reduce using rule 28 (expr2 -> arg .)
    Array           reduce using rule 28 (expr2 -> arg .)
    NUMBER          reduce using rule 28 (expr2 -> arg .)
    FLOAT           reduce using rule 28 (expr2 -> arg .)
    STRING          reduce using rule 28 (expr2 -> arg .)
    true            reduce using rule 28 (expr2 -> arg .)
    false           reduce using rule 28 (expr2 -> arg .)
    $end            reduce using rule 28 (expr2 -> arg .)
    do              reduce using rule 28 (expr2 -> arg .)
    CLOSE_BRACKET   reduce using rule 28 (expr2 -> arg .)


state 24

    (22) expr -> for . M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 104
    empty                          shift and go to state 105

state 25

    (9) stmt -> print . OPEN_BRACKET primary CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 106


state 26

    (6) stmt1 -> stmt .

    SEMI_COLON      reduce using rule 6 (stmt1 -> stmt .)
    NEWLINE         reduce using rule 6 (stmt1 -> stmt .)
    puts            reduce using rule 6 (stmt1 -> stmt .)
    print           reduce using rule 6 (stmt1 -> stmt .)
    break           reduce using rule 6 (stmt1 -> stmt .)
    def             reduce using rule 6 (stmt1 -> stmt .)
    if              reduce using rule 6 (stmt1 -> stmt .)
    while           reduce using rule 6 (stmt1 -> stmt .)
    until           reduce using rule 6 (stmt1 -> stmt .)
    case            reduce using rule 6 (stmt1 -> stmt .)
    for             reduce using rule 6 (stmt1 -> stmt .)
    return          reduce using rule 6 (stmt1 -> stmt .)
    IDENTIFIER      reduce using rule 6 (stmt1 -> stmt .)
    nil             reduce using rule 6 (stmt1 -> stmt .)
    self            reduce using rule 6 (stmt1 -> stmt .)
    GLOBAL          reduce using rule 6 (stmt1 -> stmt .)
    AT_THE_RATE     reduce using rule 6 (stmt1 -> stmt .)
    MINUS           reduce using rule 6 (stmt1 -> stmt .)
    PLUS            reduce using rule 6 (stmt1 -> stmt .)
    OPEN_BRACKET    reduce using rule 6 (stmt1 -> stmt .)
    Array           reduce using rule 6 (stmt1 -> stmt .)
    NUMBER          reduce using rule 6 (stmt1 -> stmt .)
    FLOAT           reduce using rule 6 (stmt1 -> stmt .)
    STRING          reduce using rule 6 (stmt1 -> stmt .)
    true            reduce using rule 6 (stmt1 -> stmt .)
    false           reduce using rule 6 (stmt1 -> stmt .)
    $end            reduce using rule 6 (stmt1 -> stmt .)


state 27

    (0) S' -> compstmt .



state 28

    (125) variable -> varname .
    (79) primary -> varname .

    OPEN_SQUARE     reduce using rule 125 (variable -> varname .)
    MULTIPLY        reduce using rule 79 (primary -> varname .)
    DIVIDE          reduce using rule 79 (primary -> varname .)
    MODULO          reduce using rule 79 (primary -> varname .)
    PLUS            reduce using rule 79 (primary -> varname .)
    MINUS           reduce using rule 79 (primary -> varname .)
    LEFT_SHIFT      reduce using rule 79 (primary -> varname .)
    RIGHT_SHIFT     reduce using rule 79 (primary -> varname .)
    BIT_AND         reduce using rule 79 (primary -> varname .)
    BIT_XOR         reduce using rule 79 (primary -> varname .)
    BIT_OR          reduce using rule 79 (primary -> varname .)
    DOUBLE_EQUALS   reduce using rule 79 (primary -> varname .)
    NOT_EQUALS      reduce using rule 79 (primary -> varname .)
    EQUAL_TILDE     reduce using rule 79 (primary -> varname .)
    COMPARISON      reduce using rule 79 (primary -> varname .)
    LESS            reduce using rule 79 (primary -> varname .)
    LESS_EQUALS     reduce using rule 79 (primary -> varname .)
    GREATER         reduce using rule 79 (primary -> varname .)
    GREATER_EQUALS  reduce using rule 79 (primary -> varname .)
    INCL_RANGE      reduce using rule 79 (primary -> varname .)
    EXCL_RANGE      reduce using rule 79 (primary -> varname .)
    LOGICAL_OR      reduce using rule 79 (primary -> varname .)
    CLOSE_BRACKET   reduce using rule 79 (primary -> varname .)
    SEMI_COLON      reduce using rule 79 (primary -> varname .)
    NEWLINE         reduce using rule 79 (primary -> varname .)
    puts            reduce using rule 79 (primary -> varname .)
    print           reduce using rule 79 (primary -> varname .)
    break           reduce using rule 79 (primary -> varname .)
    def             reduce using rule 79 (primary -> varname .)
    if              reduce using rule 79 (primary -> varname .)
    while           reduce using rule 79 (primary -> varname .)
    until           reduce using rule 79 (primary -> varname .)
    case            reduce using rule 79 (primary -> varname .)
    for             reduce using rule 79 (primary -> varname .)
    return          reduce using rule 79 (primary -> varname .)
    IDENTIFIER      reduce using rule 79 (primary -> varname .)
    nil             reduce using rule 79 (primary -> varname .)
    self            reduce using rule 79 (primary -> varname .)
    GLOBAL          reduce using rule 79 (primary -> varname .)
    AT_THE_RATE     reduce using rule 79 (primary -> varname .)
    OPEN_BRACKET    reduce using rule 79 (primary -> varname .)
    Array           reduce using rule 79 (primary -> varname .)
    NUMBER          reduce using rule 79 (primary -> varname .)
    FLOAT           reduce using rule 79 (primary -> varname .)
    STRING          reduce using rule 79 (primary -> varname .)
    true            reduce using rule 79 (primary -> varname .)
    false           reduce using rule 79 (primary -> varname .)
    $end            reduce using rule 79 (primary -> varname .)
    then            reduce using rule 79 (primary -> varname .)
    COMMA           reduce using rule 79 (primary -> varname .)
    do              reduce using rule 79 (primary -> varname .)


state 29

    (3) multcompstmt -> stmt1 . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (5) multcompstmt -> . empty
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE
    (6) stmt1 -> . stmt
    (151) empty -> .
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3
    $end            reduce using rule 151 (empty -> .)
    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 38
    function                       shift and go to state 39
    newline                        shift and go to state 57
    multcompstmt                   shift and go to state 107
    stmt                           shift and go to state 26
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    stmt1                          shift and go to state 29
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 30

    (146) varname -> GLOBAL .

    OPEN_SQUARE     reduce using rule 146 (varname -> GLOBAL .)
    MULTIPLY        reduce using rule 146 (varname -> GLOBAL .)
    DIVIDE          reduce using rule 146 (varname -> GLOBAL .)
    MODULO          reduce using rule 146 (varname -> GLOBAL .)
    PLUS            reduce using rule 146 (varname -> GLOBAL .)
    MINUS           reduce using rule 146 (varname -> GLOBAL .)
    LEFT_SHIFT      reduce using rule 146 (varname -> GLOBAL .)
    RIGHT_SHIFT     reduce using rule 146 (varname -> GLOBAL .)
    BIT_AND         reduce using rule 146 (varname -> GLOBAL .)
    BIT_XOR         reduce using rule 146 (varname -> GLOBAL .)
    BIT_OR          reduce using rule 146 (varname -> GLOBAL .)
    DOUBLE_EQUALS   reduce using rule 146 (varname -> GLOBAL .)
    NOT_EQUALS      reduce using rule 146 (varname -> GLOBAL .)
    EQUAL_TILDE     reduce using rule 146 (varname -> GLOBAL .)
    COMPARISON      reduce using rule 146 (varname -> GLOBAL .)
    LESS            reduce using rule 146 (varname -> GLOBAL .)
    LESS_EQUALS     reduce using rule 146 (varname -> GLOBAL .)
    GREATER         reduce using rule 146 (varname -> GLOBAL .)
    GREATER_EQUALS  reduce using rule 146 (varname -> GLOBAL .)
    INCL_RANGE      reduce using rule 146 (varname -> GLOBAL .)
    EXCL_RANGE      reduce using rule 146 (varname -> GLOBAL .)
    LOGICAL_OR      reduce using rule 146 (varname -> GLOBAL .)
    then            reduce using rule 146 (varname -> GLOBAL .)
    SEMI_COLON      reduce using rule 146 (varname -> GLOBAL .)
    NEWLINE         reduce using rule 146 (varname -> GLOBAL .)
    puts            reduce using rule 146 (varname -> GLOBAL .)
    print           reduce using rule 146 (varname -> GLOBAL .)
    break           reduce using rule 146 (varname -> GLOBAL .)
    def             reduce using rule 146 (varname -> GLOBAL .)
    if              reduce using rule 146 (varname -> GLOBAL .)
    while           reduce using rule 146 (varname -> GLOBAL .)
    until           reduce using rule 146 (varname -> GLOBAL .)
    case            reduce using rule 146 (varname -> GLOBAL .)
    for             reduce using rule 146 (varname -> GLOBAL .)
    return          reduce using rule 146 (varname -> GLOBAL .)
    IDENTIFIER      reduce using rule 146 (varname -> GLOBAL .)
    nil             reduce using rule 146 (varname -> GLOBAL .)
    self            reduce using rule 146 (varname -> GLOBAL .)
    GLOBAL          reduce using rule 146 (varname -> GLOBAL .)
    AT_THE_RATE     reduce using rule 146 (varname -> GLOBAL .)
    OPEN_BRACKET    reduce using rule 146 (varname -> GLOBAL .)
    Array           reduce using rule 146 (varname -> GLOBAL .)
    NUMBER          reduce using rule 146 (varname -> GLOBAL .)
    FLOAT           reduce using rule 146 (varname -> GLOBAL .)
    STRING          reduce using rule 146 (varname -> GLOBAL .)
    true            reduce using rule 146 (varname -> GLOBAL .)
    false           reduce using rule 146 (varname -> GLOBAL .)
    $end            reduce using rule 146 (varname -> GLOBAL .)
    CLOSE_BRACKET   reduce using rule 146 (varname -> GLOBAL .)
    COMMA           reduce using rule 146 (varname -> GLOBAL .)
    do              reduce using rule 146 (varname -> GLOBAL .)
    CLOSE_SQUARE    reduce using rule 146 (varname -> GLOBAL .)


state 31

    (74) term13 -> primary .

    MULTIPLY        reduce using rule 74 (term13 -> primary .)
    DIVIDE          reduce using rule 74 (term13 -> primary .)
    MODULO          reduce using rule 74 (term13 -> primary .)
    PLUS            reduce using rule 74 (term13 -> primary .)
    MINUS           reduce using rule 74 (term13 -> primary .)
    LEFT_SHIFT      reduce using rule 74 (term13 -> primary .)
    RIGHT_SHIFT     reduce using rule 74 (term13 -> primary .)
    BIT_AND         reduce using rule 74 (term13 -> primary .)
    BIT_XOR         reduce using rule 74 (term13 -> primary .)
    BIT_OR          reduce using rule 74 (term13 -> primary .)
    DOUBLE_EQUALS   reduce using rule 74 (term13 -> primary .)
    NOT_EQUALS      reduce using rule 74 (term13 -> primary .)
    EQUAL_TILDE     reduce using rule 74 (term13 -> primary .)
    COMPARISON      reduce using rule 74 (term13 -> primary .)
    LESS            reduce using rule 74 (term13 -> primary .)
    LESS_EQUALS     reduce using rule 74 (term13 -> primary .)
    GREATER         reduce using rule 74 (term13 -> primary .)
    GREATER_EQUALS  reduce using rule 74 (term13 -> primary .)
    INCL_RANGE      reduce using rule 74 (term13 -> primary .)
    EXCL_RANGE      reduce using rule 74 (term13 -> primary .)
    LOGICAL_OR      reduce using rule 74 (term13 -> primary .)
    SEMI_COLON      reduce using rule 74 (term13 -> primary .)
    NEWLINE         reduce using rule 74 (term13 -> primary .)
    puts            reduce using rule 74 (term13 -> primary .)
    print           reduce using rule 74 (term13 -> primary .)
    break           reduce using rule 74 (term13 -> primary .)
    def             reduce using rule 74 (term13 -> primary .)
    if              reduce using rule 74 (term13 -> primary .)
    while           reduce using rule 74 (term13 -> primary .)
    until           reduce using rule 74 (term13 -> primary .)
    case            reduce using rule 74 (term13 -> primary .)
    for             reduce using rule 74 (term13 -> primary .)
    return          reduce using rule 74 (term13 -> primary .)
    IDENTIFIER      reduce using rule 74 (term13 -> primary .)
    nil             reduce using rule 74 (term13 -> primary .)
    self            reduce using rule 74 (term13 -> primary .)
    GLOBAL          reduce using rule 74 (term13 -> primary .)
    AT_THE_RATE     reduce using rule 74 (term13 -> primary .)
    OPEN_BRACKET    reduce using rule 74 (term13 -> primary .)
    Array           reduce using rule 74 (term13 -> primary .)
    NUMBER          reduce using rule 74 (term13 -> primary .)
    FLOAT           reduce using rule 74 (term13 -> primary .)
    STRING          reduce using rule 74 (term13 -> primary .)
    true            reduce using rule 74 (term13 -> primary .)
    false           reduce using rule 74 (term13 -> primary .)
    $end            reduce using rule 74 (term13 -> primary .)
    CLOSE_BRACKET   reduce using rule 74 (term13 -> primary .)
    then            reduce using rule 74 (term13 -> primary .)
    COMMA           reduce using rule 74 (term13 -> primary .)
    do              reduce using rule 74 (term13 -> primary .)


state 32

    (100) mlhsitem -> arrayal .

    EQUALS          reduce using rule 100 (mlhsitem -> arrayal .)
    MODULO_EQUALS   reduce using rule 100 (mlhsitem -> arrayal .)
    DIVIDE_EQUALS   reduce using rule 100 (mlhsitem -> arrayal .)
    MINUS_EQUALS    reduce using rule 100 (mlhsitem -> arrayal .)
    PLUS_EQUALS     reduce using rule 100 (mlhsitem -> arrayal .)
    OR_EQUALS       reduce using rule 100 (mlhsitem -> arrayal .)
    AND_EQUALS      reduce using rule 100 (mlhsitem -> arrayal .)
    XOR_EQUALS      reduce using rule 100 (mlhsitem -> arrayal .)
    RIGHT_SHIFT_EQUALS reduce using rule 100 (mlhsitem -> arrayal .)
    LEFT_SHIFT_EQUALS reduce using rule 100 (mlhsitem -> arrayal .)
    MULTIPLY_EQUALS reduce using rule 100 (mlhsitem -> arrayal .)
    LOGICAL_AND_EQUALS reduce using rule 100 (mlhsitem -> arrayal .)
    LOGICAL_OR_EQUALS reduce using rule 100 (mlhsitem -> arrayal .)
    in              reduce using rule 100 (mlhsitem -> arrayal .)


state 33

    (8) stmt -> puts . OPEN_BRACKET STRING CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 108


state 34

    (78) primary -> literal .

    MULTIPLY        reduce using rule 78 (primary -> literal .)
    DIVIDE          reduce using rule 78 (primary -> literal .)
    MODULO          reduce using rule 78 (primary -> literal .)
    PLUS            reduce using rule 78 (primary -> literal .)
    MINUS           reduce using rule 78 (primary -> literal .)
    LEFT_SHIFT      reduce using rule 78 (primary -> literal .)
    RIGHT_SHIFT     reduce using rule 78 (primary -> literal .)
    BIT_AND         reduce using rule 78 (primary -> literal .)
    BIT_XOR         reduce using rule 78 (primary -> literal .)
    BIT_OR          reduce using rule 78 (primary -> literal .)
    DOUBLE_EQUALS   reduce using rule 78 (primary -> literal .)
    NOT_EQUALS      reduce using rule 78 (primary -> literal .)
    EQUAL_TILDE     reduce using rule 78 (primary -> literal .)
    COMPARISON      reduce using rule 78 (primary -> literal .)
    LESS            reduce using rule 78 (primary -> literal .)
    LESS_EQUALS     reduce using rule 78 (primary -> literal .)
    GREATER         reduce using rule 78 (primary -> literal .)
    GREATER_EQUALS  reduce using rule 78 (primary -> literal .)
    INCL_RANGE      reduce using rule 78 (primary -> literal .)
    EXCL_RANGE      reduce using rule 78 (primary -> literal .)
    LOGICAL_OR      reduce using rule 78 (primary -> literal .)
    CLOSE_BRACKET   reduce using rule 78 (primary -> literal .)
    SEMI_COLON      reduce using rule 78 (primary -> literal .)
    NEWLINE         reduce using rule 78 (primary -> literal .)
    puts            reduce using rule 78 (primary -> literal .)
    print           reduce using rule 78 (primary -> literal .)
    break           reduce using rule 78 (primary -> literal .)
    def             reduce using rule 78 (primary -> literal .)
    if              reduce using rule 78 (primary -> literal .)
    while           reduce using rule 78 (primary -> literal .)
    until           reduce using rule 78 (primary -> literal .)
    case            reduce using rule 78 (primary -> literal .)
    for             reduce using rule 78 (primary -> literal .)
    return          reduce using rule 78 (primary -> literal .)
    IDENTIFIER      reduce using rule 78 (primary -> literal .)
    nil             reduce using rule 78 (primary -> literal .)
    self            reduce using rule 78 (primary -> literal .)
    GLOBAL          reduce using rule 78 (primary -> literal .)
    AT_THE_RATE     reduce using rule 78 (primary -> literal .)
    OPEN_BRACKET    reduce using rule 78 (primary -> literal .)
    Array           reduce using rule 78 (primary -> literal .)
    NUMBER          reduce using rule 78 (primary -> literal .)
    FLOAT           reduce using rule 78 (primary -> literal .)
    STRING          reduce using rule 78 (primary -> literal .)
    true            reduce using rule 78 (primary -> literal .)
    false           reduce using rule 78 (primary -> literal .)
    $end            reduce using rule 78 (primary -> literal .)
    then            reduce using rule 78 (primary -> literal .)
    COMMA           reduce using rule 78 (primary -> literal .)
    do              reduce using rule 78 (primary -> literal .)
    CLOSE_SQUARE    reduce using rule 78 (primary -> literal .)


state 35

    (29) expr2 -> call .

    SEMI_COLON      reduce using rule 29 (expr2 -> call .)
    NEWLINE         reduce using rule 29 (expr2 -> call .)
    then            reduce using rule 29 (expr2 -> call .)
    puts            reduce using rule 29 (expr2 -> call .)
    print           reduce using rule 29 (expr2 -> call .)
    break           reduce using rule 29 (expr2 -> call .)
    def             reduce using rule 29 (expr2 -> call .)
    if              reduce using rule 29 (expr2 -> call .)
    while           reduce using rule 29 (expr2 -> call .)
    until           reduce using rule 29 (expr2 -> call .)
    case            reduce using rule 29 (expr2 -> call .)
    for             reduce using rule 29 (expr2 -> call .)
    return          reduce using rule 29 (expr2 -> call .)
    IDENTIFIER      reduce using rule 29 (expr2 -> call .)
    nil             reduce using rule 29 (expr2 -> call .)
    self            reduce using rule 29 (expr2 -> call .)
    GLOBAL          reduce using rule 29 (expr2 -> call .)
    AT_THE_RATE     reduce using rule 29 (expr2 -> call .)
    MINUS           reduce using rule 29 (expr2 -> call .)
    PLUS            reduce using rule 29 (expr2 -> call .)
    OPEN_BRACKET    reduce using rule 29 (expr2 -> call .)
    Array           reduce using rule 29 (expr2 -> call .)
    NUMBER          reduce using rule 29 (expr2 -> call .)
    FLOAT           reduce using rule 29 (expr2 -> call .)
    STRING          reduce using rule 29 (expr2 -> call .)
    true            reduce using rule 29 (expr2 -> call .)
    false           reduce using rule 29 (expr2 -> call .)
    $end            reduce using rule 29 (expr2 -> call .)
    do              reduce using rule 29 (expr2 -> call .)
    CLOSE_BRACKET   reduce using rule 29 (expr2 -> call .)


state 36

    (31) function -> IDENTIFIER . OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> IDENTIFIER . OPEN_BRACKET CLOSE_BRACKET
    (99) mlhsitem -> IDENTIFIER .
    (148) varname -> IDENTIFIER .

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    OPEN_BRACKET    shift and go to state 109
    EQUALS          reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    OR_EQUALS       reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    AND_EQUALS      reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    XOR_EQUALS      reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LOGICAL_AND_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LOGICAL_OR_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 148 (varname -> IDENTIFIER .)
    MULTIPLY        reduce using rule 148 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 148 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 148 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 148 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 148 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 148 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 148 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 148 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 148 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 148 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 148 (varname -> IDENTIFIER .)
    LESS            reduce using rule 148 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 148 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 148 (varname -> IDENTIFIER .)
    then            reduce using rule 148 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 148 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 148 (varname -> IDENTIFIER .)
    puts            reduce using rule 148 (varname -> IDENTIFIER .)
    print           reduce using rule 148 (varname -> IDENTIFIER .)
    break           reduce using rule 148 (varname -> IDENTIFIER .)
    def             reduce using rule 148 (varname -> IDENTIFIER .)
    if              reduce using rule 148 (varname -> IDENTIFIER .)
    while           reduce using rule 148 (varname -> IDENTIFIER .)
    until           reduce using rule 148 (varname -> IDENTIFIER .)
    case            reduce using rule 148 (varname -> IDENTIFIER .)
    for             reduce using rule 148 (varname -> IDENTIFIER .)
    return          reduce using rule 148 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 148 (varname -> IDENTIFIER .)
    nil             reduce using rule 148 (varname -> IDENTIFIER .)
    self            reduce using rule 148 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 148 (varname -> IDENTIFIER .)
    AT_THE_RATE     reduce using rule 148 (varname -> IDENTIFIER .)
    Array           reduce using rule 148 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 148 (varname -> IDENTIFIER .)
    FLOAT           reduce using rule 148 (varname -> IDENTIFIER .)
    STRING          reduce using rule 148 (varname -> IDENTIFIER .)
    true            reduce using rule 148 (varname -> IDENTIFIER .)
    false           reduce using rule 148 (varname -> IDENTIFIER .)
    $end            reduce using rule 148 (varname -> IDENTIFIER .)
    do              reduce using rule 148 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 148 (varname -> IDENTIFIER .)

  ! OPEN_BRACKET    [ reduce using rule 148 (varname -> IDENTIFIER .) ]


state 37

    (20) expr -> until . M_1 expr1 pdo M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 110
    empty                          shift and go to state 105

state 38

    (5) multcompstmt -> empty .

    $end            reduce using rule 5 (multcompstmt -> empty .)


state 39

    (30) call -> function .

    SEMI_COLON      reduce using rule 30 (call -> function .)
    NEWLINE         reduce using rule 30 (call -> function .)
    do              reduce using rule 30 (call -> function .)
    CLOSE_BRACKET   reduce using rule 30 (call -> function .)
    puts            reduce using rule 30 (call -> function .)
    print           reduce using rule 30 (call -> function .)
    break           reduce using rule 30 (call -> function .)
    def             reduce using rule 30 (call -> function .)
    if              reduce using rule 30 (call -> function .)
    while           reduce using rule 30 (call -> function .)
    until           reduce using rule 30 (call -> function .)
    case            reduce using rule 30 (call -> function .)
    for             reduce using rule 30 (call -> function .)
    return          reduce using rule 30 (call -> function .)
    IDENTIFIER      reduce using rule 30 (call -> function .)
    nil             reduce using rule 30 (call -> function .)
    self            reduce using rule 30 (call -> function .)
    GLOBAL          reduce using rule 30 (call -> function .)
    AT_THE_RATE     reduce using rule 30 (call -> function .)
    MINUS           reduce using rule 30 (call -> function .)
    PLUS            reduce using rule 30 (call -> function .)
    OPEN_BRACKET    reduce using rule 30 (call -> function .)
    Array           reduce using rule 30 (call -> function .)
    NUMBER          reduce using rule 30 (call -> function .)
    FLOAT           reduce using rule 30 (call -> function .)
    STRING          reduce using rule 30 (call -> function .)
    true            reduce using rule 30 (call -> function .)
    false           reduce using rule 30 (call -> function .)
    $end            reduce using rule 30 (call -> function .)
    then            reduce using rule 30 (call -> function .)


state 40

    (98) mlhs -> mlhsitem .

    EQUALS          reduce using rule 98 (mlhs -> mlhsitem .)
    MODULO_EQUALS   reduce using rule 98 (mlhs -> mlhsitem .)
    DIVIDE_EQUALS   reduce using rule 98 (mlhs -> mlhsitem .)
    MINUS_EQUALS    reduce using rule 98 (mlhs -> mlhsitem .)
    PLUS_EQUALS     reduce using rule 98 (mlhs -> mlhsitem .)
    OR_EQUALS       reduce using rule 98 (mlhs -> mlhsitem .)
    AND_EQUALS      reduce using rule 98 (mlhs -> mlhsitem .)
    XOR_EQUALS      reduce using rule 98 (mlhs -> mlhsitem .)
    RIGHT_SHIFT_EQUALS reduce using rule 98 (mlhs -> mlhsitem .)
    LEFT_SHIFT_EQUALS reduce using rule 98 (mlhs -> mlhsitem .)
    MULTIPLY_EQUALS reduce using rule 98 (mlhs -> mlhsitem .)
    LOGICAL_AND_EQUALS reduce using rule 98 (mlhs -> mlhsitem .)
    LOGICAL_OR_EQUALS reduce using rule 98 (mlhs -> mlhsitem .)
    in              reduce using rule 98 (mlhs -> mlhsitem .)


state 41

    (59) term7 -> term8 .
    (60) term8 -> term8 . LEFT_SHIFT term9
    (61) term8 -> term8 . RIGHT_SHIFT term9

    BIT_AND         reduce using rule 59 (term7 -> term8 .)
    BIT_XOR         reduce using rule 59 (term7 -> term8 .)
    BIT_OR          reduce using rule 59 (term7 -> term8 .)
    DOUBLE_EQUALS   reduce using rule 59 (term7 -> term8 .)
    NOT_EQUALS      reduce using rule 59 (term7 -> term8 .)
    EQUAL_TILDE     reduce using rule 59 (term7 -> term8 .)
    COMPARISON      reduce using rule 59 (term7 -> term8 .)
    LESS            reduce using rule 59 (term7 -> term8 .)
    LESS_EQUALS     reduce using rule 59 (term7 -> term8 .)
    GREATER         reduce using rule 59 (term7 -> term8 .)
    GREATER_EQUALS  reduce using rule 59 (term7 -> term8 .)
    INCL_RANGE      reduce using rule 59 (term7 -> term8 .)
    EXCL_RANGE      reduce using rule 59 (term7 -> term8 .)
    LOGICAL_OR      reduce using rule 59 (term7 -> term8 .)
    SEMI_COLON      reduce using rule 59 (term7 -> term8 .)
    NEWLINE         reduce using rule 59 (term7 -> term8 .)
    puts            reduce using rule 59 (term7 -> term8 .)
    print           reduce using rule 59 (term7 -> term8 .)
    break           reduce using rule 59 (term7 -> term8 .)
    def             reduce using rule 59 (term7 -> term8 .)
    if              reduce using rule 59 (term7 -> term8 .)
    while           reduce using rule 59 (term7 -> term8 .)
    until           reduce using rule 59 (term7 -> term8 .)
    case            reduce using rule 59 (term7 -> term8 .)
    for             reduce using rule 59 (term7 -> term8 .)
    return          reduce using rule 59 (term7 -> term8 .)
    IDENTIFIER      reduce using rule 59 (term7 -> term8 .)
    nil             reduce using rule 59 (term7 -> term8 .)
    self            reduce using rule 59 (term7 -> term8 .)
    GLOBAL          reduce using rule 59 (term7 -> term8 .)
    AT_THE_RATE     reduce using rule 59 (term7 -> term8 .)
    MINUS           reduce using rule 59 (term7 -> term8 .)
    PLUS            reduce using rule 59 (term7 -> term8 .)
    OPEN_BRACKET    reduce using rule 59 (term7 -> term8 .)
    Array           reduce using rule 59 (term7 -> term8 .)
    NUMBER          reduce using rule 59 (term7 -> term8 .)
    FLOAT           reduce using rule 59 (term7 -> term8 .)
    STRING          reduce using rule 59 (term7 -> term8 .)
    true            reduce using rule 59 (term7 -> term8 .)
    false           reduce using rule 59 (term7 -> term8 .)
    $end            reduce using rule 59 (term7 -> term8 .)
    CLOSE_BRACKET   reduce using rule 59 (term7 -> term8 .)
    then            reduce using rule 59 (term7 -> term8 .)
    COMMA           reduce using rule 59 (term7 -> term8 .)
    do              reduce using rule 59 (term7 -> term8 .)
    LEFT_SHIFT      shift and go to state 112
    RIGHT_SHIFT     shift and go to state 111


state 42

    (95) literal -> true .

    COMMA           reduce using rule 95 (literal -> true .)
    CLOSE_BRACKET   reduce using rule 95 (literal -> true .)
    MULTIPLY        reduce using rule 95 (literal -> true .)
    DIVIDE          reduce using rule 95 (literal -> true .)
    MODULO          reduce using rule 95 (literal -> true .)
    PLUS            reduce using rule 95 (literal -> true .)
    MINUS           reduce using rule 95 (literal -> true .)
    LEFT_SHIFT      reduce using rule 95 (literal -> true .)
    RIGHT_SHIFT     reduce using rule 95 (literal -> true .)
    BIT_AND         reduce using rule 95 (literal -> true .)
    BIT_XOR         reduce using rule 95 (literal -> true .)
    BIT_OR          reduce using rule 95 (literal -> true .)
    DOUBLE_EQUALS   reduce using rule 95 (literal -> true .)
    NOT_EQUALS      reduce using rule 95 (literal -> true .)
    EQUAL_TILDE     reduce using rule 95 (literal -> true .)
    COMPARISON      reduce using rule 95 (literal -> true .)
    LESS            reduce using rule 95 (literal -> true .)
    LESS_EQUALS     reduce using rule 95 (literal -> true .)
    GREATER         reduce using rule 95 (literal -> true .)
    GREATER_EQUALS  reduce using rule 95 (literal -> true .)
    INCL_RANGE      reduce using rule 95 (literal -> true .)
    EXCL_RANGE      reduce using rule 95 (literal -> true .)
    LOGICAL_OR      reduce using rule 95 (literal -> true .)
    SEMI_COLON      reduce using rule 95 (literal -> true .)
    NEWLINE         reduce using rule 95 (literal -> true .)
    puts            reduce using rule 95 (literal -> true .)
    print           reduce using rule 95 (literal -> true .)
    break           reduce using rule 95 (literal -> true .)
    def             reduce using rule 95 (literal -> true .)
    if              reduce using rule 95 (literal -> true .)
    while           reduce using rule 95 (literal -> true .)
    until           reduce using rule 95 (literal -> true .)
    case            reduce using rule 95 (literal -> true .)
    for             reduce using rule 95 (literal -> true .)
    return          reduce using rule 95 (literal -> true .)
    IDENTIFIER      reduce using rule 95 (literal -> true .)
    nil             reduce using rule 95 (literal -> true .)
    self            reduce using rule 95 (literal -> true .)
    GLOBAL          reduce using rule 95 (literal -> true .)
    AT_THE_RATE     reduce using rule 95 (literal -> true .)
    OPEN_BRACKET    reduce using rule 95 (literal -> true .)
    Array           reduce using rule 95 (literal -> true .)
    NUMBER          reduce using rule 95 (literal -> true .)
    FLOAT           reduce using rule 95 (literal -> true .)
    STRING          reduce using rule 95 (literal -> true .)
    true            reduce using rule 95 (literal -> true .)
    false           reduce using rule 95 (literal -> true .)
    $end            reduce using rule 95 (literal -> true .)
    then            reduce using rule 95 (literal -> true .)
    do              reduce using rule 95 (literal -> true .)
    CLOSE_SQUARE    reduce using rule 95 (literal -> true .)


state 43

    (21) expr -> case . expr1 newline multcase end M_1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    literal                        shift and go to state 34
    expr1                          shift and go to state 113
    call                           shift and go to state 35
    function                       shift and go to state 39
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 44

    (11) stmt -> expr .

    SEMI_COLON      reduce using rule 11 (stmt -> expr .)
    NEWLINE         reduce using rule 11 (stmt -> expr .)
    puts            reduce using rule 11 (stmt -> expr .)
    print           reduce using rule 11 (stmt -> expr .)
    break           reduce using rule 11 (stmt -> expr .)
    def             reduce using rule 11 (stmt -> expr .)
    if              reduce using rule 11 (stmt -> expr .)
    while           reduce using rule 11 (stmt -> expr .)
    until           reduce using rule 11 (stmt -> expr .)
    case            reduce using rule 11 (stmt -> expr .)
    for             reduce using rule 11 (stmt -> expr .)
    return          reduce using rule 11 (stmt -> expr .)
    IDENTIFIER      reduce using rule 11 (stmt -> expr .)
    nil             reduce using rule 11 (stmt -> expr .)
    self            reduce using rule 11 (stmt -> expr .)
    GLOBAL          reduce using rule 11 (stmt -> expr .)
    AT_THE_RATE     reduce using rule 11 (stmt -> expr .)
    MINUS           reduce using rule 11 (stmt -> expr .)
    PLUS            reduce using rule 11 (stmt -> expr .)
    OPEN_BRACKET    reduce using rule 11 (stmt -> expr .)
    Array           reduce using rule 11 (stmt -> expr .)
    NUMBER          reduce using rule 11 (stmt -> expr .)
    FLOAT           reduce using rule 11 (stmt -> expr .)
    STRING          reduce using rule 11 (stmt -> expr .)
    true            reduce using rule 11 (stmt -> expr .)
    false           reduce using rule 11 (stmt -> expr .)
    $end            reduce using rule 11 (stmt -> expr .)


state 45

    (19) expr -> while . M_1 expr1 pdo M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 114
    empty                          shift and go to state 105

state 46

    (77) primary -> arraya .

    MULTIPLY        reduce using rule 77 (primary -> arraya .)
    DIVIDE          reduce using rule 77 (primary -> arraya .)
    MODULO          reduce using rule 77 (primary -> arraya .)
    PLUS            reduce using rule 77 (primary -> arraya .)
    MINUS           reduce using rule 77 (primary -> arraya .)
    LEFT_SHIFT      reduce using rule 77 (primary -> arraya .)
    RIGHT_SHIFT     reduce using rule 77 (primary -> arraya .)
    BIT_AND         reduce using rule 77 (primary -> arraya .)
    BIT_XOR         reduce using rule 77 (primary -> arraya .)
    BIT_OR          reduce using rule 77 (primary -> arraya .)
    DOUBLE_EQUALS   reduce using rule 77 (primary -> arraya .)
    NOT_EQUALS      reduce using rule 77 (primary -> arraya .)
    EQUAL_TILDE     reduce using rule 77 (primary -> arraya .)
    COMPARISON      reduce using rule 77 (primary -> arraya .)
    LESS            reduce using rule 77 (primary -> arraya .)
    LESS_EQUALS     reduce using rule 77 (primary -> arraya .)
    GREATER         reduce using rule 77 (primary -> arraya .)
    GREATER_EQUALS  reduce using rule 77 (primary -> arraya .)
    INCL_RANGE      reduce using rule 77 (primary -> arraya .)
    EXCL_RANGE      reduce using rule 77 (primary -> arraya .)
    LOGICAL_OR      reduce using rule 77 (primary -> arraya .)
    CLOSE_BRACKET   reduce using rule 77 (primary -> arraya .)
    SEMI_COLON      reduce using rule 77 (primary -> arraya .)
    NEWLINE         reduce using rule 77 (primary -> arraya .)
    puts            reduce using rule 77 (primary -> arraya .)
    print           reduce using rule 77 (primary -> arraya .)
    break           reduce using rule 77 (primary -> arraya .)
    def             reduce using rule 77 (primary -> arraya .)
    if              reduce using rule 77 (primary -> arraya .)
    while           reduce using rule 77 (primary -> arraya .)
    until           reduce using rule 77 (primary -> arraya .)
    case            reduce using rule 77 (primary -> arraya .)
    for             reduce using rule 77 (primary -> arraya .)
    return          reduce using rule 77 (primary -> arraya .)
    IDENTIFIER      reduce using rule 77 (primary -> arraya .)
    nil             reduce using rule 77 (primary -> arraya .)
    self            reduce using rule 77 (primary -> arraya .)
    GLOBAL          reduce using rule 77 (primary -> arraya .)
    AT_THE_RATE     reduce using rule 77 (primary -> arraya .)
    OPEN_BRACKET    reduce using rule 77 (primary -> arraya .)
    Array           reduce using rule 77 (primary -> arraya .)
    NUMBER          reduce using rule 77 (primary -> arraya .)
    FLOAT           reduce using rule 77 (primary -> arraya .)
    STRING          reduce using rule 77 (primary -> arraya .)
    true            reduce using rule 77 (primary -> arraya .)
    false           reduce using rule 77 (primary -> arraya .)
    $end            reduce using rule 77 (primary -> arraya .)
    then            reduce using rule 77 (primary -> arraya .)
    COMMA           reduce using rule 77 (primary -> arraya .)
    do              reduce using rule 77 (primary -> arraya .)
    CLOSE_SQUARE    reduce using rule 77 (primary -> arraya .)


state 47

    (12) keydef -> def . IDENTIFIER

    IDENTIFIER      shift and go to state 115


state 48

    (76) primary -> arrayd .

    MULTIPLY        reduce using rule 76 (primary -> arrayd .)
    DIVIDE          reduce using rule 76 (primary -> arrayd .)
    MODULO          reduce using rule 76 (primary -> arrayd .)
    PLUS            reduce using rule 76 (primary -> arrayd .)
    MINUS           reduce using rule 76 (primary -> arrayd .)
    LEFT_SHIFT      reduce using rule 76 (primary -> arrayd .)
    RIGHT_SHIFT     reduce using rule 76 (primary -> arrayd .)
    BIT_AND         reduce using rule 76 (primary -> arrayd .)
    BIT_XOR         reduce using rule 76 (primary -> arrayd .)
    BIT_OR          reduce using rule 76 (primary -> arrayd .)
    DOUBLE_EQUALS   reduce using rule 76 (primary -> arrayd .)
    NOT_EQUALS      reduce using rule 76 (primary -> arrayd .)
    EQUAL_TILDE     reduce using rule 76 (primary -> arrayd .)
    COMPARISON      reduce using rule 76 (primary -> arrayd .)
    LESS            reduce using rule 76 (primary -> arrayd .)
    LESS_EQUALS     reduce using rule 76 (primary -> arrayd .)
    GREATER         reduce using rule 76 (primary -> arrayd .)
    GREATER_EQUALS  reduce using rule 76 (primary -> arrayd .)
    INCL_RANGE      reduce using rule 76 (primary -> arrayd .)
    EXCL_RANGE      reduce using rule 76 (primary -> arrayd .)
    LOGICAL_OR      reduce using rule 76 (primary -> arrayd .)
    CLOSE_BRACKET   reduce using rule 76 (primary -> arrayd .)
    SEMI_COLON      reduce using rule 76 (primary -> arrayd .)
    NEWLINE         reduce using rule 76 (primary -> arrayd .)
    puts            reduce using rule 76 (primary -> arrayd .)
    print           reduce using rule 76 (primary -> arrayd .)
    break           reduce using rule 76 (primary -> arrayd .)
    def             reduce using rule 76 (primary -> arrayd .)
    if              reduce using rule 76 (primary -> arrayd .)
    while           reduce using rule 76 (primary -> arrayd .)
    until           reduce using rule 76 (primary -> arrayd .)
    case            reduce using rule 76 (primary -> arrayd .)
    for             reduce using rule 76 (primary -> arrayd .)
    return          reduce using rule 76 (primary -> arrayd .)
    IDENTIFIER      reduce using rule 76 (primary -> arrayd .)
    nil             reduce using rule 76 (primary -> arrayd .)
    self            reduce using rule 76 (primary -> arrayd .)
    GLOBAL          reduce using rule 76 (primary -> arrayd .)
    AT_THE_RATE     reduce using rule 76 (primary -> arrayd .)
    OPEN_BRACKET    reduce using rule 76 (primary -> arrayd .)
    Array           reduce using rule 76 (primary -> arrayd .)
    NUMBER          reduce using rule 76 (primary -> arrayd .)
    FLOAT           reduce using rule 76 (primary -> arrayd .)
    STRING          reduce using rule 76 (primary -> arrayd .)
    true            reduce using rule 76 (primary -> arrayd .)
    false           reduce using rule 76 (primary -> arrayd .)
    $end            reduce using rule 76 (primary -> arrayd .)
    then            reduce using rule 76 (primary -> arrayd .)
    COMMA           reduce using rule 76 (primary -> arrayd .)
    do              reduce using rule 76 (primary -> arrayd .)
    CLOSE_SQUARE    reduce using rule 76 (primary -> arrayd .)


state 49

    (96) literal -> false .

    COMMA           reduce using rule 96 (literal -> false .)
    CLOSE_BRACKET   reduce using rule 96 (literal -> false .)
    MULTIPLY        reduce using rule 96 (literal -> false .)
    DIVIDE          reduce using rule 96 (literal -> false .)
    MODULO          reduce using rule 96 (literal -> false .)
    PLUS            reduce using rule 96 (literal -> false .)
    MINUS           reduce using rule 96 (literal -> false .)
    LEFT_SHIFT      reduce using rule 96 (literal -> false .)
    RIGHT_SHIFT     reduce using rule 96 (literal -> false .)
    BIT_AND         reduce using rule 96 (literal -> false .)
    BIT_XOR         reduce using rule 96 (literal -> false .)
    BIT_OR          reduce using rule 96 (literal -> false .)
    DOUBLE_EQUALS   reduce using rule 96 (literal -> false .)
    NOT_EQUALS      reduce using rule 96 (literal -> false .)
    EQUAL_TILDE     reduce using rule 96 (literal -> false .)
    COMPARISON      reduce using rule 96 (literal -> false .)
    LESS            reduce using rule 96 (literal -> false .)
    LESS_EQUALS     reduce using rule 96 (literal -> false .)
    GREATER         reduce using rule 96 (literal -> false .)
    GREATER_EQUALS  reduce using rule 96 (literal -> false .)
    INCL_RANGE      reduce using rule 96 (literal -> false .)
    EXCL_RANGE      reduce using rule 96 (literal -> false .)
    LOGICAL_OR      reduce using rule 96 (literal -> false .)
    SEMI_COLON      reduce using rule 96 (literal -> false .)
    NEWLINE         reduce using rule 96 (literal -> false .)
    puts            reduce using rule 96 (literal -> false .)
    print           reduce using rule 96 (literal -> false .)
    break           reduce using rule 96 (literal -> false .)
    def             reduce using rule 96 (literal -> false .)
    if              reduce using rule 96 (literal -> false .)
    while           reduce using rule 96 (literal -> false .)
    until           reduce using rule 96 (literal -> false .)
    case            reduce using rule 96 (literal -> false .)
    for             reduce using rule 96 (literal -> false .)
    return          reduce using rule 96 (literal -> false .)
    IDENTIFIER      reduce using rule 96 (literal -> false .)
    nil             reduce using rule 96 (literal -> false .)
    self            reduce using rule 96 (literal -> false .)
    GLOBAL          reduce using rule 96 (literal -> false .)
    AT_THE_RATE     reduce using rule 96 (literal -> false .)
    OPEN_BRACKET    reduce using rule 96 (literal -> false .)
    Array           reduce using rule 96 (literal -> false .)
    NUMBER          reduce using rule 96 (literal -> false .)
    FLOAT           reduce using rule 96 (literal -> false .)
    STRING          reduce using rule 96 (literal -> false .)
    true            reduce using rule 96 (literal -> false .)
    false           reduce using rule 96 (literal -> false .)
    $end            reduce using rule 96 (literal -> false .)
    then            reduce using rule 96 (literal -> false .)
    do              reduce using rule 96 (literal -> false .)
    CLOSE_SQUARE    reduce using rule 96 (literal -> false .)


state 50

    (92) literal -> NUMBER .

    COMMA           reduce using rule 92 (literal -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 92 (literal -> NUMBER .)
    MULTIPLY        reduce using rule 92 (literal -> NUMBER .)
    DIVIDE          reduce using rule 92 (literal -> NUMBER .)
    MODULO          reduce using rule 92 (literal -> NUMBER .)
    PLUS            reduce using rule 92 (literal -> NUMBER .)
    MINUS           reduce using rule 92 (literal -> NUMBER .)
    LEFT_SHIFT      reduce using rule 92 (literal -> NUMBER .)
    RIGHT_SHIFT     reduce using rule 92 (literal -> NUMBER .)
    BIT_AND         reduce using rule 92 (literal -> NUMBER .)
    BIT_XOR         reduce using rule 92 (literal -> NUMBER .)
    BIT_OR          reduce using rule 92 (literal -> NUMBER .)
    DOUBLE_EQUALS   reduce using rule 92 (literal -> NUMBER .)
    NOT_EQUALS      reduce using rule 92 (literal -> NUMBER .)
    EQUAL_TILDE     reduce using rule 92 (literal -> NUMBER .)
    COMPARISON      reduce using rule 92 (literal -> NUMBER .)
    LESS            reduce using rule 92 (literal -> NUMBER .)
    LESS_EQUALS     reduce using rule 92 (literal -> NUMBER .)
    GREATER         reduce using rule 92 (literal -> NUMBER .)
    GREATER_EQUALS  reduce using rule 92 (literal -> NUMBER .)
    INCL_RANGE      reduce using rule 92 (literal -> NUMBER .)
    EXCL_RANGE      reduce using rule 92 (literal -> NUMBER .)
    LOGICAL_OR      reduce using rule 92 (literal -> NUMBER .)
    SEMI_COLON      reduce using rule 92 (literal -> NUMBER .)
    NEWLINE         reduce using rule 92 (literal -> NUMBER .)
    puts            reduce using rule 92 (literal -> NUMBER .)
    print           reduce using rule 92 (literal -> NUMBER .)
    break           reduce using rule 92 (literal -> NUMBER .)
    def             reduce using rule 92 (literal -> NUMBER .)
    if              reduce using rule 92 (literal -> NUMBER .)
    while           reduce using rule 92 (literal -> NUMBER .)
    until           reduce using rule 92 (literal -> NUMBER .)
    case            reduce using rule 92 (literal -> NUMBER .)
    for             reduce using rule 92 (literal -> NUMBER .)
    return          reduce using rule 92 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 92 (literal -> NUMBER .)
    nil             reduce using rule 92 (literal -> NUMBER .)
    self            reduce using rule 92 (literal -> NUMBER .)
    GLOBAL          reduce using rule 92 (literal -> NUMBER .)
    AT_THE_RATE     reduce using rule 92 (literal -> NUMBER .)
    OPEN_BRACKET    reduce using rule 92 (literal -> NUMBER .)
    Array           reduce using rule 92 (literal -> NUMBER .)
    NUMBER          reduce using rule 92 (literal -> NUMBER .)
    FLOAT           reduce using rule 92 (literal -> NUMBER .)
    STRING          reduce using rule 92 (literal -> NUMBER .)
    true            reduce using rule 92 (literal -> NUMBER .)
    false           reduce using rule 92 (literal -> NUMBER .)
    $end            reduce using rule 92 (literal -> NUMBER .)
    then            reduce using rule 92 (literal -> NUMBER .)
    do              reduce using rule 92 (literal -> NUMBER .)
    CLOSE_SQUARE    reduce using rule 92 (literal -> NUMBER .)


state 51

    (16) expr -> if . expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> if . expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> if . expr1 pthen M_1 multstmt end M_1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    literal                        shift and go to state 34
    expr1                          shift and go to state 116
    call                           shift and go to state 35
    function                       shift and go to state 39
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 52

    (127) variable -> self .

    OPEN_SQUARE     reduce using rule 127 (variable -> self .)


state 53

    (27) expr1 -> expr2 .

    do              reduce using rule 27 (expr1 -> expr2 .)
    SEMI_COLON      reduce using rule 27 (expr1 -> expr2 .)
    NEWLINE         reduce using rule 27 (expr1 -> expr2 .)
    puts            reduce using rule 27 (expr1 -> expr2 .)
    print           reduce using rule 27 (expr1 -> expr2 .)
    break           reduce using rule 27 (expr1 -> expr2 .)
    def             reduce using rule 27 (expr1 -> expr2 .)
    if              reduce using rule 27 (expr1 -> expr2 .)
    while           reduce using rule 27 (expr1 -> expr2 .)
    until           reduce using rule 27 (expr1 -> expr2 .)
    case            reduce using rule 27 (expr1 -> expr2 .)
    for             reduce using rule 27 (expr1 -> expr2 .)
    return          reduce using rule 27 (expr1 -> expr2 .)
    IDENTIFIER      reduce using rule 27 (expr1 -> expr2 .)
    nil             reduce using rule 27 (expr1 -> expr2 .)
    self            reduce using rule 27 (expr1 -> expr2 .)
    GLOBAL          reduce using rule 27 (expr1 -> expr2 .)
    AT_THE_RATE     reduce using rule 27 (expr1 -> expr2 .)
    MINUS           reduce using rule 27 (expr1 -> expr2 .)
    PLUS            reduce using rule 27 (expr1 -> expr2 .)
    OPEN_BRACKET    reduce using rule 27 (expr1 -> expr2 .)
    Array           reduce using rule 27 (expr1 -> expr2 .)
    NUMBER          reduce using rule 27 (expr1 -> expr2 .)
    FLOAT           reduce using rule 27 (expr1 -> expr2 .)
    STRING          reduce using rule 27 (expr1 -> expr2 .)
    true            reduce using rule 27 (expr1 -> expr2 .)
    false           reduce using rule 27 (expr1 -> expr2 .)
    $end            reduce using rule 27 (expr1 -> expr2 .)
    then            reduce using rule 27 (expr1 -> expr2 .)


state 54

    (23) expr -> expr1 .

    SEMI_COLON      reduce using rule 23 (expr -> expr1 .)
    NEWLINE         reduce using rule 23 (expr -> expr1 .)
    puts            reduce using rule 23 (expr -> expr1 .)
    print           reduce using rule 23 (expr -> expr1 .)
    break           reduce using rule 23 (expr -> expr1 .)
    def             reduce using rule 23 (expr -> expr1 .)
    if              reduce using rule 23 (expr -> expr1 .)
    while           reduce using rule 23 (expr -> expr1 .)
    until           reduce using rule 23 (expr -> expr1 .)
    case            reduce using rule 23 (expr -> expr1 .)
    for             reduce using rule 23 (expr -> expr1 .)
    return          reduce using rule 23 (expr -> expr1 .)
    IDENTIFIER      reduce using rule 23 (expr -> expr1 .)
    nil             reduce using rule 23 (expr -> expr1 .)
    self            reduce using rule 23 (expr -> expr1 .)
    GLOBAL          reduce using rule 23 (expr -> expr1 .)
    AT_THE_RATE     reduce using rule 23 (expr -> expr1 .)
    MINUS           reduce using rule 23 (expr -> expr1 .)
    PLUS            reduce using rule 23 (expr -> expr1 .)
    OPEN_BRACKET    reduce using rule 23 (expr -> expr1 .)
    Array           reduce using rule 23 (expr -> expr1 .)
    NUMBER          reduce using rule 23 (expr -> expr1 .)
    FLOAT           reduce using rule 23 (expr -> expr1 .)
    STRING          reduce using rule 23 (expr -> expr1 .)
    true            reduce using rule 23 (expr -> expr1 .)
    false           reduce using rule 23 (expr -> expr1 .)
    $end            reduce using rule 23 (expr -> expr1 .)
    then            reduce using rule 23 (expr -> expr1 .)


state 55

    (94) literal -> STRING .

    COMMA           reduce using rule 94 (literal -> STRING .)
    CLOSE_BRACKET   reduce using rule 94 (literal -> STRING .)
    MULTIPLY        reduce using rule 94 (literal -> STRING .)
    DIVIDE          reduce using rule 94 (literal -> STRING .)
    MODULO          reduce using rule 94 (literal -> STRING .)
    PLUS            reduce using rule 94 (literal -> STRING .)
    MINUS           reduce using rule 94 (literal -> STRING .)
    LEFT_SHIFT      reduce using rule 94 (literal -> STRING .)
    RIGHT_SHIFT     reduce using rule 94 (literal -> STRING .)
    BIT_AND         reduce using rule 94 (literal -> STRING .)
    BIT_XOR         reduce using rule 94 (literal -> STRING .)
    BIT_OR          reduce using rule 94 (literal -> STRING .)
    DOUBLE_EQUALS   reduce using rule 94 (literal -> STRING .)
    NOT_EQUALS      reduce using rule 94 (literal -> STRING .)
    EQUAL_TILDE     reduce using rule 94 (literal -> STRING .)
    COMPARISON      reduce using rule 94 (literal -> STRING .)
    LESS            reduce using rule 94 (literal -> STRING .)
    LESS_EQUALS     reduce using rule 94 (literal -> STRING .)
    GREATER         reduce using rule 94 (literal -> STRING .)
    GREATER_EQUALS  reduce using rule 94 (literal -> STRING .)
    INCL_RANGE      reduce using rule 94 (literal -> STRING .)
    EXCL_RANGE      reduce using rule 94 (literal -> STRING .)
    LOGICAL_OR      reduce using rule 94 (literal -> STRING .)
    SEMI_COLON      reduce using rule 94 (literal -> STRING .)
    NEWLINE         reduce using rule 94 (literal -> STRING .)
    puts            reduce using rule 94 (literal -> STRING .)
    print           reduce using rule 94 (literal -> STRING .)
    break           reduce using rule 94 (literal -> STRING .)
    def             reduce using rule 94 (literal -> STRING .)
    if              reduce using rule 94 (literal -> STRING .)
    while           reduce using rule 94 (literal -> STRING .)
    until           reduce using rule 94 (literal -> STRING .)
    case            reduce using rule 94 (literal -> STRING .)
    for             reduce using rule 94 (literal -> STRING .)
    return          reduce using rule 94 (literal -> STRING .)
    IDENTIFIER      reduce using rule 94 (literal -> STRING .)
    nil             reduce using rule 94 (literal -> STRING .)
    self            reduce using rule 94 (literal -> STRING .)
    GLOBAL          reduce using rule 94 (literal -> STRING .)
    AT_THE_RATE     reduce using rule 94 (literal -> STRING .)
    OPEN_BRACKET    reduce using rule 94 (literal -> STRING .)
    Array           reduce using rule 94 (literal -> STRING .)
    NUMBER          reduce using rule 94 (literal -> STRING .)
    FLOAT           reduce using rule 94 (literal -> STRING .)
    STRING          reduce using rule 94 (literal -> STRING .)
    true            reduce using rule 94 (literal -> STRING .)
    false           reduce using rule 94 (literal -> STRING .)
    $end            reduce using rule 94 (literal -> STRING .)
    then            reduce using rule 94 (literal -> STRING .)
    do              reduce using rule 94 (literal -> STRING .)
    CLOSE_SQUARE    reduce using rule 94 (literal -> STRING .)


state 56

    (126) variable -> nil .

    OPEN_SQUARE     reduce using rule 126 (variable -> nil .)


state 57

    (2) multcompstmt -> newline . stmt1 multcompstmt
    (4) multcompstmt -> newline .
    (6) stmt1 -> . stmt
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    $end            reduce using rule 4 (multcompstmt -> newline .)
    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    function                       shift and go to state 39
    stmt                           shift and go to state 26
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    stmt1                          shift and go to state 117
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 58

    (83) arrayal -> variable . OPEN_SQUARE array_args CLOSE_SQUARE
    (84) arraya -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 118


state 59

    (10) stmt -> break .

    SEMI_COLON      reduce using rule 10 (stmt -> break .)
    NEWLINE         reduce using rule 10 (stmt -> break .)
    puts            reduce using rule 10 (stmt -> break .)
    print           reduce using rule 10 (stmt -> break .)
    break           reduce using rule 10 (stmt -> break .)
    def             reduce using rule 10 (stmt -> break .)
    if              reduce using rule 10 (stmt -> break .)
    while           reduce using rule 10 (stmt -> break .)
    until           reduce using rule 10 (stmt -> break .)
    case            reduce using rule 10 (stmt -> break .)
    for             reduce using rule 10 (stmt -> break .)
    return          reduce using rule 10 (stmt -> break .)
    IDENTIFIER      reduce using rule 10 (stmt -> break .)
    nil             reduce using rule 10 (stmt -> break .)
    self            reduce using rule 10 (stmt -> break .)
    GLOBAL          reduce using rule 10 (stmt -> break .)
    AT_THE_RATE     reduce using rule 10 (stmt -> break .)
    MINUS           reduce using rule 10 (stmt -> break .)
    PLUS            reduce using rule 10 (stmt -> break .)
    OPEN_BRACKET    reduce using rule 10 (stmt -> break .)
    Array           reduce using rule 10 (stmt -> break .)
    NUMBER          reduce using rule 10 (stmt -> break .)
    FLOAT           reduce using rule 10 (stmt -> break .)
    STRING          reduce using rule 10 (stmt -> break .)
    true            reduce using rule 10 (stmt -> break .)
    false           reduce using rule 10 (stmt -> break .)
    $end            reduce using rule 10 (stmt -> break .)


state 60

    (93) literal -> FLOAT .

    COMMA           reduce using rule 93 (literal -> FLOAT .)
    CLOSE_BRACKET   reduce using rule 93 (literal -> FLOAT .)
    MULTIPLY        reduce using rule 93 (literal -> FLOAT .)
    DIVIDE          reduce using rule 93 (literal -> FLOAT .)
    MODULO          reduce using rule 93 (literal -> FLOAT .)
    PLUS            reduce using rule 93 (literal -> FLOAT .)
    MINUS           reduce using rule 93 (literal -> FLOAT .)
    LEFT_SHIFT      reduce using rule 93 (literal -> FLOAT .)
    RIGHT_SHIFT     reduce using rule 93 (literal -> FLOAT .)
    BIT_AND         reduce using rule 93 (literal -> FLOAT .)
    BIT_XOR         reduce using rule 93 (literal -> FLOAT .)
    BIT_OR          reduce using rule 93 (literal -> FLOAT .)
    DOUBLE_EQUALS   reduce using rule 93 (literal -> FLOAT .)
    NOT_EQUALS      reduce using rule 93 (literal -> FLOAT .)
    EQUAL_TILDE     reduce using rule 93 (literal -> FLOAT .)
    COMPARISON      reduce using rule 93 (literal -> FLOAT .)
    LESS            reduce using rule 93 (literal -> FLOAT .)
    LESS_EQUALS     reduce using rule 93 (literal -> FLOAT .)
    GREATER         reduce using rule 93 (literal -> FLOAT .)
    GREATER_EQUALS  reduce using rule 93 (literal -> FLOAT .)
    INCL_RANGE      reduce using rule 93 (literal -> FLOAT .)
    EXCL_RANGE      reduce using rule 93 (literal -> FLOAT .)
    LOGICAL_OR      reduce using rule 93 (literal -> FLOAT .)
    SEMI_COLON      reduce using rule 93 (literal -> FLOAT .)
    NEWLINE         reduce using rule 93 (literal -> FLOAT .)
    puts            reduce using rule 93 (literal -> FLOAT .)
    print           reduce using rule 93 (literal -> FLOAT .)
    break           reduce using rule 93 (literal -> FLOAT .)
    def             reduce using rule 93 (literal -> FLOAT .)
    if              reduce using rule 93 (literal -> FLOAT .)
    while           reduce using rule 93 (literal -> FLOAT .)
    until           reduce using rule 93 (literal -> FLOAT .)
    case            reduce using rule 93 (literal -> FLOAT .)
    for             reduce using rule 93 (literal -> FLOAT .)
    return          reduce using rule 93 (literal -> FLOAT .)
    IDENTIFIER      reduce using rule 93 (literal -> FLOAT .)
    nil             reduce using rule 93 (literal -> FLOAT .)
    self            reduce using rule 93 (literal -> FLOAT .)
    GLOBAL          reduce using rule 93 (literal -> FLOAT .)
    AT_THE_RATE     reduce using rule 93 (literal -> FLOAT .)
    OPEN_BRACKET    reduce using rule 93 (literal -> FLOAT .)
    Array           reduce using rule 93 (literal -> FLOAT .)
    NUMBER          reduce using rule 93 (literal -> FLOAT .)
    FLOAT           reduce using rule 93 (literal -> FLOAT .)
    STRING          reduce using rule 93 (literal -> FLOAT .)
    true            reduce using rule 93 (literal -> FLOAT .)
    false           reduce using rule 93 (literal -> FLOAT .)
    $end            reduce using rule 93 (literal -> FLOAT .)
    then            reduce using rule 93 (literal -> FLOAT .)
    do              reduce using rule 93 (literal -> FLOAT .)
    CLOSE_SQUARE    reduce using rule 93 (literal -> FLOAT .)


state 61

    (80) arrayd -> Array . OPEN_BRACKET array_size CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 119


state 62

    (7) stmt -> keydef . argdecl newline multstmt keyend
    (120) argdecl -> . OPEN_BRACKET arglist CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 121

    argdecl                        shift and go to state 120

state 63

    (136) opasgn -> MINUS_EQUALS .

    MULTIPLY        reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    IDENTIFIER      reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    nil             reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    self            reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    GLOBAL          reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    AT_THE_RATE     reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    MINUS           reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    PLUS            reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    OPEN_BRACKET    reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    Array           reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    NUMBER          reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    FLOAT           reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    STRING          reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    true            reduce using rule 136 (opasgn -> MINUS_EQUALS .)
    false           reduce using rule 136 (opasgn -> MINUS_EQUALS .)


state 64

    (137) opasgn -> PLUS_EQUALS .

    MULTIPLY        reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    IDENTIFIER      reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    nil             reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    self            reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    GLOBAL          reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    AT_THE_RATE     reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    MINUS           reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    PLUS            reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    OPEN_BRACKET    reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    Array           reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    NUMBER          reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    FLOAT           reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    STRING          reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    true            reduce using rule 137 (opasgn -> PLUS_EQUALS .)
    false           reduce using rule 137 (opasgn -> PLUS_EQUALS .)


state 65

    (140) opasgn -> XOR_EQUALS .

    MULTIPLY        reduce using rule 140 (opasgn -> XOR_EQUALS .)
    IDENTIFIER      reduce using rule 140 (opasgn -> XOR_EQUALS .)
    nil             reduce using rule 140 (opasgn -> XOR_EQUALS .)
    self            reduce using rule 140 (opasgn -> XOR_EQUALS .)
    GLOBAL          reduce using rule 140 (opasgn -> XOR_EQUALS .)
    AT_THE_RATE     reduce using rule 140 (opasgn -> XOR_EQUALS .)
    MINUS           reduce using rule 140 (opasgn -> XOR_EQUALS .)
    PLUS            reduce using rule 140 (opasgn -> XOR_EQUALS .)
    OPEN_BRACKET    reduce using rule 140 (opasgn -> XOR_EQUALS .)
    Array           reduce using rule 140 (opasgn -> XOR_EQUALS .)
    NUMBER          reduce using rule 140 (opasgn -> XOR_EQUALS .)
    FLOAT           reduce using rule 140 (opasgn -> XOR_EQUALS .)
    STRING          reduce using rule 140 (opasgn -> XOR_EQUALS .)
    true            reduce using rule 140 (opasgn -> XOR_EQUALS .)
    false           reduce using rule 140 (opasgn -> XOR_EQUALS .)


state 66

    (142) opasgn -> LEFT_SHIFT_EQUALS .

    MULTIPLY        reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    IDENTIFIER      reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    nil             reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    self            reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    GLOBAL          reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    AT_THE_RATE     reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    MINUS           reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    PLUS            reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    OPEN_BRACKET    reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    Array           reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    NUMBER          reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    FLOAT           reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    STRING          reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    true            reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)
    false           reduce using rule 142 (opasgn -> LEFT_SHIFT_EQUALS .)


state 67

    (139) opasgn -> AND_EQUALS .

    MULTIPLY        reduce using rule 139 (opasgn -> AND_EQUALS .)
    IDENTIFIER      reduce using rule 139 (opasgn -> AND_EQUALS .)
    nil             reduce using rule 139 (opasgn -> AND_EQUALS .)
    self            reduce using rule 139 (opasgn -> AND_EQUALS .)
    GLOBAL          reduce using rule 139 (opasgn -> AND_EQUALS .)
    AT_THE_RATE     reduce using rule 139 (opasgn -> AND_EQUALS .)
    MINUS           reduce using rule 139 (opasgn -> AND_EQUALS .)
    PLUS            reduce using rule 139 (opasgn -> AND_EQUALS .)
    OPEN_BRACKET    reduce using rule 139 (opasgn -> AND_EQUALS .)
    Array           reduce using rule 139 (opasgn -> AND_EQUALS .)
    NUMBER          reduce using rule 139 (opasgn -> AND_EQUALS .)
    FLOAT           reduce using rule 139 (opasgn -> AND_EQUALS .)
    STRING          reduce using rule 139 (opasgn -> AND_EQUALS .)
    true            reduce using rule 139 (opasgn -> AND_EQUALS .)
    false           reduce using rule 139 (opasgn -> AND_EQUALS .)


state 68

    (135) opasgn -> DIVIDE_EQUALS .

    MULTIPLY        reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    IDENTIFIER      reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    nil             reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    self            reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    GLOBAL          reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    AT_THE_RATE     reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    MINUS           reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    PLUS            reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    OPEN_BRACKET    reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    Array           reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    NUMBER          reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    STRING          reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    true            reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)
    false           reduce using rule 135 (opasgn -> DIVIDE_EQUALS .)


state 69

    (144) opasgn -> LOGICAL_AND_EQUALS .

    MULTIPLY        reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    IDENTIFIER      reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    nil             reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    self            reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    GLOBAL          reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    AT_THE_RATE     reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    MINUS           reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    PLUS            reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    OPEN_BRACKET    reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    Array           reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    NUMBER          reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    FLOAT           reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    STRING          reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    true            reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)
    false           reduce using rule 144 (opasgn -> LOGICAL_AND_EQUALS .)


state 70

    (141) opasgn -> RIGHT_SHIFT_EQUALS .

    MULTIPLY        reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    IDENTIFIER      reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    nil             reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    self            reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    GLOBAL          reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    AT_THE_RATE     reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    MINUS           reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    PLUS            reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    OPEN_BRACKET    reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    Array           reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    NUMBER          reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    FLOAT           reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    STRING          reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    true            reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)
    false           reduce using rule 141 (opasgn -> RIGHT_SHIFT_EQUALS .)


state 71

    (34) term0 -> mlhs EQUALS . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> mlhs EQUALS . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (37) term1 -> mlhs EQUALS . mrhs
    (109) mrhs -> . term2
    (110) mrhs -> . args COMMA MULTIPLY arg
    (111) mrhs -> . MULTIPLY arg
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (117) args -> . arg multargs
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (33) arg -> . term0
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    IDENTIFIER      shift and go to state 125
    MULTIPLY        shift and go to state 124
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 122
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 123
    arrayal                        shift and go to state 32
    literal                        shift and go to state 34
    args                           shift and go to state 126
    mrhs                           shift and go to state 127
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 72

    (138) opasgn -> OR_EQUALS .

    MULTIPLY        reduce using rule 138 (opasgn -> OR_EQUALS .)
    IDENTIFIER      reduce using rule 138 (opasgn -> OR_EQUALS .)
    nil             reduce using rule 138 (opasgn -> OR_EQUALS .)
    self            reduce using rule 138 (opasgn -> OR_EQUALS .)
    GLOBAL          reduce using rule 138 (opasgn -> OR_EQUALS .)
    AT_THE_RATE     reduce using rule 138 (opasgn -> OR_EQUALS .)
    MINUS           reduce using rule 138 (opasgn -> OR_EQUALS .)
    PLUS            reduce using rule 138 (opasgn -> OR_EQUALS .)
    OPEN_BRACKET    reduce using rule 138 (opasgn -> OR_EQUALS .)
    Array           reduce using rule 138 (opasgn -> OR_EQUALS .)
    NUMBER          reduce using rule 138 (opasgn -> OR_EQUALS .)
    FLOAT           reduce using rule 138 (opasgn -> OR_EQUALS .)
    STRING          reduce using rule 138 (opasgn -> OR_EQUALS .)
    true            reduce using rule 138 (opasgn -> OR_EQUALS .)
    false           reduce using rule 138 (opasgn -> OR_EQUALS .)


state 73

    (38) term1 -> mlhs opasgn . mrhs
    (109) mrhs -> . term2
    (110) mrhs -> . args COMMA MULTIPLY arg
    (111) mrhs -> . MULTIPLY arg
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (117) args -> . arg multargs
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (33) arg -> . term0
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    MULTIPLY        shift and go to state 124
    IDENTIFIER      shift and go to state 128
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 122
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 123
    arrayal                        shift and go to state 32
    literal                        shift and go to state 34
    args                           shift and go to state 126
    mrhs                           shift and go to state 129
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 74

    (143) opasgn -> MULTIPLY_EQUALS .

    MULTIPLY        reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    IDENTIFIER      reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    nil             reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    self            reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    GLOBAL          reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    AT_THE_RATE     reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    MINUS           reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    PLUS            reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    OPEN_BRACKET    reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    Array           reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    NUMBER          reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    FLOAT           reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    STRING          reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    true            reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)
    false           reduce using rule 143 (opasgn -> MULTIPLY_EQUALS .)


state 75

    (145) opasgn -> LOGICAL_OR_EQUALS .

    MULTIPLY        reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    IDENTIFIER      reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    nil             reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    self            reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    GLOBAL          reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    AT_THE_RATE     reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    MINUS           reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    PLUS            reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    OPEN_BRACKET    reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    Array           reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    NUMBER          reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    FLOAT           reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    STRING          reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    true            reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)
    false           reduce using rule 145 (opasgn -> LOGICAL_OR_EQUALS .)


state 76

    (134) opasgn -> MODULO_EQUALS .

    MULTIPLY        reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    IDENTIFIER      reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    nil             reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    self            reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    GLOBAL          reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    AT_THE_RATE     reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    MINUS           reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    PLUS            reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    OPEN_BRACKET    reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    Array           reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    NUMBER          reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    FLOAT           reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    STRING          reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    true            reduce using rule 134 (opasgn -> MODULO_EQUALS .)
    false           reduce using rule 134 (opasgn -> MODULO_EQUALS .)


state 77

    (148) varname -> IDENTIFIER .

    MULTIPLY        reduce using rule 148 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 148 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 148 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 148 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 148 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 148 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 148 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 148 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 148 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 148 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 148 (varname -> IDENTIFIER .)
    LESS            reduce using rule 148 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 148 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 148 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 148 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 148 (varname -> IDENTIFIER .)
    puts            reduce using rule 148 (varname -> IDENTIFIER .)
    print           reduce using rule 148 (varname -> IDENTIFIER .)
    break           reduce using rule 148 (varname -> IDENTIFIER .)
    def             reduce using rule 148 (varname -> IDENTIFIER .)
    if              reduce using rule 148 (varname -> IDENTIFIER .)
    while           reduce using rule 148 (varname -> IDENTIFIER .)
    until           reduce using rule 148 (varname -> IDENTIFIER .)
    case            reduce using rule 148 (varname -> IDENTIFIER .)
    for             reduce using rule 148 (varname -> IDENTIFIER .)
    return          reduce using rule 148 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 148 (varname -> IDENTIFIER .)
    nil             reduce using rule 148 (varname -> IDENTIFIER .)
    self            reduce using rule 148 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 148 (varname -> IDENTIFIER .)
    AT_THE_RATE     reduce using rule 148 (varname -> IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 148 (varname -> IDENTIFIER .)
    Array           reduce using rule 148 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 148 (varname -> IDENTIFIER .)
    FLOAT           reduce using rule 148 (varname -> IDENTIFIER .)
    STRING          reduce using rule 148 (varname -> IDENTIFIER .)
    true            reduce using rule 148 (varname -> IDENTIFIER .)
    false           reduce using rule 148 (varname -> IDENTIFIER .)
    $end            reduce using rule 148 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 148 (varname -> IDENTIFIER .)
    then            reduce using rule 148 (varname -> IDENTIFIER .)
    COMMA           reduce using rule 148 (varname -> IDENTIFIER .)
    do              reduce using rule 148 (varname -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 148 (varname -> IDENTIFIER .)
    CLOSE_SQUARE    reduce using rule 148 (varname -> IDENTIFIER .)


state 78

    (84) arraya -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 130


state 79

    (79) primary -> varname .
    (125) variable -> varname .

    MULTIPLY        reduce using rule 79 (primary -> varname .)
    DIVIDE          reduce using rule 79 (primary -> varname .)
    MODULO          reduce using rule 79 (primary -> varname .)
    PLUS            reduce using rule 79 (primary -> varname .)
    MINUS           reduce using rule 79 (primary -> varname .)
    LEFT_SHIFT      reduce using rule 79 (primary -> varname .)
    RIGHT_SHIFT     reduce using rule 79 (primary -> varname .)
    BIT_AND         reduce using rule 79 (primary -> varname .)
    BIT_XOR         reduce using rule 79 (primary -> varname .)
    BIT_OR          reduce using rule 79 (primary -> varname .)
    LESS            reduce using rule 79 (primary -> varname .)
    LESS_EQUALS     reduce using rule 79 (primary -> varname .)
    GREATER         reduce using rule 79 (primary -> varname .)
    GREATER_EQUALS  reduce using rule 79 (primary -> varname .)
    INCL_RANGE      reduce using rule 79 (primary -> varname .)
    EXCL_RANGE      reduce using rule 79 (primary -> varname .)
    LOGICAL_OR      reduce using rule 79 (primary -> varname .)
    SEMI_COLON      reduce using rule 79 (primary -> varname .)
    NEWLINE         reduce using rule 79 (primary -> varname .)
    puts            reduce using rule 79 (primary -> varname .)
    print           reduce using rule 79 (primary -> varname .)
    break           reduce using rule 79 (primary -> varname .)
    def             reduce using rule 79 (primary -> varname .)
    if              reduce using rule 79 (primary -> varname .)
    while           reduce using rule 79 (primary -> varname .)
    until           reduce using rule 79 (primary -> varname .)
    case            reduce using rule 79 (primary -> varname .)
    for             reduce using rule 79 (primary -> varname .)
    return          reduce using rule 79 (primary -> varname .)
    IDENTIFIER      reduce using rule 79 (primary -> varname .)
    nil             reduce using rule 79 (primary -> varname .)
    self            reduce using rule 79 (primary -> varname .)
    GLOBAL          reduce using rule 79 (primary -> varname .)
    AT_THE_RATE     reduce using rule 79 (primary -> varname .)
    OPEN_BRACKET    reduce using rule 79 (primary -> varname .)
    Array           reduce using rule 79 (primary -> varname .)
    NUMBER          reduce using rule 79 (primary -> varname .)
    FLOAT           reduce using rule 79 (primary -> varname .)
    STRING          reduce using rule 79 (primary -> varname .)
    true            reduce using rule 79 (primary -> varname .)
    false           reduce using rule 79 (primary -> varname .)
    $end            reduce using rule 79 (primary -> varname .)
    CLOSE_BRACKET   reduce using rule 79 (primary -> varname .)
    then            reduce using rule 79 (primary -> varname .)
    COMMA           reduce using rule 79 (primary -> varname .)
    do              reduce using rule 79 (primary -> varname .)
    DOUBLE_EQUALS   reduce using rule 79 (primary -> varname .)
    NOT_EQUALS      reduce using rule 79 (primary -> varname .)
    EQUAL_TILDE     reduce using rule 79 (primary -> varname .)
    COMPARISON      reduce using rule 79 (primary -> varname .)
    CLOSE_SQUARE    reduce using rule 79 (primary -> varname .)
    OPEN_SQUARE     reduce using rule 125 (variable -> varname .)


state 80

    (70) term11 -> MINUS term11 .

    MULTIPLY        reduce using rule 70 (term11 -> MINUS term11 .)
    DIVIDE          reduce using rule 70 (term11 -> MINUS term11 .)
    MODULO          reduce using rule 70 (term11 -> MINUS term11 .)
    PLUS            reduce using rule 70 (term11 -> MINUS term11 .)
    MINUS           reduce using rule 70 (term11 -> MINUS term11 .)
    LEFT_SHIFT      reduce using rule 70 (term11 -> MINUS term11 .)
    RIGHT_SHIFT     reduce using rule 70 (term11 -> MINUS term11 .)
    BIT_AND         reduce using rule 70 (term11 -> MINUS term11 .)
    BIT_XOR         reduce using rule 70 (term11 -> MINUS term11 .)
    BIT_OR          reduce using rule 70 (term11 -> MINUS term11 .)
    DOUBLE_EQUALS   reduce using rule 70 (term11 -> MINUS term11 .)
    NOT_EQUALS      reduce using rule 70 (term11 -> MINUS term11 .)
    EQUAL_TILDE     reduce using rule 70 (term11 -> MINUS term11 .)
    COMPARISON      reduce using rule 70 (term11 -> MINUS term11 .)
    LESS            reduce using rule 70 (term11 -> MINUS term11 .)
    LESS_EQUALS     reduce using rule 70 (term11 -> MINUS term11 .)
    GREATER         reduce using rule 70 (term11 -> MINUS term11 .)
    GREATER_EQUALS  reduce using rule 70 (term11 -> MINUS term11 .)
    INCL_RANGE      reduce using rule 70 (term11 -> MINUS term11 .)
    EXCL_RANGE      reduce using rule 70 (term11 -> MINUS term11 .)
    LOGICAL_OR      reduce using rule 70 (term11 -> MINUS term11 .)
    SEMI_COLON      reduce using rule 70 (term11 -> MINUS term11 .)
    NEWLINE         reduce using rule 70 (term11 -> MINUS term11 .)
    puts            reduce using rule 70 (term11 -> MINUS term11 .)
    print           reduce using rule 70 (term11 -> MINUS term11 .)
    break           reduce using rule 70 (term11 -> MINUS term11 .)
    def             reduce using rule 70 (term11 -> MINUS term11 .)
    if              reduce using rule 70 (term11 -> MINUS term11 .)
    while           reduce using rule 70 (term11 -> MINUS term11 .)
    until           reduce using rule 70 (term11 -> MINUS term11 .)
    case            reduce using rule 70 (term11 -> MINUS term11 .)
    for             reduce using rule 70 (term11 -> MINUS term11 .)
    return          reduce using rule 70 (term11 -> MINUS term11 .)
    IDENTIFIER      reduce using rule 70 (term11 -> MINUS term11 .)
    nil             reduce using rule 70 (term11 -> MINUS term11 .)
    self            reduce using rule 70 (term11 -> MINUS term11 .)
    GLOBAL          reduce using rule 70 (term11 -> MINUS term11 .)
    AT_THE_RATE     reduce using rule 70 (term11 -> MINUS term11 .)
    OPEN_BRACKET    reduce using rule 70 (term11 -> MINUS term11 .)
    Array           reduce using rule 70 (term11 -> MINUS term11 .)
    NUMBER          reduce using rule 70 (term11 -> MINUS term11 .)
    FLOAT           reduce using rule 70 (term11 -> MINUS term11 .)
    STRING          reduce using rule 70 (term11 -> MINUS term11 .)
    true            reduce using rule 70 (term11 -> MINUS term11 .)
    false           reduce using rule 70 (term11 -> MINUS term11 .)
    $end            reduce using rule 70 (term11 -> MINUS term11 .)
    CLOSE_BRACKET   reduce using rule 70 (term11 -> MINUS term11 .)
    then            reduce using rule 70 (term11 -> MINUS term11 .)
    COMMA           reduce using rule 70 (term11 -> MINUS term11 .)
    do              reduce using rule 70 (term11 -> MINUS term11 .)


state 81

    (75) primary -> OPEN_BRACKET expr2 . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 131


state 82

    (72) term12 -> PLUS term12 .

    MULTIPLY        reduce using rule 72 (term12 -> PLUS term12 .)
    DIVIDE          reduce using rule 72 (term12 -> PLUS term12 .)
    MODULO          reduce using rule 72 (term12 -> PLUS term12 .)
    PLUS            reduce using rule 72 (term12 -> PLUS term12 .)
    MINUS           reduce using rule 72 (term12 -> PLUS term12 .)
    LEFT_SHIFT      reduce using rule 72 (term12 -> PLUS term12 .)
    RIGHT_SHIFT     reduce using rule 72 (term12 -> PLUS term12 .)
    BIT_AND         reduce using rule 72 (term12 -> PLUS term12 .)
    BIT_XOR         reduce using rule 72 (term12 -> PLUS term12 .)
    BIT_OR          reduce using rule 72 (term12 -> PLUS term12 .)
    DOUBLE_EQUALS   reduce using rule 72 (term12 -> PLUS term12 .)
    NOT_EQUALS      reduce using rule 72 (term12 -> PLUS term12 .)
    EQUAL_TILDE     reduce using rule 72 (term12 -> PLUS term12 .)
    COMPARISON      reduce using rule 72 (term12 -> PLUS term12 .)
    LESS            reduce using rule 72 (term12 -> PLUS term12 .)
    LESS_EQUALS     reduce using rule 72 (term12 -> PLUS term12 .)
    GREATER         reduce using rule 72 (term12 -> PLUS term12 .)
    GREATER_EQUALS  reduce using rule 72 (term12 -> PLUS term12 .)
    INCL_RANGE      reduce using rule 72 (term12 -> PLUS term12 .)
    EXCL_RANGE      reduce using rule 72 (term12 -> PLUS term12 .)
    LOGICAL_OR      reduce using rule 72 (term12 -> PLUS term12 .)
    SEMI_COLON      reduce using rule 72 (term12 -> PLUS term12 .)
    NEWLINE         reduce using rule 72 (term12 -> PLUS term12 .)
    puts            reduce using rule 72 (term12 -> PLUS term12 .)
    print           reduce using rule 72 (term12 -> PLUS term12 .)
    break           reduce using rule 72 (term12 -> PLUS term12 .)
    def             reduce using rule 72 (term12 -> PLUS term12 .)
    if              reduce using rule 72 (term12 -> PLUS term12 .)
    while           reduce using rule 72 (term12 -> PLUS term12 .)
    until           reduce using rule 72 (term12 -> PLUS term12 .)
    case            reduce using rule 72 (term12 -> PLUS term12 .)
    for             reduce using rule 72 (term12 -> PLUS term12 .)
    return          reduce using rule 72 (term12 -> PLUS term12 .)
    IDENTIFIER      reduce using rule 72 (term12 -> PLUS term12 .)
    nil             reduce using rule 72 (term12 -> PLUS term12 .)
    self            reduce using rule 72 (term12 -> PLUS term12 .)
    GLOBAL          reduce using rule 72 (term12 -> PLUS term12 .)
    AT_THE_RATE     reduce using rule 72 (term12 -> PLUS term12 .)
    OPEN_BRACKET    reduce using rule 72 (term12 -> PLUS term12 .)
    Array           reduce using rule 72 (term12 -> PLUS term12 .)
    NUMBER          reduce using rule 72 (term12 -> PLUS term12 .)
    FLOAT           reduce using rule 72 (term12 -> PLUS term12 .)
    STRING          reduce using rule 72 (term12 -> PLUS term12 .)
    true            reduce using rule 72 (term12 -> PLUS term12 .)
    false           reduce using rule 72 (term12 -> PLUS term12 .)
    $end            reduce using rule 72 (term12 -> PLUS term12 .)
    CLOSE_BRACKET   reduce using rule 72 (term12 -> PLUS term12 .)
    then            reduce using rule 72 (term12 -> PLUS term12 .)
    COMMA           reduce using rule 72 (term12 -> PLUS term12 .)
    do              reduce using rule 72 (term12 -> PLUS term12 .)


state 83

    (25) expr1 -> return IDENTIFIER .

    do              reduce using rule 25 (expr1 -> return IDENTIFIER .)
    SEMI_COLON      reduce using rule 25 (expr1 -> return IDENTIFIER .)
    NEWLINE         reduce using rule 25 (expr1 -> return IDENTIFIER .)
    puts            reduce using rule 25 (expr1 -> return IDENTIFIER .)
    print           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    break           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    def             reduce using rule 25 (expr1 -> return IDENTIFIER .)
    if              reduce using rule 25 (expr1 -> return IDENTIFIER .)
    while           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    until           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    case            reduce using rule 25 (expr1 -> return IDENTIFIER .)
    for             reduce using rule 25 (expr1 -> return IDENTIFIER .)
    return          reduce using rule 25 (expr1 -> return IDENTIFIER .)
    IDENTIFIER      reduce using rule 25 (expr1 -> return IDENTIFIER .)
    nil             reduce using rule 25 (expr1 -> return IDENTIFIER .)
    self            reduce using rule 25 (expr1 -> return IDENTIFIER .)
    GLOBAL          reduce using rule 25 (expr1 -> return IDENTIFIER .)
    AT_THE_RATE     reduce using rule 25 (expr1 -> return IDENTIFIER .)
    MINUS           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    PLUS            reduce using rule 25 (expr1 -> return IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 25 (expr1 -> return IDENTIFIER .)
    Array           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    NUMBER          reduce using rule 25 (expr1 -> return IDENTIFIER .)
    FLOAT           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    STRING          reduce using rule 25 (expr1 -> return IDENTIFIER .)
    true            reduce using rule 25 (expr1 -> return IDENTIFIER .)
    false           reduce using rule 25 (expr1 -> return IDENTIFIER .)
    $end            reduce using rule 25 (expr1 -> return IDENTIFIER .)
    then            reduce using rule 25 (expr1 -> return IDENTIFIER .)


state 84

    (66) term10 -> term10 MULTIPLY . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 132

state 85

    (68) term10 -> term10 MODULO . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 133

state 86

    (67) term10 -> term10 DIVIDE . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 134

state 87

    (58) term7 -> term7 BIT_AND . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 135
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 88

    (55) term6 -> term6 BIT_XOR . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 136
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 89

    (56) term6 -> term6 BIT_OR . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 137
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 90

    (48) term4 -> term5 COMPARISON . term5
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 138
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 91

    (45) term4 -> term5 DOUBLE_EQUALS . term5
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 139
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 92

    (52) term5 -> term5 GREATER . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 140
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 93

    (50) term5 -> term5 LESS . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 141
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 94

    (46) term4 -> term5 NOT_EQUALS . term5
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 142
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 95

    (51) term5 -> term5 LESS_EQUALS . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 143
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 96

    (47) term4 -> term5 EQUAL_TILDE . term5
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 144
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 97

    (53) term5 -> term5 GREATER_EQUALS . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 145
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 98

    (40) term2 -> term3 INCL_RANGE . term3
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 146
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 99

    (41) term2 -> term3 EXCL_RANGE . term3
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 147
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 100

    (43) term3 -> term3 LOGICAL_OR . term4
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 148
    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 101

    (63) term9 -> term9 PLUS . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 149

state 102

    (64) term9 -> term9 MINUS . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 150

state 103

    (147) varname -> AT_THE_RATE IDENTIFIER .

    OPEN_SQUARE     reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    MULTIPLY        reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    DIVIDE          reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    MODULO          reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    PLUS            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    MINUS           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    BIT_AND         reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    BIT_XOR         reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    BIT_OR          reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    NOT_EQUALS      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    COMPARISON      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    LESS            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    LESS_EQUALS     reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    GREATER         reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    INCL_RANGE      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    EXCL_RANGE      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    LOGICAL_OR      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    then            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    SEMI_COLON      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    NEWLINE         reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    puts            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    print           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    break           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    def             reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    if              reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    while           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    until           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    case            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    for             reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    return          reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    IDENTIFIER      reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    nil             reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    self            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    GLOBAL          reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    AT_THE_RATE     reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    Array           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    NUMBER          reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    FLOAT           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    STRING          reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    true            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    false           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    $end            reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    COMMA           reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    do              reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)
    CLOSE_SQUARE    reduce using rule 147 (varname -> AT_THE_RATE IDENTIFIER .)


state 104

    (22) expr -> for M_1 . mlhs in expr1 pdo M_1 multstmt end M_1
    (98) mlhs -> . mlhsitem
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER

    IDENTIFIER      shift and go to state 128
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21

    varname                        shift and go to state 151
    mlhs                           shift and go to state 152
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 153
    arrayal                        shift and go to state 32

state 105

    (24) M_1 -> empty .

    SEMI_COLON      reduce using rule 24 (M_1 -> empty .)
    NEWLINE         reduce using rule 24 (M_1 -> empty .)
    puts            reduce using rule 24 (M_1 -> empty .)
    print           reduce using rule 24 (M_1 -> empty .)
    break           reduce using rule 24 (M_1 -> empty .)
    def             reduce using rule 24 (M_1 -> empty .)
    if              reduce using rule 24 (M_1 -> empty .)
    while           reduce using rule 24 (M_1 -> empty .)
    until           reduce using rule 24 (M_1 -> empty .)
    case            reduce using rule 24 (M_1 -> empty .)
    for             reduce using rule 24 (M_1 -> empty .)
    return          reduce using rule 24 (M_1 -> empty .)
    IDENTIFIER      reduce using rule 24 (M_1 -> empty .)
    nil             reduce using rule 24 (M_1 -> empty .)
    self            reduce using rule 24 (M_1 -> empty .)
    GLOBAL          reduce using rule 24 (M_1 -> empty .)
    AT_THE_RATE     reduce using rule 24 (M_1 -> empty .)
    MINUS           reduce using rule 24 (M_1 -> empty .)
    PLUS            reduce using rule 24 (M_1 -> empty .)
    OPEN_BRACKET    reduce using rule 24 (M_1 -> empty .)
    Array           reduce using rule 24 (M_1 -> empty .)
    NUMBER          reduce using rule 24 (M_1 -> empty .)
    FLOAT           reduce using rule 24 (M_1 -> empty .)
    STRING          reduce using rule 24 (M_1 -> empty .)
    true            reduce using rule 24 (M_1 -> empty .)
    false           reduce using rule 24 (M_1 -> empty .)
    $end            reduce using rule 24 (M_1 -> empty .)
    then            reduce using rule 24 (M_1 -> empty .)
    when            reduce using rule 24 (M_1 -> empty .)
    end             reduce using rule 24 (M_1 -> empty .)
    else            reduce using rule 24 (M_1 -> empty .)
    elsif           reduce using rule 24 (M_1 -> empty .)


state 106

    (9) stmt -> print OPEN_BRACKET . primary CLOSE_BRACKET
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 154
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 107

    (3) multcompstmt -> stmt1 multcompstmt .

    $end            reduce using rule 3 (multcompstmt -> stmt1 multcompstmt .)


state 108

    (8) stmt -> puts OPEN_BRACKET . STRING CLOSE_BRACKET

    STRING          shift and go to state 155


state 109

    (31) function -> IDENTIFIER OPEN_BRACKET . callargs CLOSE_BRACKET
    (32) function -> IDENTIFIER OPEN_BRACKET . CLOSE_BRACKET
    (112) callargs -> . callarglist
    (113) callarglist -> . primary callmultarglist
    (114) callarglist -> . empty
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (151) empty -> .
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

  ! shift/reduce conflict for CLOSE_BRACKET resolved as shift
    CLOSE_BRACKET   shift and go to state 156
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

  ! CLOSE_BRACKET   [ reduce using rule 151 (empty -> .) ]

    callarglist                    shift and go to state 158
    varname                        shift and go to state 79
    primary                        shift and go to state 159
    literal                        shift and go to state 34
    callargs                       shift and go to state 160
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    empty                          shift and go to state 157
    arrayd                         shift and go to state 48

state 110

    (20) expr -> until M_1 . expr1 pdo M_1 multstmt end M_1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    literal                        shift and go to state 34
    expr1                          shift and go to state 161
    call                           shift and go to state 35
    function                       shift and go to state 39
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 111

    (61) term8 -> term8 RIGHT_SHIFT . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 162
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 112

    (60) term8 -> term8 LEFT_SHIFT . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 31
    term9                          shift and go to state 163
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 113

    (21) expr -> case expr1 . newline multcase end M_1
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 164

state 114

    (19) expr -> while M_1 . expr1 pdo M_1 multstmt end M_1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    literal                        shift and go to state 34
    expr1                          shift and go to state 165
    call                           shift and go to state 35
    function                       shift and go to state 39
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 115

    (12) keydef -> def IDENTIFIER .

    OPEN_BRACKET    reduce using rule 12 (keydef -> def IDENTIFIER .)


state 116

    (16) expr -> if expr1 . pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> if expr1 . pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> if expr1 . pthen M_1 multstmt end M_1
    (128) pthen -> . newline
    (129) pthen -> . then
    (130) pthen -> . newline then
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    then            shift and go to state 166
    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 167
    pthen                          shift and go to state 168

state 117

    (2) multcompstmt -> newline stmt1 . multcompstmt
    (2) multcompstmt -> . newline stmt1 multcompstmt
    (3) multcompstmt -> . stmt1 multcompstmt
    (4) multcompstmt -> . newline
    (5) multcompstmt -> . empty
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE
    (6) stmt1 -> . stmt
    (151) empty -> .
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3
    $end            reduce using rule 151 (empty -> .)
    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 38
    function                       shift and go to state 39
    newline                        shift and go to state 57
    multcompstmt                   shift and go to state 169
    stmt                           shift and go to state 26
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    stmt1                          shift and go to state 29
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 118

    (83) arrayal -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (84) arraya -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (85) array_args -> . primary COMMA array_args
    (86) array_args -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 171
    array_args                     shift and go to state 170
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 119

    (80) arrayd -> Array OPEN_BRACKET . array_size CLOSE_BRACKET
    (81) array_size -> . primary COMMA array_size
    (82) array_size -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    array_size                     shift and go to state 173
    varname                        shift and go to state 79
    primary                        shift and go to state 172
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 120

    (7) stmt -> keydef argdecl . newline multstmt keyend
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 174

state 121

    (120) argdecl -> OPEN_BRACKET . arglist CLOSE_BRACKET
    (121) arglist -> . IDENTIFIER multarglist
    (122) arglist -> . empty
    (151) empty -> .

    IDENTIFIER      shift and go to state 176
    CLOSE_BRACKET   reduce using rule 151 (empty -> .)

    arglist                        shift and go to state 175
    empty                          shift and go to state 177

state 122

    (109) mrhs -> term2 .
    (39) term1 -> term2 .

  ! reduce/reduce conflict for COMMA resolved using rule 39 (term1 -> term2 .)
    SEMI_COLON      reduce using rule 109 (mrhs -> term2 .)
    NEWLINE         reduce using rule 109 (mrhs -> term2 .)
    puts            reduce using rule 109 (mrhs -> term2 .)
    print           reduce using rule 109 (mrhs -> term2 .)
    break           reduce using rule 109 (mrhs -> term2 .)
    def             reduce using rule 109 (mrhs -> term2 .)
    if              reduce using rule 109 (mrhs -> term2 .)
    while           reduce using rule 109 (mrhs -> term2 .)
    until           reduce using rule 109 (mrhs -> term2 .)
    case            reduce using rule 109 (mrhs -> term2 .)
    for             reduce using rule 109 (mrhs -> term2 .)
    return          reduce using rule 109 (mrhs -> term2 .)
    IDENTIFIER      reduce using rule 109 (mrhs -> term2 .)
    nil             reduce using rule 109 (mrhs -> term2 .)
    self            reduce using rule 109 (mrhs -> term2 .)
    GLOBAL          reduce using rule 109 (mrhs -> term2 .)
    AT_THE_RATE     reduce using rule 109 (mrhs -> term2 .)
    MINUS           reduce using rule 109 (mrhs -> term2 .)
    PLUS            reduce using rule 109 (mrhs -> term2 .)
    OPEN_BRACKET    reduce using rule 109 (mrhs -> term2 .)
    Array           reduce using rule 109 (mrhs -> term2 .)
    NUMBER          reduce using rule 109 (mrhs -> term2 .)
    FLOAT           reduce using rule 109 (mrhs -> term2 .)
    STRING          reduce using rule 109 (mrhs -> term2 .)
    true            reduce using rule 109 (mrhs -> term2 .)
    false           reduce using rule 109 (mrhs -> term2 .)
    $end            reduce using rule 109 (mrhs -> term2 .)
    CLOSE_BRACKET   reduce using rule 109 (mrhs -> term2 .)
    then            reduce using rule 109 (mrhs -> term2 .)
    do              reduce using rule 109 (mrhs -> term2 .)
    COMMA           reduce using rule 39 (term1 -> term2 .)

  ! COMMA           [ reduce using rule 109 (mrhs -> term2 .) ]


state 123

    (117) args -> arg . multargs
    (118) multargs -> . COMMA arg multargs
    (119) multargs -> . empty
    (151) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 178

  ! COMMA           [ reduce using rule 151 (empty -> .) ]

    multargs                       shift and go to state 179
    empty                          shift and go to state 180

state 124

    (111) mrhs -> MULTIPLY . arg
    (33) arg -> . term0
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    IDENTIFIER      shift and go to state 128
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 181
    arrayal                        shift and go to state 32
    literal                        shift and go to state 34
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 125

    (34) term0 -> mlhs EQUALS IDENTIFIER . OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> mlhs EQUALS IDENTIFIER . OPEN_BRACKET callargs CLOSE_BRACKET
    (99) mlhsitem -> IDENTIFIER .
    (148) varname -> IDENTIFIER .

  ! shift/reduce conflict for OPEN_BRACKET resolved as shift
    OPEN_BRACKET    shift and go to state 182
    EQUALS          reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    OR_EQUALS       reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    AND_EQUALS      reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    XOR_EQUALS      reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LOGICAL_AND_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LOGICAL_OR_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 148 (varname -> IDENTIFIER .)
    MULTIPLY        reduce using rule 148 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 148 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 148 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 148 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 148 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 148 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 148 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 148 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 148 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 148 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 148 (varname -> IDENTIFIER .)
    LESS            reduce using rule 148 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 148 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 148 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 148 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 148 (varname -> IDENTIFIER .)
    puts            reduce using rule 148 (varname -> IDENTIFIER .)
    print           reduce using rule 148 (varname -> IDENTIFIER .)
    break           reduce using rule 148 (varname -> IDENTIFIER .)
    def             reduce using rule 148 (varname -> IDENTIFIER .)
    if              reduce using rule 148 (varname -> IDENTIFIER .)
    while           reduce using rule 148 (varname -> IDENTIFIER .)
    until           reduce using rule 148 (varname -> IDENTIFIER .)
    case            reduce using rule 148 (varname -> IDENTIFIER .)
    for             reduce using rule 148 (varname -> IDENTIFIER .)
    return          reduce using rule 148 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 148 (varname -> IDENTIFIER .)
    nil             reduce using rule 148 (varname -> IDENTIFIER .)
    self            reduce using rule 148 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 148 (varname -> IDENTIFIER .)
    AT_THE_RATE     reduce using rule 148 (varname -> IDENTIFIER .)
    Array           reduce using rule 148 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 148 (varname -> IDENTIFIER .)
    FLOAT           reduce using rule 148 (varname -> IDENTIFIER .)
    STRING          reduce using rule 148 (varname -> IDENTIFIER .)
    true            reduce using rule 148 (varname -> IDENTIFIER .)
    false           reduce using rule 148 (varname -> IDENTIFIER .)
    $end            reduce using rule 148 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 148 (varname -> IDENTIFIER .)
    then            reduce using rule 148 (varname -> IDENTIFIER .)
    COMMA           reduce using rule 148 (varname -> IDENTIFIER .)
    do              reduce using rule 148 (varname -> IDENTIFIER .)

  ! OPEN_BRACKET    [ reduce using rule 148 (varname -> IDENTIFIER .) ]


state 126

    (110) mrhs -> args . COMMA MULTIPLY arg

    COMMA           shift and go to state 183


state 127

    (37) term1 -> mlhs EQUALS mrhs .

    SEMI_COLON      reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    NEWLINE         reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    COMMA           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    then            reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    do              reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    puts            reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    print           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    break           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    def             reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    if              reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    while           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    until           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    case            reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    for             reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    return          reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    IDENTIFIER      reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    nil             reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    self            reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    GLOBAL          reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    AT_THE_RATE     reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    MINUS           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    PLUS            reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    OPEN_BRACKET    reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    Array           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    NUMBER          reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    FLOAT           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    STRING          reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    true            reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    false           reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    $end            reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)
    CLOSE_BRACKET   reduce using rule 37 (term1 -> mlhs EQUALS mrhs .)


state 128

    (99) mlhsitem -> IDENTIFIER .
    (148) varname -> IDENTIFIER .

    EQUALS          reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MODULO_EQUALS   reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    DIVIDE_EQUALS   reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MINUS_EQUALS    reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    PLUS_EQUALS     reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    OR_EQUALS       reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    AND_EQUALS      reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    XOR_EQUALS      reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    RIGHT_SHIFT_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LEFT_SHIFT_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    MULTIPLY_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LOGICAL_AND_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    LOGICAL_OR_EQUALS reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    in              reduce using rule 99 (mlhsitem -> IDENTIFIER .)
    OPEN_SQUARE     reduce using rule 148 (varname -> IDENTIFIER .)
    MULTIPLY        reduce using rule 148 (varname -> IDENTIFIER .)
    DIVIDE          reduce using rule 148 (varname -> IDENTIFIER .)
    MODULO          reduce using rule 148 (varname -> IDENTIFIER .)
    PLUS            reduce using rule 148 (varname -> IDENTIFIER .)
    MINUS           reduce using rule 148 (varname -> IDENTIFIER .)
    LEFT_SHIFT      reduce using rule 148 (varname -> IDENTIFIER .)
    RIGHT_SHIFT     reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_AND         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_XOR         reduce using rule 148 (varname -> IDENTIFIER .)
    BIT_OR          reduce using rule 148 (varname -> IDENTIFIER .)
    DOUBLE_EQUALS   reduce using rule 148 (varname -> IDENTIFIER .)
    NOT_EQUALS      reduce using rule 148 (varname -> IDENTIFIER .)
    EQUAL_TILDE     reduce using rule 148 (varname -> IDENTIFIER .)
    COMPARISON      reduce using rule 148 (varname -> IDENTIFIER .)
    LESS            reduce using rule 148 (varname -> IDENTIFIER .)
    LESS_EQUALS     reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER         reduce using rule 148 (varname -> IDENTIFIER .)
    GREATER_EQUALS  reduce using rule 148 (varname -> IDENTIFIER .)
    INCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    EXCL_RANGE      reduce using rule 148 (varname -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 148 (varname -> IDENTIFIER .)
    SEMI_COLON      reduce using rule 148 (varname -> IDENTIFIER .)
    NEWLINE         reduce using rule 148 (varname -> IDENTIFIER .)
    puts            reduce using rule 148 (varname -> IDENTIFIER .)
    print           reduce using rule 148 (varname -> IDENTIFIER .)
    break           reduce using rule 148 (varname -> IDENTIFIER .)
    def             reduce using rule 148 (varname -> IDENTIFIER .)
    if              reduce using rule 148 (varname -> IDENTIFIER .)
    while           reduce using rule 148 (varname -> IDENTIFIER .)
    until           reduce using rule 148 (varname -> IDENTIFIER .)
    case            reduce using rule 148 (varname -> IDENTIFIER .)
    for             reduce using rule 148 (varname -> IDENTIFIER .)
    return          reduce using rule 148 (varname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 148 (varname -> IDENTIFIER .)
    nil             reduce using rule 148 (varname -> IDENTIFIER .)
    self            reduce using rule 148 (varname -> IDENTIFIER .)
    GLOBAL          reduce using rule 148 (varname -> IDENTIFIER .)
    AT_THE_RATE     reduce using rule 148 (varname -> IDENTIFIER .)
    OPEN_BRACKET    reduce using rule 148 (varname -> IDENTIFIER .)
    Array           reduce using rule 148 (varname -> IDENTIFIER .)
    NUMBER          reduce using rule 148 (varname -> IDENTIFIER .)
    FLOAT           reduce using rule 148 (varname -> IDENTIFIER .)
    STRING          reduce using rule 148 (varname -> IDENTIFIER .)
    true            reduce using rule 148 (varname -> IDENTIFIER .)
    false           reduce using rule 148 (varname -> IDENTIFIER .)
    $end            reduce using rule 148 (varname -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 148 (varname -> IDENTIFIER .)
    then            reduce using rule 148 (varname -> IDENTIFIER .)
    COMMA           reduce using rule 148 (varname -> IDENTIFIER .)
    do              reduce using rule 148 (varname -> IDENTIFIER .)


state 129

    (38) term1 -> mlhs opasgn mrhs .

    SEMI_COLON      reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    NEWLINE         reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    COMMA           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    then            reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    do              reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    puts            reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    print           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    break           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    def             reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    if              reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    while           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    until           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    case            reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    for             reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    return          reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    IDENTIFIER      reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    nil             reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    self            reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    GLOBAL          reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    AT_THE_RATE     reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    MINUS           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    PLUS            reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    OPEN_BRACKET    reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    Array           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    NUMBER          reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    FLOAT           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    STRING          reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    true            reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    false           reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    $end            reduce using rule 38 (term1 -> mlhs opasgn mrhs .)
    CLOSE_BRACKET   reduce using rule 38 (term1 -> mlhs opasgn mrhs .)


state 130

    (84) arraya -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (85) array_args -> . primary COMMA array_args
    (86) array_args -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 171
    array_args                     shift and go to state 184
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 131

    (75) primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .

    MULTIPLY        reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    DIVIDE          reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    MODULO          reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    PLUS            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    MINUS           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LEFT_SHIFT      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    RIGHT_SHIFT     reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_AND         reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_XOR         reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    BIT_OR          reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    DOUBLE_EQUALS   reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NOT_EQUALS      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    EQUAL_TILDE     reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    COMPARISON      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LESS            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LESS_EQUALS     reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GREATER         reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GREATER_EQUALS  reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    INCL_RANGE      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    EXCL_RANGE      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    LOGICAL_OR      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    SEMI_COLON      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NEWLINE         reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    puts            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    print           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    break           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    def             reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    if              reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    while           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    until           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    case            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    for             reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    return          reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    nil             reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    self            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    GLOBAL          reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    Array           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    NUMBER          reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    FLOAT           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    STRING          reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    true            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    false           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    $end            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    then            reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    COMMA           reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    do              reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)
    CLOSE_SQUARE    reduce using rule 75 (primary -> OPEN_BRACKET expr2 CLOSE_BRACKET .)


state 132

    (66) term10 -> term10 MULTIPLY term11 .

    MULTIPLY        reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    DIVIDE          reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    MODULO          reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    PLUS            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    MINUS           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    LEFT_SHIFT      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    RIGHT_SHIFT     reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    BIT_AND         reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    BIT_XOR         reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    BIT_OR          reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    DOUBLE_EQUALS   reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    NOT_EQUALS      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    EQUAL_TILDE     reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    COMPARISON      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    LESS            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    LESS_EQUALS     reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    GREATER         reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    GREATER_EQUALS  reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    INCL_RANGE      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    EXCL_RANGE      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    LOGICAL_OR      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    then            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    SEMI_COLON      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    NEWLINE         reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    puts            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    print           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    break           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    def             reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    if              reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    while           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    until           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    case            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    for             reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    return          reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    IDENTIFIER      reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    nil             reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    self            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    GLOBAL          reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    AT_THE_RATE     reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    OPEN_BRACKET    reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    Array           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    NUMBER          reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    FLOAT           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    STRING          reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    true            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    false           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    $end            reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    CLOSE_BRACKET   reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    COMMA           reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)
    do              reduce using rule 66 (term10 -> term10 MULTIPLY term11 .)


state 133

    (68) term10 -> term10 MODULO term11 .

    MULTIPLY        reduce using rule 68 (term10 -> term10 MODULO term11 .)
    DIVIDE          reduce using rule 68 (term10 -> term10 MODULO term11 .)
    MODULO          reduce using rule 68 (term10 -> term10 MODULO term11 .)
    PLUS            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    MINUS           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    LEFT_SHIFT      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    RIGHT_SHIFT     reduce using rule 68 (term10 -> term10 MODULO term11 .)
    BIT_AND         reduce using rule 68 (term10 -> term10 MODULO term11 .)
    BIT_XOR         reduce using rule 68 (term10 -> term10 MODULO term11 .)
    BIT_OR          reduce using rule 68 (term10 -> term10 MODULO term11 .)
    DOUBLE_EQUALS   reduce using rule 68 (term10 -> term10 MODULO term11 .)
    NOT_EQUALS      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    EQUAL_TILDE     reduce using rule 68 (term10 -> term10 MODULO term11 .)
    COMPARISON      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    LESS            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    LESS_EQUALS     reduce using rule 68 (term10 -> term10 MODULO term11 .)
    GREATER         reduce using rule 68 (term10 -> term10 MODULO term11 .)
    GREATER_EQUALS  reduce using rule 68 (term10 -> term10 MODULO term11 .)
    INCL_RANGE      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    EXCL_RANGE      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    LOGICAL_OR      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    then            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    SEMI_COLON      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    NEWLINE         reduce using rule 68 (term10 -> term10 MODULO term11 .)
    puts            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    print           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    break           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    def             reduce using rule 68 (term10 -> term10 MODULO term11 .)
    if              reduce using rule 68 (term10 -> term10 MODULO term11 .)
    while           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    until           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    case            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    for             reduce using rule 68 (term10 -> term10 MODULO term11 .)
    return          reduce using rule 68 (term10 -> term10 MODULO term11 .)
    IDENTIFIER      reduce using rule 68 (term10 -> term10 MODULO term11 .)
    nil             reduce using rule 68 (term10 -> term10 MODULO term11 .)
    self            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    GLOBAL          reduce using rule 68 (term10 -> term10 MODULO term11 .)
    AT_THE_RATE     reduce using rule 68 (term10 -> term10 MODULO term11 .)
    OPEN_BRACKET    reduce using rule 68 (term10 -> term10 MODULO term11 .)
    Array           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    NUMBER          reduce using rule 68 (term10 -> term10 MODULO term11 .)
    FLOAT           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    STRING          reduce using rule 68 (term10 -> term10 MODULO term11 .)
    true            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    false           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    $end            reduce using rule 68 (term10 -> term10 MODULO term11 .)
    CLOSE_BRACKET   reduce using rule 68 (term10 -> term10 MODULO term11 .)
    COMMA           reduce using rule 68 (term10 -> term10 MODULO term11 .)
    do              reduce using rule 68 (term10 -> term10 MODULO term11 .)


state 134

    (67) term10 -> term10 DIVIDE term11 .

    MULTIPLY        reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    DIVIDE          reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    MODULO          reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    PLUS            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    MINUS           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    LEFT_SHIFT      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    RIGHT_SHIFT     reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    BIT_AND         reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    BIT_XOR         reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    BIT_OR          reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    DOUBLE_EQUALS   reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    NOT_EQUALS      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    EQUAL_TILDE     reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    COMPARISON      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    LESS            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    LESS_EQUALS     reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    GREATER         reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    GREATER_EQUALS  reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    INCL_RANGE      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    EXCL_RANGE      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    LOGICAL_OR      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    then            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    SEMI_COLON      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    NEWLINE         reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    puts            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    print           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    break           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    def             reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    if              reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    while           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    until           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    case            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    for             reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    return          reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    IDENTIFIER      reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    nil             reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    self            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    GLOBAL          reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    AT_THE_RATE     reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    OPEN_BRACKET    reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    Array           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    NUMBER          reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    FLOAT           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    STRING          reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    true            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    false           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    $end            reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    CLOSE_BRACKET   reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    COMMA           reduce using rule 67 (term10 -> term10 DIVIDE term11 .)
    do              reduce using rule 67 (term10 -> term10 DIVIDE term11 .)


state 135

    (58) term7 -> term7 BIT_AND term8 .
    (60) term8 -> term8 . LEFT_SHIFT term9
    (61) term8 -> term8 . RIGHT_SHIFT term9

    BIT_AND         reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    BIT_XOR         reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    BIT_OR          reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    DOUBLE_EQUALS   reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    NOT_EQUALS      reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    EQUAL_TILDE     reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    COMPARISON      reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    LESS            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    LESS_EQUALS     reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    GREATER         reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    GREATER_EQUALS  reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    INCL_RANGE      reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    EXCL_RANGE      reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    LOGICAL_OR      reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    SEMI_COLON      reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    NEWLINE         reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    puts            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    print           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    break           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    def             reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    if              reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    while           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    until           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    case            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    for             reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    return          reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    IDENTIFIER      reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    nil             reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    self            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    GLOBAL          reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    AT_THE_RATE     reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    MINUS           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    PLUS            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    OPEN_BRACKET    reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    Array           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    NUMBER          reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    FLOAT           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    STRING          reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    true            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    false           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    $end            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    CLOSE_BRACKET   reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    then            reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    COMMA           reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    do              reduce using rule 58 (term7 -> term7 BIT_AND term8 .)
    LEFT_SHIFT      shift and go to state 112
    RIGHT_SHIFT     shift and go to state 111


state 136

    (55) term6 -> term6 BIT_XOR term7 .
    (58) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    BIT_OR          reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    DOUBLE_EQUALS   reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    NOT_EQUALS      reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    EQUAL_TILDE     reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    COMPARISON      reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    LESS            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    LESS_EQUALS     reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    GREATER         reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    GREATER_EQUALS  reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    INCL_RANGE      reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    EXCL_RANGE      reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    LOGICAL_OR      reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    SEMI_COLON      reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    NEWLINE         reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    puts            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    print           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    break           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    def             reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    if              reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    while           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    until           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    case            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    for             reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    return          reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    IDENTIFIER      reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    nil             reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    self            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    GLOBAL          reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    AT_THE_RATE     reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    MINUS           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    PLUS            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    OPEN_BRACKET    reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    Array           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    NUMBER          reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    FLOAT           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    STRING          reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    true            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    false           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    $end            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    CLOSE_BRACKET   reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    then            reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    COMMA           reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    do              reduce using rule 55 (term6 -> term6 BIT_XOR term7 .)
    BIT_AND         shift and go to state 87


state 137

    (56) term6 -> term6 BIT_OR term7 .
    (58) term7 -> term7 . BIT_AND term8

    BIT_XOR         reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    BIT_OR          reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    DOUBLE_EQUALS   reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    NOT_EQUALS      reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    EQUAL_TILDE     reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    COMPARISON      reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    LESS            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    LESS_EQUALS     reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    GREATER         reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    GREATER_EQUALS  reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    INCL_RANGE      reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    EXCL_RANGE      reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    LOGICAL_OR      reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    SEMI_COLON      reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    NEWLINE         reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    puts            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    print           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    break           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    def             reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    if              reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    while           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    until           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    case            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    for             reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    return          reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    IDENTIFIER      reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    nil             reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    self            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    GLOBAL          reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    AT_THE_RATE     reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    MINUS           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    PLUS            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    OPEN_BRACKET    reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    Array           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    NUMBER          reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    FLOAT           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    STRING          reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    true            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    false           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    $end            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    CLOSE_BRACKET   reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    then            reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    COMMA           reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    do              reduce using rule 56 (term6 -> term6 BIT_OR term7 .)
    BIT_AND         shift and go to state 87


state 138

    (48) term4 -> term5 COMPARISON term5 .
    (50) term5 -> term5 . LESS term6
    (51) term5 -> term5 . LESS_EQUALS term6
    (52) term5 -> term5 . GREATER term6
    (53) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    EXCL_RANGE      reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    LOGICAL_OR      reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    COMMA           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    SEMI_COLON      reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    NEWLINE         reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    puts            reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    print           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    break           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    def             reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    if              reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    while           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    until           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    case            reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    for             reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    return          reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    IDENTIFIER      reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    nil             reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    self            reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    GLOBAL          reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    AT_THE_RATE     reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    MINUS           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    PLUS            reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    OPEN_BRACKET    reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    Array           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    NUMBER          reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    FLOAT           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    STRING          reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    true            reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    false           reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    $end            reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    CLOSE_BRACKET   reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    then            reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    do              reduce using rule 48 (term4 -> term5 COMPARISON term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 139

    (45) term4 -> term5 DOUBLE_EQUALS term5 .
    (50) term5 -> term5 . LESS term6
    (51) term5 -> term5 . LESS_EQUALS term6
    (52) term5 -> term5 . GREATER term6
    (53) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    EXCL_RANGE      reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    LOGICAL_OR      reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    COMMA           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    SEMI_COLON      reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    NEWLINE         reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    puts            reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    print           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    break           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    def             reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    if              reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    while           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    until           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    case            reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    for             reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    return          reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    IDENTIFIER      reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    nil             reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    self            reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    GLOBAL          reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    AT_THE_RATE     reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    MINUS           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    PLUS            reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    OPEN_BRACKET    reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    Array           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    NUMBER          reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    FLOAT           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    STRING          reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    true            reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    false           reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    $end            reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    CLOSE_BRACKET   reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    then            reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    do              reduce using rule 45 (term4 -> term5 DOUBLE_EQUALS term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 140

    (52) term5 -> term5 GREATER term6 .
    (55) term6 -> term6 . BIT_XOR term7
    (56) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 52 (term5 -> term5 GREATER term6 .)
    NOT_EQUALS      reduce using rule 52 (term5 -> term5 GREATER term6 .)
    EQUAL_TILDE     reduce using rule 52 (term5 -> term5 GREATER term6 .)
    COMPARISON      reduce using rule 52 (term5 -> term5 GREATER term6 .)
    LESS            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    LESS_EQUALS     reduce using rule 52 (term5 -> term5 GREATER term6 .)
    GREATER         reduce using rule 52 (term5 -> term5 GREATER term6 .)
    GREATER_EQUALS  reduce using rule 52 (term5 -> term5 GREATER term6 .)
    INCL_RANGE      reduce using rule 52 (term5 -> term5 GREATER term6 .)
    EXCL_RANGE      reduce using rule 52 (term5 -> term5 GREATER term6 .)
    LOGICAL_OR      reduce using rule 52 (term5 -> term5 GREATER term6 .)
    SEMI_COLON      reduce using rule 52 (term5 -> term5 GREATER term6 .)
    NEWLINE         reduce using rule 52 (term5 -> term5 GREATER term6 .)
    puts            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    print           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    break           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    def             reduce using rule 52 (term5 -> term5 GREATER term6 .)
    if              reduce using rule 52 (term5 -> term5 GREATER term6 .)
    while           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    until           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    case            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    for             reduce using rule 52 (term5 -> term5 GREATER term6 .)
    return          reduce using rule 52 (term5 -> term5 GREATER term6 .)
    IDENTIFIER      reduce using rule 52 (term5 -> term5 GREATER term6 .)
    nil             reduce using rule 52 (term5 -> term5 GREATER term6 .)
    self            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    GLOBAL          reduce using rule 52 (term5 -> term5 GREATER term6 .)
    AT_THE_RATE     reduce using rule 52 (term5 -> term5 GREATER term6 .)
    MINUS           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    PLUS            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    OPEN_BRACKET    reduce using rule 52 (term5 -> term5 GREATER term6 .)
    Array           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    NUMBER          reduce using rule 52 (term5 -> term5 GREATER term6 .)
    FLOAT           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    STRING          reduce using rule 52 (term5 -> term5 GREATER term6 .)
    true            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    false           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    $end            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    CLOSE_BRACKET   reduce using rule 52 (term5 -> term5 GREATER term6 .)
    then            reduce using rule 52 (term5 -> term5 GREATER term6 .)
    COMMA           reduce using rule 52 (term5 -> term5 GREATER term6 .)
    do              reduce using rule 52 (term5 -> term5 GREATER term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 141

    (50) term5 -> term5 LESS term6 .
    (55) term6 -> term6 . BIT_XOR term7
    (56) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 50 (term5 -> term5 LESS term6 .)
    NOT_EQUALS      reduce using rule 50 (term5 -> term5 LESS term6 .)
    EQUAL_TILDE     reduce using rule 50 (term5 -> term5 LESS term6 .)
    COMPARISON      reduce using rule 50 (term5 -> term5 LESS term6 .)
    LESS            reduce using rule 50 (term5 -> term5 LESS term6 .)
    LESS_EQUALS     reduce using rule 50 (term5 -> term5 LESS term6 .)
    GREATER         reduce using rule 50 (term5 -> term5 LESS term6 .)
    GREATER_EQUALS  reduce using rule 50 (term5 -> term5 LESS term6 .)
    INCL_RANGE      reduce using rule 50 (term5 -> term5 LESS term6 .)
    EXCL_RANGE      reduce using rule 50 (term5 -> term5 LESS term6 .)
    LOGICAL_OR      reduce using rule 50 (term5 -> term5 LESS term6 .)
    SEMI_COLON      reduce using rule 50 (term5 -> term5 LESS term6 .)
    NEWLINE         reduce using rule 50 (term5 -> term5 LESS term6 .)
    puts            reduce using rule 50 (term5 -> term5 LESS term6 .)
    print           reduce using rule 50 (term5 -> term5 LESS term6 .)
    break           reduce using rule 50 (term5 -> term5 LESS term6 .)
    def             reduce using rule 50 (term5 -> term5 LESS term6 .)
    if              reduce using rule 50 (term5 -> term5 LESS term6 .)
    while           reduce using rule 50 (term5 -> term5 LESS term6 .)
    until           reduce using rule 50 (term5 -> term5 LESS term6 .)
    case            reduce using rule 50 (term5 -> term5 LESS term6 .)
    for             reduce using rule 50 (term5 -> term5 LESS term6 .)
    return          reduce using rule 50 (term5 -> term5 LESS term6 .)
    IDENTIFIER      reduce using rule 50 (term5 -> term5 LESS term6 .)
    nil             reduce using rule 50 (term5 -> term5 LESS term6 .)
    self            reduce using rule 50 (term5 -> term5 LESS term6 .)
    GLOBAL          reduce using rule 50 (term5 -> term5 LESS term6 .)
    AT_THE_RATE     reduce using rule 50 (term5 -> term5 LESS term6 .)
    MINUS           reduce using rule 50 (term5 -> term5 LESS term6 .)
    PLUS            reduce using rule 50 (term5 -> term5 LESS term6 .)
    OPEN_BRACKET    reduce using rule 50 (term5 -> term5 LESS term6 .)
    Array           reduce using rule 50 (term5 -> term5 LESS term6 .)
    NUMBER          reduce using rule 50 (term5 -> term5 LESS term6 .)
    FLOAT           reduce using rule 50 (term5 -> term5 LESS term6 .)
    STRING          reduce using rule 50 (term5 -> term5 LESS term6 .)
    true            reduce using rule 50 (term5 -> term5 LESS term6 .)
    false           reduce using rule 50 (term5 -> term5 LESS term6 .)
    $end            reduce using rule 50 (term5 -> term5 LESS term6 .)
    CLOSE_BRACKET   reduce using rule 50 (term5 -> term5 LESS term6 .)
    then            reduce using rule 50 (term5 -> term5 LESS term6 .)
    COMMA           reduce using rule 50 (term5 -> term5 LESS term6 .)
    do              reduce using rule 50 (term5 -> term5 LESS term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 142

    (46) term4 -> term5 NOT_EQUALS term5 .
    (50) term5 -> term5 . LESS term6
    (51) term5 -> term5 . LESS_EQUALS term6
    (52) term5 -> term5 . GREATER term6
    (53) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    EXCL_RANGE      reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    LOGICAL_OR      reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    COMMA           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    SEMI_COLON      reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    NEWLINE         reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    puts            reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    print           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    break           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    def             reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    if              reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    while           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    until           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    case            reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    for             reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    return          reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    IDENTIFIER      reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    nil             reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    self            reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    GLOBAL          reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    AT_THE_RATE     reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    MINUS           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    PLUS            reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    OPEN_BRACKET    reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    Array           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    NUMBER          reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    FLOAT           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    STRING          reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    true            reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    false           reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    $end            reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    CLOSE_BRACKET   reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    then            reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    do              reduce using rule 46 (term4 -> term5 NOT_EQUALS term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 143

    (51) term5 -> term5 LESS_EQUALS term6 .
    (55) term6 -> term6 . BIT_XOR term7
    (56) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    NOT_EQUALS      reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    EQUAL_TILDE     reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    COMPARISON      reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    LESS            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    LESS_EQUALS     reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    GREATER         reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    GREATER_EQUALS  reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    INCL_RANGE      reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    EXCL_RANGE      reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    LOGICAL_OR      reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    SEMI_COLON      reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    NEWLINE         reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    puts            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    print           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    break           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    def             reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    if              reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    while           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    until           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    case            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    for             reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    return          reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    IDENTIFIER      reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    nil             reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    self            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    GLOBAL          reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    AT_THE_RATE     reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    MINUS           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    PLUS            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    OPEN_BRACKET    reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    Array           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    NUMBER          reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    FLOAT           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    STRING          reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    true            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    false           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    $end            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    CLOSE_BRACKET   reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    then            reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    COMMA           reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    do              reduce using rule 51 (term5 -> term5 LESS_EQUALS term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 144

    (47) term4 -> term5 EQUAL_TILDE term5 .
    (50) term5 -> term5 . LESS term6
    (51) term5 -> term5 . LESS_EQUALS term6
    (52) term5 -> term5 . GREATER term6
    (53) term5 -> term5 . GREATER_EQUALS term6

    INCL_RANGE      reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    EXCL_RANGE      reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    LOGICAL_OR      reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    COMMA           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    SEMI_COLON      reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    NEWLINE         reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    puts            reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    print           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    break           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    def             reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    if              reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    while           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    until           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    case            reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    for             reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    return          reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    IDENTIFIER      reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    nil             reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    self            reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    GLOBAL          reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    AT_THE_RATE     reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    MINUS           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    PLUS            reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    OPEN_BRACKET    reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    Array           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    NUMBER          reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    FLOAT           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    STRING          reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    true            reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    false           reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    $end            reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    CLOSE_BRACKET   reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    then            reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    do              reduce using rule 47 (term4 -> term5 EQUAL_TILDE term5 .)
    LESS            shift and go to state 93
    LESS_EQUALS     shift and go to state 95
    GREATER         shift and go to state 92
    GREATER_EQUALS  shift and go to state 97


state 145

    (53) term5 -> term5 GREATER_EQUALS term6 .
    (55) term6 -> term6 . BIT_XOR term7
    (56) term6 -> term6 . BIT_OR term7

    DOUBLE_EQUALS   reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    NOT_EQUALS      reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    EQUAL_TILDE     reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    COMPARISON      reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    LESS            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    LESS_EQUALS     reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    GREATER         reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    GREATER_EQUALS  reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    INCL_RANGE      reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    EXCL_RANGE      reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    LOGICAL_OR      reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    SEMI_COLON      reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    NEWLINE         reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    puts            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    print           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    break           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    def             reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    if              reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    while           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    until           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    case            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    for             reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    return          reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    IDENTIFIER      reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    nil             reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    self            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    GLOBAL          reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    AT_THE_RATE     reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    MINUS           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    PLUS            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    OPEN_BRACKET    reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    Array           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    NUMBER          reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    FLOAT           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    STRING          reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    true            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    false           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    $end            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    CLOSE_BRACKET   reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    then            reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    COMMA           reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    do              reduce using rule 53 (term5 -> term5 GREATER_EQUALS term6 .)
    BIT_XOR         shift and go to state 88
    BIT_OR          shift and go to state 89


state 146

    (40) term2 -> term3 INCL_RANGE term3 .
    (43) term3 -> term3 . LOGICAL_OR term4

    SEMI_COLON      reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    NEWLINE         reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    puts            reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    print           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    break           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    def             reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    if              reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    while           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    until           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    case            reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    for             reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    return          reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    IDENTIFIER      reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    nil             reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    self            reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    GLOBAL          reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    AT_THE_RATE     reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    MINUS           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    PLUS            reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    OPEN_BRACKET    reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    Array           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    NUMBER          reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    FLOAT           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    STRING          reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    true            reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    false           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    $end            reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    CLOSE_BRACKET   reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    then            reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    COMMA           reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    do              reduce using rule 40 (term2 -> term3 INCL_RANGE term3 .)
    LOGICAL_OR      shift and go to state 100


state 147

    (41) term2 -> term3 EXCL_RANGE term3 .
    (43) term3 -> term3 . LOGICAL_OR term4

    SEMI_COLON      reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    NEWLINE         reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    puts            reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    print           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    break           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    def             reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    if              reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    while           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    until           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    case            reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    for             reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    return          reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    IDENTIFIER      reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    nil             reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    self            reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    GLOBAL          reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    AT_THE_RATE     reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    MINUS           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    PLUS            reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    OPEN_BRACKET    reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    Array           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    NUMBER          reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    FLOAT           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    STRING          reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    true            reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    false           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    $end            reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    CLOSE_BRACKET   reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    then            reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    COMMA           reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    do              reduce using rule 41 (term2 -> term3 EXCL_RANGE term3 .)
    LOGICAL_OR      shift and go to state 100


state 148

    (43) term3 -> term3 LOGICAL_OR term4 .

    INCL_RANGE      reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    EXCL_RANGE      reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    LOGICAL_OR      reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    SEMI_COLON      reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    NEWLINE         reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    puts            reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    print           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    break           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    def             reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    if              reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    while           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    until           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    case            reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    for             reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    return          reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    IDENTIFIER      reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    nil             reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    self            reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    GLOBAL          reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    AT_THE_RATE     reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    MINUS           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    PLUS            reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    OPEN_BRACKET    reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    Array           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    NUMBER          reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    FLOAT           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    STRING          reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    true            reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    false           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    $end            reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    CLOSE_BRACKET   reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    then            reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    COMMA           reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)
    do              reduce using rule 43 (term3 -> term3 LOGICAL_OR term4 .)


state 149

    (63) term9 -> term9 PLUS term10 .
    (66) term10 -> term10 . MULTIPLY term11
    (67) term10 -> term10 . DIVIDE term11
    (68) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    MINUS           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    LEFT_SHIFT      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    RIGHT_SHIFT     reduce using rule 63 (term9 -> term9 PLUS term10 .)
    BIT_AND         reduce using rule 63 (term9 -> term9 PLUS term10 .)
    BIT_XOR         reduce using rule 63 (term9 -> term9 PLUS term10 .)
    BIT_OR          reduce using rule 63 (term9 -> term9 PLUS term10 .)
    LESS            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    LESS_EQUALS     reduce using rule 63 (term9 -> term9 PLUS term10 .)
    GREATER         reduce using rule 63 (term9 -> term9 PLUS term10 .)
    GREATER_EQUALS  reduce using rule 63 (term9 -> term9 PLUS term10 .)
    INCL_RANGE      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    EXCL_RANGE      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    LOGICAL_OR      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    SEMI_COLON      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    NEWLINE         reduce using rule 63 (term9 -> term9 PLUS term10 .)
    puts            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    print           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    break           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    def             reduce using rule 63 (term9 -> term9 PLUS term10 .)
    if              reduce using rule 63 (term9 -> term9 PLUS term10 .)
    while           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    until           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    case            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    for             reduce using rule 63 (term9 -> term9 PLUS term10 .)
    return          reduce using rule 63 (term9 -> term9 PLUS term10 .)
    IDENTIFIER      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    nil             reduce using rule 63 (term9 -> term9 PLUS term10 .)
    self            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    GLOBAL          reduce using rule 63 (term9 -> term9 PLUS term10 .)
    AT_THE_RATE     reduce using rule 63 (term9 -> term9 PLUS term10 .)
    OPEN_BRACKET    reduce using rule 63 (term9 -> term9 PLUS term10 .)
    Array           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    NUMBER          reduce using rule 63 (term9 -> term9 PLUS term10 .)
    FLOAT           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    STRING          reduce using rule 63 (term9 -> term9 PLUS term10 .)
    true            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    false           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    $end            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    CLOSE_BRACKET   reduce using rule 63 (term9 -> term9 PLUS term10 .)
    then            reduce using rule 63 (term9 -> term9 PLUS term10 .)
    COMMA           reduce using rule 63 (term9 -> term9 PLUS term10 .)
    do              reduce using rule 63 (term9 -> term9 PLUS term10 .)
    DOUBLE_EQUALS   reduce using rule 63 (term9 -> term9 PLUS term10 .)
    NOT_EQUALS      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    EQUAL_TILDE     reduce using rule 63 (term9 -> term9 PLUS term10 .)
    COMPARISON      reduce using rule 63 (term9 -> term9 PLUS term10 .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 86
    MODULO          shift and go to state 85


state 150

    (64) term9 -> term9 MINUS term10 .
    (66) term10 -> term10 . MULTIPLY term11
    (67) term10 -> term10 . DIVIDE term11
    (68) term10 -> term10 . MODULO term11

    PLUS            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    MINUS           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    LEFT_SHIFT      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    RIGHT_SHIFT     reduce using rule 64 (term9 -> term9 MINUS term10 .)
    BIT_AND         reduce using rule 64 (term9 -> term9 MINUS term10 .)
    BIT_XOR         reduce using rule 64 (term9 -> term9 MINUS term10 .)
    BIT_OR          reduce using rule 64 (term9 -> term9 MINUS term10 .)
    LESS            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    LESS_EQUALS     reduce using rule 64 (term9 -> term9 MINUS term10 .)
    GREATER         reduce using rule 64 (term9 -> term9 MINUS term10 .)
    GREATER_EQUALS  reduce using rule 64 (term9 -> term9 MINUS term10 .)
    INCL_RANGE      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    EXCL_RANGE      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    LOGICAL_OR      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    SEMI_COLON      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    NEWLINE         reduce using rule 64 (term9 -> term9 MINUS term10 .)
    puts            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    print           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    break           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    def             reduce using rule 64 (term9 -> term9 MINUS term10 .)
    if              reduce using rule 64 (term9 -> term9 MINUS term10 .)
    while           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    until           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    case            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    for             reduce using rule 64 (term9 -> term9 MINUS term10 .)
    return          reduce using rule 64 (term9 -> term9 MINUS term10 .)
    IDENTIFIER      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    nil             reduce using rule 64 (term9 -> term9 MINUS term10 .)
    self            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    GLOBAL          reduce using rule 64 (term9 -> term9 MINUS term10 .)
    AT_THE_RATE     reduce using rule 64 (term9 -> term9 MINUS term10 .)
    OPEN_BRACKET    reduce using rule 64 (term9 -> term9 MINUS term10 .)
    Array           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    NUMBER          reduce using rule 64 (term9 -> term9 MINUS term10 .)
    FLOAT           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    STRING          reduce using rule 64 (term9 -> term9 MINUS term10 .)
    true            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    false           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    $end            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    CLOSE_BRACKET   reduce using rule 64 (term9 -> term9 MINUS term10 .)
    then            reduce using rule 64 (term9 -> term9 MINUS term10 .)
    COMMA           reduce using rule 64 (term9 -> term9 MINUS term10 .)
    do              reduce using rule 64 (term9 -> term9 MINUS term10 .)
    DOUBLE_EQUALS   reduce using rule 64 (term9 -> term9 MINUS term10 .)
    NOT_EQUALS      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    EQUAL_TILDE     reduce using rule 64 (term9 -> term9 MINUS term10 .)
    COMPARISON      reduce using rule 64 (term9 -> term9 MINUS term10 .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 86
    MODULO          shift and go to state 85


state 151

    (125) variable -> varname .

    OPEN_SQUARE     reduce using rule 125 (variable -> varname .)


state 152

    (22) expr -> for M_1 mlhs . in expr1 pdo M_1 multstmt end M_1

    in              shift and go to state 185


state 153

    (83) arrayal -> variable . OPEN_SQUARE array_args CLOSE_SQUARE

    OPEN_SQUARE     shift and go to state 186


state 154

    (9) stmt -> print OPEN_BRACKET primary . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 187


state 155

    (8) stmt -> puts OPEN_BRACKET STRING . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 188


state 156

    (32) function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NEWLINE         reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    do              reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    puts            reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    print           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    break           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    def             reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    if              reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    while           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    until           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    case            reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    for             reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    return          reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    nil             reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    self            reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    GLOBAL          reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    MINUS           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    PLUS            reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    Array           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NUMBER          reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    FLOAT           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    STRING          reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    true            reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    false           reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    $end            reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    then            reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 32 (function -> IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)


state 157

    (114) callarglist -> empty .

    CLOSE_BRACKET   reduce using rule 114 (callarglist -> empty .)


state 158

    (112) callargs -> callarglist .

    CLOSE_BRACKET   reduce using rule 112 (callargs -> callarglist .)


state 159

    (113) callarglist -> primary . callmultarglist
    (115) callmultarglist -> . COMMA primary callmultarglist
    (116) callmultarglist -> . empty
    (151) empty -> .

    COMMA           shift and go to state 190
    CLOSE_BRACKET   reduce using rule 151 (empty -> .)

    callmultarglist                shift and go to state 189
    empty                          shift and go to state 191

state 160

    (31) function -> IDENTIFIER OPEN_BRACKET callargs . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 192


state 161

    (20) expr -> until M_1 expr1 . pdo M_1 multstmt end M_1
    (131) pdo -> . newline
    (132) pdo -> . do newline
    (133) pdo -> . newline do
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    do              shift and go to state 193
    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    pdo                            shift and go to state 195
    newline                        shift and go to state 194

state 162

    (61) term8 -> term8 RIGHT_SHIFT term9 .
    (63) term9 -> term9 . PLUS term10
    (64) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    RIGHT_SHIFT     reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_AND         reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_XOR         reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    BIT_OR          reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    DOUBLE_EQUALS   reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    NOT_EQUALS      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    EQUAL_TILDE     reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    COMPARISON      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    LESS            reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    LESS_EQUALS     reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    GREATER         reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    GREATER_EQUALS  reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    INCL_RANGE      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    EXCL_RANGE      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    LOGICAL_OR      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    SEMI_COLON      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    NEWLINE         reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    puts            reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    print           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    break           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    def             reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    if              reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    while           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    until           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    case            reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    for             reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    return          reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    IDENTIFIER      reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    nil             reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    self            reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    GLOBAL          reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    AT_THE_RATE     reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    OPEN_BRACKET    reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    Array           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    NUMBER          reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    FLOAT           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    STRING          reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    true            reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    false           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    $end            reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    CLOSE_BRACKET   reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    then            reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    COMMA           reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    do              reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102

  ! MINUS           [ reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .) ]
  ! PLUS            [ reduce using rule 61 (term8 -> term8 RIGHT_SHIFT term9 .) ]


state 163

    (60) term8 -> term8 LEFT_SHIFT term9 .
    (63) term9 -> term9 . PLUS term10
    (64) term9 -> term9 . MINUS term10

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LEFT_SHIFT      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    RIGHT_SHIFT     reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_AND         reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_XOR         reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    BIT_OR          reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    DOUBLE_EQUALS   reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    NOT_EQUALS      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    EQUAL_TILDE     reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    COMPARISON      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    LESS            reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    LESS_EQUALS     reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    GREATER         reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    GREATER_EQUALS  reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    INCL_RANGE      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    EXCL_RANGE      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    LOGICAL_OR      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    SEMI_COLON      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    NEWLINE         reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    puts            reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    print           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    break           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    def             reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    if              reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    while           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    until           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    case            reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    for             reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    return          reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    IDENTIFIER      reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    nil             reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    self            reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    GLOBAL          reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    AT_THE_RATE     reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    OPEN_BRACKET    reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    Array           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    NUMBER          reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    FLOAT           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    STRING          reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    true            reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    false           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    $end            reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    CLOSE_BRACKET   reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    then            reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    COMMA           reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    do              reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102

  ! MINUS           [ reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .) ]
  ! PLUS            [ reduce using rule 60 (term8 -> term8 LEFT_SHIFT term9 .) ]


state 164

    (21) expr -> case expr1 newline . multcase end M_1
    (87) multcase -> . when whenargs pthen M_1 multstmt M_1 multcase
    (88) multcase -> . when whenargs pthen M_1 multstmt M_1

    when            shift and go to state 196

    multcase                       shift and go to state 197

state 165

    (19) expr -> while M_1 expr1 . pdo M_1 multstmt end M_1
    (131) pdo -> . newline
    (132) pdo -> . do newline
    (133) pdo -> . newline do
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    do              shift and go to state 193
    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    pdo                            shift and go to state 198
    newline                        shift and go to state 194

state 166

    (129) pthen -> then .

    puts            reduce using rule 129 (pthen -> then .)
    print           reduce using rule 129 (pthen -> then .)
    break           reduce using rule 129 (pthen -> then .)
    def             reduce using rule 129 (pthen -> then .)
    if              reduce using rule 129 (pthen -> then .)
    while           reduce using rule 129 (pthen -> then .)
    until           reduce using rule 129 (pthen -> then .)
    case            reduce using rule 129 (pthen -> then .)
    for             reduce using rule 129 (pthen -> then .)
    return          reduce using rule 129 (pthen -> then .)
    IDENTIFIER      reduce using rule 129 (pthen -> then .)
    nil             reduce using rule 129 (pthen -> then .)
    self            reduce using rule 129 (pthen -> then .)
    GLOBAL          reduce using rule 129 (pthen -> then .)
    AT_THE_RATE     reduce using rule 129 (pthen -> then .)
    MINUS           reduce using rule 129 (pthen -> then .)
    PLUS            reduce using rule 129 (pthen -> then .)
    OPEN_BRACKET    reduce using rule 129 (pthen -> then .)
    Array           reduce using rule 129 (pthen -> then .)
    NUMBER          reduce using rule 129 (pthen -> then .)
    FLOAT           reduce using rule 129 (pthen -> then .)
    STRING          reduce using rule 129 (pthen -> then .)
    true            reduce using rule 129 (pthen -> then .)
    false           reduce using rule 129 (pthen -> then .)
    elsif           reduce using rule 129 (pthen -> then .)
    else            reduce using rule 129 (pthen -> then .)
    end             reduce using rule 129 (pthen -> then .)
    when            reduce using rule 129 (pthen -> then .)


state 167

    (128) pthen -> newline .
    (130) pthen -> newline . then

    puts            reduce using rule 128 (pthen -> newline .)
    print           reduce using rule 128 (pthen -> newline .)
    break           reduce using rule 128 (pthen -> newline .)
    def             reduce using rule 128 (pthen -> newline .)
    if              reduce using rule 128 (pthen -> newline .)
    while           reduce using rule 128 (pthen -> newline .)
    until           reduce using rule 128 (pthen -> newline .)
    case            reduce using rule 128 (pthen -> newline .)
    for             reduce using rule 128 (pthen -> newline .)
    return          reduce using rule 128 (pthen -> newline .)
    IDENTIFIER      reduce using rule 128 (pthen -> newline .)
    nil             reduce using rule 128 (pthen -> newline .)
    self            reduce using rule 128 (pthen -> newline .)
    GLOBAL          reduce using rule 128 (pthen -> newline .)
    AT_THE_RATE     reduce using rule 128 (pthen -> newline .)
    MINUS           reduce using rule 128 (pthen -> newline .)
    PLUS            reduce using rule 128 (pthen -> newline .)
    OPEN_BRACKET    reduce using rule 128 (pthen -> newline .)
    Array           reduce using rule 128 (pthen -> newline .)
    NUMBER          reduce using rule 128 (pthen -> newline .)
    FLOAT           reduce using rule 128 (pthen -> newline .)
    STRING          reduce using rule 128 (pthen -> newline .)
    true            reduce using rule 128 (pthen -> newline .)
    false           reduce using rule 128 (pthen -> newline .)
    elsif           reduce using rule 128 (pthen -> newline .)
    else            reduce using rule 128 (pthen -> newline .)
    end             reduce using rule 128 (pthen -> newline .)
    when            reduce using rule 128 (pthen -> newline .)
    then            shift and go to state 199


state 168

    (16) expr -> if expr1 pthen . M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> if expr1 pthen . M_1 multstmt M_1 multelsif end M_1
    (18) expr -> if expr1 pthen . M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    else            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)
    elsif           reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 200
    empty                          shift and go to state 105

state 169

    (2) multcompstmt -> newline stmt1 multcompstmt .

    $end            reduce using rule 2 (multcompstmt -> newline stmt1 multcompstmt .)


state 170

    (83) arrayal -> variable OPEN_SQUARE array_args . CLOSE_SQUARE
    (84) arraya -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 201


state 171

    (85) array_args -> primary . COMMA array_args
    (86) array_args -> primary .

    COMMA           shift and go to state 202
    CLOSE_SQUARE    reduce using rule 86 (array_args -> primary .)


state 172

    (81) array_size -> primary . COMMA array_size
    (82) array_size -> primary .

    COMMA           shift and go to state 203
    CLOSE_BRACKET   reduce using rule 82 (array_size -> primary .)


state 173

    (80) arrayd -> Array OPEN_BRACKET array_size . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 204


state 174

    (7) stmt -> keydef argdecl newline . multstmt keyend
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 207
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 175

    (120) argdecl -> OPEN_BRACKET arglist . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 208


state 176

    (121) arglist -> IDENTIFIER . multarglist
    (123) multarglist -> . COMMA IDENTIFIER multarglist
    (124) multarglist -> . empty
    (151) empty -> .

    COMMA           shift and go to state 209
    CLOSE_BRACKET   reduce using rule 151 (empty -> .)

    multarglist                    shift and go to state 210
    empty                          shift and go to state 211

state 177

    (122) arglist -> empty .

    CLOSE_BRACKET   reduce using rule 122 (arglist -> empty .)


state 178

    (118) multargs -> COMMA . arg multargs
    (33) arg -> . term0
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    IDENTIFIER      shift and go to state 128
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 212
    arrayal                        shift and go to state 32
    literal                        shift and go to state 34
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 179

    (117) args -> arg multargs .

    COMMA           reduce using rule 117 (args -> arg multargs .)


state 180

    (119) multargs -> empty .

    COMMA           reduce using rule 119 (multargs -> empty .)


state 181

    (111) mrhs -> MULTIPLY arg .

    SEMI_COLON      reduce using rule 111 (mrhs -> MULTIPLY arg .)
    NEWLINE         reduce using rule 111 (mrhs -> MULTIPLY arg .)
    puts            reduce using rule 111 (mrhs -> MULTIPLY arg .)
    print           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    break           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    def             reduce using rule 111 (mrhs -> MULTIPLY arg .)
    if              reduce using rule 111 (mrhs -> MULTIPLY arg .)
    while           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    until           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    case            reduce using rule 111 (mrhs -> MULTIPLY arg .)
    for             reduce using rule 111 (mrhs -> MULTIPLY arg .)
    return          reduce using rule 111 (mrhs -> MULTIPLY arg .)
    IDENTIFIER      reduce using rule 111 (mrhs -> MULTIPLY arg .)
    nil             reduce using rule 111 (mrhs -> MULTIPLY arg .)
    self            reduce using rule 111 (mrhs -> MULTIPLY arg .)
    GLOBAL          reduce using rule 111 (mrhs -> MULTIPLY arg .)
    AT_THE_RATE     reduce using rule 111 (mrhs -> MULTIPLY arg .)
    MINUS           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    PLUS            reduce using rule 111 (mrhs -> MULTIPLY arg .)
    OPEN_BRACKET    reduce using rule 111 (mrhs -> MULTIPLY arg .)
    Array           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    NUMBER          reduce using rule 111 (mrhs -> MULTIPLY arg .)
    FLOAT           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    STRING          reduce using rule 111 (mrhs -> MULTIPLY arg .)
    true            reduce using rule 111 (mrhs -> MULTIPLY arg .)
    false           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    $end            reduce using rule 111 (mrhs -> MULTIPLY arg .)
    CLOSE_BRACKET   reduce using rule 111 (mrhs -> MULTIPLY arg .)
    then            reduce using rule 111 (mrhs -> MULTIPLY arg .)
    COMMA           reduce using rule 111 (mrhs -> MULTIPLY arg .)
    do              reduce using rule 111 (mrhs -> MULTIPLY arg .)


state 182

    (34) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET . CLOSE_BRACKET
    (35) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET . callargs CLOSE_BRACKET
    (112) callargs -> . callarglist
    (113) callarglist -> . primary callmultarglist
    (114) callarglist -> . empty
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (151) empty -> .
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

  ! shift/reduce conflict for CLOSE_BRACKET resolved as shift
    CLOSE_BRACKET   shift and go to state 213
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

  ! CLOSE_BRACKET   [ reduce using rule 151 (empty -> .) ]

    callarglist                    shift and go to state 158
    varname                        shift and go to state 79
    primary                        shift and go to state 159
    literal                        shift and go to state 34
    callargs                       shift and go to state 214
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    empty                          shift and go to state 157
    arrayd                         shift and go to state 48

state 183

    (110) mrhs -> args COMMA . MULTIPLY arg

    MULTIPLY        shift and go to state 215


state 184

    (84) arraya -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 216


state 185

    (22) expr -> for M_1 mlhs in . expr1 pdo M_1 multstmt end M_1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    literal                        shift and go to state 34
    expr1                          shift and go to state 217
    call                           shift and go to state 35
    function                       shift and go to state 39
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 186

    (83) arrayal -> variable OPEN_SQUARE . array_args CLOSE_SQUARE
    (85) array_args -> . primary COMMA array_args
    (86) array_args -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 171
    array_args                     shift and go to state 218
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 187

    (9) stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    NEWLINE         reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    puts            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    print           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    break           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    def             reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    if              reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    while           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    until           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    case            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    for             reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    return          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    nil             reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    self            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    GLOBAL          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    MINUS           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    PLUS            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    Array           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    NUMBER          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    FLOAT           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    STRING          reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    true            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    false           reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)
    $end            reduce using rule 9 (stmt -> print OPEN_BRACKET primary CLOSE_BRACKET .)


state 188

    (8) stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    NEWLINE         reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    puts            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    print           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    break           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    def             reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    if              reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    while           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    until           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    case            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    for             reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    return          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    nil             reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    self            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    GLOBAL          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    MINUS           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    PLUS            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    Array           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    NUMBER          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    FLOAT           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    STRING          reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    true            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    false           reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)
    $end            reduce using rule 8 (stmt -> puts OPEN_BRACKET STRING CLOSE_BRACKET .)


state 189

    (113) callarglist -> primary callmultarglist .

    CLOSE_BRACKET   reduce using rule 113 (callarglist -> primary callmultarglist .)


state 190

    (115) callmultarglist -> COMMA . primary callmultarglist
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 219
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 191

    (116) callmultarglist -> empty .

    CLOSE_BRACKET   reduce using rule 116 (callmultarglist -> empty .)


state 192

    (31) function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NEWLINE         reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    do              reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    puts            reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    print           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    break           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    def             reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    if              reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    while           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    until           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    case            reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    for             reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    return          reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    nil             reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    self            reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    GLOBAL          reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    MINUS           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    PLUS            reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    Array           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NUMBER          reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    FLOAT           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    STRING          reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    true            reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    false           reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    $end            reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    then            reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 31 (function -> IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)


state 193

    (132) pdo -> do . newline
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 220

state 194

    (131) pdo -> newline .
    (133) pdo -> newline . do

    puts            reduce using rule 131 (pdo -> newline .)
    print           reduce using rule 131 (pdo -> newline .)
    break           reduce using rule 131 (pdo -> newline .)
    def             reduce using rule 131 (pdo -> newline .)
    if              reduce using rule 131 (pdo -> newline .)
    while           reduce using rule 131 (pdo -> newline .)
    until           reduce using rule 131 (pdo -> newline .)
    case            reduce using rule 131 (pdo -> newline .)
    for             reduce using rule 131 (pdo -> newline .)
    return          reduce using rule 131 (pdo -> newline .)
    IDENTIFIER      reduce using rule 131 (pdo -> newline .)
    nil             reduce using rule 131 (pdo -> newline .)
    self            reduce using rule 131 (pdo -> newline .)
    GLOBAL          reduce using rule 131 (pdo -> newline .)
    AT_THE_RATE     reduce using rule 131 (pdo -> newline .)
    MINUS           reduce using rule 131 (pdo -> newline .)
    PLUS            reduce using rule 131 (pdo -> newline .)
    OPEN_BRACKET    reduce using rule 131 (pdo -> newline .)
    Array           reduce using rule 131 (pdo -> newline .)
    NUMBER          reduce using rule 131 (pdo -> newline .)
    FLOAT           reduce using rule 131 (pdo -> newline .)
    STRING          reduce using rule 131 (pdo -> newline .)
    true            reduce using rule 131 (pdo -> newline .)
    false           reduce using rule 131 (pdo -> newline .)
    end             reduce using rule 131 (pdo -> newline .)
    do              shift and go to state 221


state 195

    (20) expr -> until M_1 expr1 pdo . M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 222
    empty                          shift and go to state 105

state 196

    (87) multcase -> when . whenargs pthen M_1 multstmt M_1 multcase
    (88) multcase -> when . whenargs pthen M_1 multstmt M_1
    (97) whenargs -> . arg
    (33) arg -> . term0
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    IDENTIFIER      shift and go to state 128
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 223
    arrayal                        shift and go to state 32
    literal                        shift and go to state 34
    whenargs                       shift and go to state 224
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 197

    (21) expr -> case expr1 newline multcase . end M_1

    end             shift and go to state 225


state 198

    (19) expr -> while M_1 expr1 pdo . M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 226
    empty                          shift and go to state 105

state 199

    (130) pthen -> newline then .

    puts            reduce using rule 130 (pthen -> newline then .)
    print           reduce using rule 130 (pthen -> newline then .)
    break           reduce using rule 130 (pthen -> newline then .)
    def             reduce using rule 130 (pthen -> newline then .)
    if              reduce using rule 130 (pthen -> newline then .)
    while           reduce using rule 130 (pthen -> newline then .)
    until           reduce using rule 130 (pthen -> newline then .)
    case            reduce using rule 130 (pthen -> newline then .)
    for             reduce using rule 130 (pthen -> newline then .)
    return          reduce using rule 130 (pthen -> newline then .)
    IDENTIFIER      reduce using rule 130 (pthen -> newline then .)
    nil             reduce using rule 130 (pthen -> newline then .)
    self            reduce using rule 130 (pthen -> newline then .)
    GLOBAL          reduce using rule 130 (pthen -> newline then .)
    AT_THE_RATE     reduce using rule 130 (pthen -> newline then .)
    MINUS           reduce using rule 130 (pthen -> newline then .)
    PLUS            reduce using rule 130 (pthen -> newline then .)
    OPEN_BRACKET    reduce using rule 130 (pthen -> newline then .)
    Array           reduce using rule 130 (pthen -> newline then .)
    NUMBER          reduce using rule 130 (pthen -> newline then .)
    FLOAT           reduce using rule 130 (pthen -> newline then .)
    STRING          reduce using rule 130 (pthen -> newline then .)
    true            reduce using rule 130 (pthen -> newline then .)
    false           reduce using rule 130 (pthen -> newline then .)
    elsif           reduce using rule 130 (pthen -> newline then .)
    else            reduce using rule 130 (pthen -> newline then .)
    end             reduce using rule 130 (pthen -> newline then .)
    when            reduce using rule 130 (pthen -> newline then .)


state 200

    (16) expr -> if expr1 pthen M_1 . multstmt else newline M_1 multstmt end M_1
    (17) expr -> if expr1 pthen M_1 . multstmt M_1 multelsif end M_1
    (18) expr -> if expr1 pthen M_1 . multstmt end M_1
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    else            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)
    elsif           reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 227
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 201

    (83) arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .
    (84) arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    EQUALS          reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO_EQUALS   reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE_EQUALS   reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS_EQUALS    reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS_EQUALS     reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OR_EQUALS       reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    AND_EQUALS      reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    XOR_EQUALS      reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT_EQUALS reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT_EQUALS reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MULTIPLY_EQUALS reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_AND_EQUALS reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR_EQUALS reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MULTIPLY        reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_AND         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_XOR         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_OR          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DOUBLE_EQUALS   reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NOT_EQUALS      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EQUAL_TILDE     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMPARISON      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS_EQUALS     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER_EQUALS  reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    INCL_RANGE      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EXCL_RANGE      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    SEMI_COLON      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NEWLINE         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    puts            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    print           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    break           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    def             reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    if              reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    while           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    until           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    case            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    for             reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    return          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    IDENTIFIER      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    nil             reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    self            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GLOBAL          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    AT_THE_RATE     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OPEN_BRACKET    reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    Array           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NUMBER          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    FLOAT           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    STRING          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    true            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    false           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    $end            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_BRACKET   reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    then            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMMA           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    do              reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 202

    (85) array_args -> primary COMMA . array_args
    (85) array_args -> . primary COMMA array_args
    (86) array_args -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    varname                        shift and go to state 79
    primary                        shift and go to state 171
    array_args                     shift and go to state 228
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 203

    (81) array_size -> primary COMMA . array_size
    (81) array_size -> . primary COMMA array_size
    (82) array_size -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self

    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    IDENTIFIER      shift and go to state 77
    nil             shift and go to state 56
    self            shift and go to state 52

    array_size                     shift and go to state 229
    varname                        shift and go to state 79
    primary                        shift and go to state 172
    literal                        shift and go to state 34
    variable                       shift and go to state 78
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48

state 204

    (80) arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .

    MULTIPLY        reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    DIVIDE          reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    MODULO          reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    PLUS            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    MINUS           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LEFT_SHIFT      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    RIGHT_SHIFT     reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_AND         reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_XOR         reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    BIT_OR          reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    DOUBLE_EQUALS   reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NOT_EQUALS      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    EQUAL_TILDE     reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    COMPARISON      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LESS            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LESS_EQUALS     reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GREATER         reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GREATER_EQUALS  reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    INCL_RANGE      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    EXCL_RANGE      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    LOGICAL_OR      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    SEMI_COLON      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NEWLINE         reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    puts            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    print           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    break           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    def             reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    if              reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    while           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    until           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    case            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    for             reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    return          reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    nil             reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    self            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    GLOBAL          reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    Array           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    NUMBER          reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    FLOAT           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    STRING          reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    true            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    false           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    $end            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    then            reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    COMMA           reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    do              reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)
    CLOSE_SQUARE    reduce using rule 80 (arrayd -> Array OPEN_BRACKET array_size CLOSE_BRACKET .)


state 205

    (14) multstmt -> stmt . newline multstmt
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 230

state 206

    (15) multstmt -> empty .

    end             reduce using rule 15 (multstmt -> empty .)
    else            reduce using rule 15 (multstmt -> empty .)
    elsif           reduce using rule 15 (multstmt -> empty .)
    when            reduce using rule 15 (multstmt -> empty .)


state 207

    (7) stmt -> keydef argdecl newline multstmt . keyend
    (13) keyend -> . end

    end             shift and go to state 232

    keyend                         shift and go to state 231

state 208

    (120) argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 120 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)
    NEWLINE         reduce using rule 120 (argdecl -> OPEN_BRACKET arglist CLOSE_BRACKET .)


state 209

    (123) multarglist -> COMMA . IDENTIFIER multarglist

    IDENTIFIER      shift and go to state 233


state 210

    (121) arglist -> IDENTIFIER multarglist .

    CLOSE_BRACKET   reduce using rule 121 (arglist -> IDENTIFIER multarglist .)


state 211

    (124) multarglist -> empty .

    CLOSE_BRACKET   reduce using rule 124 (multarglist -> empty .)


state 212

    (118) multargs -> COMMA arg . multargs
    (118) multargs -> . COMMA arg multargs
    (119) multargs -> . empty
    (151) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 178

  ! COMMA           [ reduce using rule 151 (empty -> .) ]

    multargs                       shift and go to state 234
    empty                          shift and go to state 180

state 213

    (34) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NEWLINE         reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    do              reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    then            reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    COMMA           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    puts            reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    print           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    break           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    def             reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    if              reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    while           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    until           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    case            reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    for             reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    return          reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    nil             reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    self            reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    GLOBAL          reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    MINUS           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    PLUS            reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    Array           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    NUMBER          reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    FLOAT           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    STRING          reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    true            reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    false           reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    $end            reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 34 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET .)


state 214

    (35) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 235


state 215

    (110) mrhs -> args COMMA MULTIPLY . arg
    (33) arg -> . term0
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    IDENTIFIER      shift and go to state 128
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 236
    arrayal                        shift and go to state 32
    literal                        shift and go to state 34
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 216

    (84) arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    MULTIPLY        reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DIVIDE          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MODULO          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    PLUS            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    MINUS           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LEFT_SHIFT      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    RIGHT_SHIFT     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_AND         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_XOR         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    BIT_OR          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    DOUBLE_EQUALS   reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NOT_EQUALS      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EQUAL_TILDE     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMPARISON      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LESS_EQUALS     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GREATER_EQUALS  reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    INCL_RANGE      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    EXCL_RANGE      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    LOGICAL_OR      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    SEMI_COLON      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NEWLINE         reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    puts            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    print           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    break           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    def             reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    if              reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    while           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    until           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    case            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    for             reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    return          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    IDENTIFIER      reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    nil             reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    self            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    GLOBAL          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    AT_THE_RATE     reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    OPEN_BRACKET    reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    Array           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    NUMBER          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    FLOAT           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    STRING          reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    true            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    false           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    $end            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_BRACKET   reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    then            reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    COMMA           reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    do              reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)
    CLOSE_SQUARE    reduce using rule 84 (arraya -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 217

    (22) expr -> for M_1 mlhs in expr1 . pdo M_1 multstmt end M_1
    (131) pdo -> . newline
    (132) pdo -> . do newline
    (133) pdo -> . newline do
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    do              shift and go to state 193
    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 194
    pdo                            shift and go to state 237

state 218

    (83) arrayal -> variable OPEN_SQUARE array_args . CLOSE_SQUARE

    CLOSE_SQUARE    shift and go to state 238


state 219

    (115) callmultarglist -> COMMA primary . callmultarglist
    (115) callmultarglist -> . COMMA primary callmultarglist
    (116) callmultarglist -> . empty
    (151) empty -> .

    COMMA           shift and go to state 190
    CLOSE_BRACKET   reduce using rule 151 (empty -> .)

    callmultarglist                shift and go to state 239
    empty                          shift and go to state 191

state 220

    (132) pdo -> do newline .

    puts            reduce using rule 132 (pdo -> do newline .)
    print           reduce using rule 132 (pdo -> do newline .)
    break           reduce using rule 132 (pdo -> do newline .)
    def             reduce using rule 132 (pdo -> do newline .)
    if              reduce using rule 132 (pdo -> do newline .)
    while           reduce using rule 132 (pdo -> do newline .)
    until           reduce using rule 132 (pdo -> do newline .)
    case            reduce using rule 132 (pdo -> do newline .)
    for             reduce using rule 132 (pdo -> do newline .)
    return          reduce using rule 132 (pdo -> do newline .)
    IDENTIFIER      reduce using rule 132 (pdo -> do newline .)
    nil             reduce using rule 132 (pdo -> do newline .)
    self            reduce using rule 132 (pdo -> do newline .)
    GLOBAL          reduce using rule 132 (pdo -> do newline .)
    AT_THE_RATE     reduce using rule 132 (pdo -> do newline .)
    MINUS           reduce using rule 132 (pdo -> do newline .)
    PLUS            reduce using rule 132 (pdo -> do newline .)
    OPEN_BRACKET    reduce using rule 132 (pdo -> do newline .)
    Array           reduce using rule 132 (pdo -> do newline .)
    NUMBER          reduce using rule 132 (pdo -> do newline .)
    FLOAT           reduce using rule 132 (pdo -> do newline .)
    STRING          reduce using rule 132 (pdo -> do newline .)
    true            reduce using rule 132 (pdo -> do newline .)
    false           reduce using rule 132 (pdo -> do newline .)
    end             reduce using rule 132 (pdo -> do newline .)


state 221

    (133) pdo -> newline do .

    puts            reduce using rule 133 (pdo -> newline do .)
    print           reduce using rule 133 (pdo -> newline do .)
    break           reduce using rule 133 (pdo -> newline do .)
    def             reduce using rule 133 (pdo -> newline do .)
    if              reduce using rule 133 (pdo -> newline do .)
    while           reduce using rule 133 (pdo -> newline do .)
    until           reduce using rule 133 (pdo -> newline do .)
    case            reduce using rule 133 (pdo -> newline do .)
    for             reduce using rule 133 (pdo -> newline do .)
    return          reduce using rule 133 (pdo -> newline do .)
    IDENTIFIER      reduce using rule 133 (pdo -> newline do .)
    nil             reduce using rule 133 (pdo -> newline do .)
    self            reduce using rule 133 (pdo -> newline do .)
    GLOBAL          reduce using rule 133 (pdo -> newline do .)
    AT_THE_RATE     reduce using rule 133 (pdo -> newline do .)
    MINUS           reduce using rule 133 (pdo -> newline do .)
    PLUS            reduce using rule 133 (pdo -> newline do .)
    OPEN_BRACKET    reduce using rule 133 (pdo -> newline do .)
    Array           reduce using rule 133 (pdo -> newline do .)
    NUMBER          reduce using rule 133 (pdo -> newline do .)
    FLOAT           reduce using rule 133 (pdo -> newline do .)
    STRING          reduce using rule 133 (pdo -> newline do .)
    true            reduce using rule 133 (pdo -> newline do .)
    false           reduce using rule 133 (pdo -> newline do .)
    end             reduce using rule 133 (pdo -> newline do .)


state 222

    (20) expr -> until M_1 expr1 pdo M_1 . multstmt end M_1
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 240
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 223

    (97) whenargs -> arg .

    then            reduce using rule 97 (whenargs -> arg .)
    SEMI_COLON      reduce using rule 97 (whenargs -> arg .)
    NEWLINE         reduce using rule 97 (whenargs -> arg .)


state 224

    (87) multcase -> when whenargs . pthen M_1 multstmt M_1 multcase
    (88) multcase -> when whenargs . pthen M_1 multstmt M_1
    (128) pthen -> . newline
    (129) pthen -> . then
    (130) pthen -> . newline then
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    then            shift and go to state 166
    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 167
    pthen                          shift and go to state 241

state 225

    (21) expr -> case expr1 newline multcase end . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    SEMI_COLON      reduce using rule 151 (empty -> .)
    NEWLINE         reduce using rule 151 (empty -> .)
    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    $end            reduce using rule 151 (empty -> .)
    then            reduce using rule 151 (empty -> .)

    empty                          shift and go to state 105
    M_1                            shift and go to state 242

state 226

    (19) expr -> while M_1 expr1 pdo M_1 . multstmt end M_1
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 243
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 227

    (16) expr -> if expr1 pthen M_1 multstmt . else newline M_1 multstmt end M_1
    (17) expr -> if expr1 pthen M_1 multstmt . M_1 multelsif end M_1
    (18) expr -> if expr1 pthen M_1 multstmt . end M_1
    (24) M_1 -> . empty
    (151) empty -> .

  ! shift/reduce conflict for else resolved as shift
  ! shift/reduce conflict for end resolved as shift
    else            shift and go to state 245
    end             shift and go to state 244
    elsif           reduce using rule 151 (empty -> .)

  ! else            [ reduce using rule 151 (empty -> .) ]
  ! end             [ reduce using rule 151 (empty -> .) ]

    M_1                            shift and go to state 246
    empty                          shift and go to state 105

state 228

    (85) array_args -> primary COMMA array_args .

    CLOSE_SQUARE    reduce using rule 85 (array_args -> primary COMMA array_args .)


state 229

    (81) array_size -> primary COMMA array_size .

    CLOSE_BRACKET   reduce using rule 81 (array_size -> primary COMMA array_size .)


state 230

    (14) multstmt -> stmt newline . multstmt
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    end             reduce using rule 151 (empty -> .)
    else            reduce using rule 151 (empty -> .)
    elsif           reduce using rule 151 (empty -> .)
    when            reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 247
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 231

    (7) stmt -> keydef argdecl newline multstmt keyend .

    SEMI_COLON      reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    NEWLINE         reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    puts            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    print           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    break           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    def             reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    if              reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    while           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    until           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    case            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    for             reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    return          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    IDENTIFIER      reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    nil             reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    self            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    GLOBAL          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    AT_THE_RATE     reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    MINUS           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    PLUS            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    OPEN_BRACKET    reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    Array           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    NUMBER          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    FLOAT           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    STRING          reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    true            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    false           reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)
    $end            reduce using rule 7 (stmt -> keydef argdecl newline multstmt keyend .)


state 232

    (13) keyend -> end .

    SEMI_COLON      reduce using rule 13 (keyend -> end .)
    NEWLINE         reduce using rule 13 (keyend -> end .)
    puts            reduce using rule 13 (keyend -> end .)
    print           reduce using rule 13 (keyend -> end .)
    break           reduce using rule 13 (keyend -> end .)
    def             reduce using rule 13 (keyend -> end .)
    if              reduce using rule 13 (keyend -> end .)
    while           reduce using rule 13 (keyend -> end .)
    until           reduce using rule 13 (keyend -> end .)
    case            reduce using rule 13 (keyend -> end .)
    for             reduce using rule 13 (keyend -> end .)
    return          reduce using rule 13 (keyend -> end .)
    IDENTIFIER      reduce using rule 13 (keyend -> end .)
    nil             reduce using rule 13 (keyend -> end .)
    self            reduce using rule 13 (keyend -> end .)
    GLOBAL          reduce using rule 13 (keyend -> end .)
    AT_THE_RATE     reduce using rule 13 (keyend -> end .)
    MINUS           reduce using rule 13 (keyend -> end .)
    PLUS            reduce using rule 13 (keyend -> end .)
    OPEN_BRACKET    reduce using rule 13 (keyend -> end .)
    Array           reduce using rule 13 (keyend -> end .)
    NUMBER          reduce using rule 13 (keyend -> end .)
    FLOAT           reduce using rule 13 (keyend -> end .)
    STRING          reduce using rule 13 (keyend -> end .)
    true            reduce using rule 13 (keyend -> end .)
    false           reduce using rule 13 (keyend -> end .)
    $end            reduce using rule 13 (keyend -> end .)


state 233

    (123) multarglist -> COMMA IDENTIFIER . multarglist
    (123) multarglist -> . COMMA IDENTIFIER multarglist
    (124) multarglist -> . empty
    (151) empty -> .

    COMMA           shift and go to state 209
    CLOSE_BRACKET   reduce using rule 151 (empty -> .)

    multarglist                    shift and go to state 248
    empty                          shift and go to state 211

state 234

    (118) multargs -> COMMA arg multargs .

    COMMA           reduce using rule 118 (multargs -> COMMA arg multargs .)


state 235

    (35) term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .

    SEMI_COLON      reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NEWLINE         reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    do              reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    then            reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    COMMA           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    puts            reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    print           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    break           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    def             reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    if              reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    while           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    until           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    case            reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    for             reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    return          reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    IDENTIFIER      reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    nil             reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    self            reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    GLOBAL          reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    AT_THE_RATE     reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    MINUS           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    PLUS            reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    OPEN_BRACKET    reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    Array           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    NUMBER          reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    FLOAT           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    STRING          reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    true            reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    false           reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    $end            reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)
    CLOSE_BRACKET   reduce using rule 35 (term0 -> mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET .)


state 236

    (110) mrhs -> args COMMA MULTIPLY arg .

    SEMI_COLON      reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    NEWLINE         reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    puts            reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    print           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    break           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    def             reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    if              reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    while           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    until           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    case            reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    for             reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    return          reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    IDENTIFIER      reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    nil             reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    self            reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    GLOBAL          reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    AT_THE_RATE     reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    MINUS           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    PLUS            reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    OPEN_BRACKET    reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    Array           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    NUMBER          reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    FLOAT           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    STRING          reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    true            reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    false           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    $end            reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    CLOSE_BRACKET   reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    then            reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    COMMA           reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)
    do              reduce using rule 110 (mrhs -> args COMMA MULTIPLY arg .)


state 237

    (22) expr -> for M_1 mlhs in expr1 pdo . M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 249
    empty                          shift and go to state 105

state 238

    (83) arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .

    in              reduce using rule 83 (arrayal -> variable OPEN_SQUARE array_args CLOSE_SQUARE .)


state 239

    (115) callmultarglist -> COMMA primary callmultarglist .

    CLOSE_BRACKET   reduce using rule 115 (callmultarglist -> COMMA primary callmultarglist .)


state 240

    (20) expr -> until M_1 expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 250


state 241

    (87) multcase -> when whenargs pthen . M_1 multstmt M_1 multcase
    (88) multcase -> when whenargs pthen . M_1 multstmt M_1
    (24) M_1 -> . empty
    (151) empty -> .

    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    when            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 251
    empty                          shift and go to state 105

state 242

    (21) expr -> case expr1 newline multcase end M_1 .

    SEMI_COLON      reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    NEWLINE         reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    puts            reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    print           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    break           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    def             reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    if              reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    while           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    until           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    case            reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    for             reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    return          reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    IDENTIFIER      reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    nil             reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    self            reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    GLOBAL          reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    AT_THE_RATE     reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    MINUS           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    PLUS            reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    OPEN_BRACKET    reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    Array           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    NUMBER          reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    FLOAT           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    STRING          reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    true            reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    false           reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    $end            reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)
    then            reduce using rule 21 (expr -> case expr1 newline multcase end M_1 .)


state 243

    (19) expr -> while M_1 expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 252


state 244

    (18) expr -> if expr1 pthen M_1 multstmt end . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    SEMI_COLON      reduce using rule 151 (empty -> .)
    NEWLINE         reduce using rule 151 (empty -> .)
    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    $end            reduce using rule 151 (empty -> .)
    then            reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 253
    empty                          shift and go to state 105

state 245

    (16) expr -> if expr1 pthen M_1 multstmt else . newline M_1 multstmt end M_1
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 254

state 246

    (17) expr -> if expr1 pthen M_1 multstmt M_1 . multelsif end M_1
    (89) multelsif -> . elsif expr pthen M_1 multstmt M_1 multelsif M_1
    (90) multelsif -> . else newline multstmt
    (91) multelsif -> . empty
    (151) empty -> .

    elsif           shift and go to state 256
    else            shift and go to state 255
    end             reduce using rule 151 (empty -> .)

    empty                          shift and go to state 257
    multelsif                      shift and go to state 258

state 247

    (14) multstmt -> stmt newline multstmt .

    end             reduce using rule 14 (multstmt -> stmt newline multstmt .)
    else            reduce using rule 14 (multstmt -> stmt newline multstmt .)
    elsif           reduce using rule 14 (multstmt -> stmt newline multstmt .)
    when            reduce using rule 14 (multstmt -> stmt newline multstmt .)


state 248

    (123) multarglist -> COMMA IDENTIFIER multarglist .

    CLOSE_BRACKET   reduce using rule 123 (multarglist -> COMMA IDENTIFIER multarglist .)


state 249

    (22) expr -> for M_1 mlhs in expr1 pdo M_1 . multstmt end M_1
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 259
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 250

    (20) expr -> until M_1 expr1 pdo M_1 multstmt end . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    SEMI_COLON      reduce using rule 151 (empty -> .)
    NEWLINE         reduce using rule 151 (empty -> .)
    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    $end            reduce using rule 151 (empty -> .)
    then            reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 260
    empty                          shift and go to state 105

state 251

    (87) multcase -> when whenargs pthen M_1 . multstmt M_1 multcase
    (88) multcase -> when whenargs pthen M_1 . multstmt M_1
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    when            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    arrayal                        shift and go to state 32
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 261
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    varname                        shift and go to state 28
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 252

    (19) expr -> while M_1 expr1 pdo M_1 multstmt end . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    SEMI_COLON      reduce using rule 151 (empty -> .)
    NEWLINE         reduce using rule 151 (empty -> .)
    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    $end            reduce using rule 151 (empty -> .)
    then            reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 262
    empty                          shift and go to state 105

state 253

    (18) expr -> if expr1 pthen M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    puts            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    print           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    break           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    def             reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    if              reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    while           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    until           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    case            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    for             reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    return          reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    nil             reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    self            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    MINUS           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    PLUS            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    Array           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    STRING          reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    true            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    false           reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    $end            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)
    then            reduce using rule 18 (expr -> if expr1 pthen M_1 multstmt end M_1 .)


state 254

    (16) expr -> if expr1 pthen M_1 multstmt else newline . M_1 multstmt end M_1
    (24) M_1 -> . empty
    (151) empty -> .

    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 263
    empty                          shift and go to state 105

state 255

    (90) multelsif -> else . newline multstmt
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 264

state 256

    (89) multelsif -> elsif . expr pthen M_1 multstmt M_1 multelsif M_1
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    function                       shift and go to state 39
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 265
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    term13                         shift and go to state 8
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 257

    (91) multelsif -> empty .

    end             reduce using rule 91 (multelsif -> empty .)


state 258

    (17) expr -> if expr1 pthen M_1 multstmt M_1 multelsif . end M_1

    end             shift and go to state 266


state 259

    (22) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt . end M_1

    end             shift and go to state 267


state 260

    (20) expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    STRING          reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 20 (expr -> until M_1 expr1 pdo M_1 multstmt end M_1 .)


state 261

    (87) multcase -> when whenargs pthen M_1 multstmt . M_1 multcase
    (88) multcase -> when whenargs pthen M_1 multstmt . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    when            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 268
    empty                          shift and go to state 105

state 262

    (19) expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    STRING          reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 19 (expr -> while M_1 expr1 pdo M_1 multstmt end M_1 .)


state 263

    (16) expr -> if expr1 pthen M_1 multstmt else newline M_1 . multstmt end M_1
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 269
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 264

    (90) multelsif -> else newline . multstmt
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 270
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 265

    (89) multelsif -> elsif expr . pthen M_1 multstmt M_1 multelsif M_1
    (128) pthen -> . newline
    (129) pthen -> . then
    (130) pthen -> . newline then
    (149) newline -> . SEMI_COLON
    (150) newline -> . NEWLINE

    then            shift and go to state 166
    SEMI_COLON      shift and go to state 22
    NEWLINE         shift and go to state 3

    newline                        shift and go to state 167
    pthen                          shift and go to state 271

state 266

    (17) expr -> if expr1 pthen M_1 multstmt M_1 multelsif end . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    SEMI_COLON      reduce using rule 151 (empty -> .)
    NEWLINE         reduce using rule 151 (empty -> .)
    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    $end            reduce using rule 151 (empty -> .)
    then            reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 272
    empty                          shift and go to state 105

state 267

    (22) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    SEMI_COLON      reduce using rule 151 (empty -> .)
    NEWLINE         reduce using rule 151 (empty -> .)
    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    $end            reduce using rule 151 (empty -> .)
    then            reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 273
    empty                          shift and go to state 105

state 268

    (87) multcase -> when whenargs pthen M_1 multstmt M_1 . multcase
    (88) multcase -> when whenargs pthen M_1 multstmt M_1 .
    (87) multcase -> . when whenargs pthen M_1 multstmt M_1 multcase
    (88) multcase -> . when whenargs pthen M_1 multstmt M_1

    end             reduce using rule 88 (multcase -> when whenargs pthen M_1 multstmt M_1 .)
    when            shift and go to state 196

    multcase                       shift and go to state 274

state 269

    (16) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt . end M_1

    end             shift and go to state 275


state 270

    (90) multelsif -> else newline multstmt .

    end             reduce using rule 90 (multelsif -> else newline multstmt .)


state 271

    (89) multelsif -> elsif expr pthen . M_1 multstmt M_1 multelsif M_1
    (24) M_1 -> . empty
    (151) empty -> .

    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    elsif           reduce using rule 151 (empty -> .)
    else            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 276
    empty                          shift and go to state 105

state 272

    (17) expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .

    SEMI_COLON      reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    NEWLINE         reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    puts            reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    print           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    break           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    def             reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    if              reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    while           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    until           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    case            reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    for             reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    return          reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    IDENTIFIER      reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    nil             reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    self            reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    GLOBAL          reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    AT_THE_RATE     reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    MINUS           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    PLUS            reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    OPEN_BRACKET    reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    Array           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    NUMBER          reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    FLOAT           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    STRING          reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    true            reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    false           reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    $end            reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)
    then            reduce using rule 17 (expr -> if expr1 pthen M_1 multstmt M_1 multelsif end M_1 .)


state 273

    (22) expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    puts            reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    print           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    break           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    def             reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    if              reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    while           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    until           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    case            reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    for             reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    return          reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    nil             reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    self            reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    MINUS           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    PLUS            reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    Array           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    STRING          reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    true            reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    false           reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    $end            reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)
    then            reduce using rule 22 (expr -> for M_1 mlhs in expr1 pdo M_1 multstmt end M_1 .)


state 274

    (87) multcase -> when whenargs pthen M_1 multstmt M_1 multcase .

    end             reduce using rule 87 (multcase -> when whenargs pthen M_1 multstmt M_1 multcase .)


state 275

    (16) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    SEMI_COLON      reduce using rule 151 (empty -> .)
    NEWLINE         reduce using rule 151 (empty -> .)
    puts            reduce using rule 151 (empty -> .)
    print           reduce using rule 151 (empty -> .)
    break           reduce using rule 151 (empty -> .)
    def             reduce using rule 151 (empty -> .)
    if              reduce using rule 151 (empty -> .)
    while           reduce using rule 151 (empty -> .)
    until           reduce using rule 151 (empty -> .)
    case            reduce using rule 151 (empty -> .)
    for             reduce using rule 151 (empty -> .)
    return          reduce using rule 151 (empty -> .)
    IDENTIFIER      reduce using rule 151 (empty -> .)
    nil             reduce using rule 151 (empty -> .)
    self            reduce using rule 151 (empty -> .)
    GLOBAL          reduce using rule 151 (empty -> .)
    AT_THE_RATE     reduce using rule 151 (empty -> .)
    MINUS           reduce using rule 151 (empty -> .)
    PLUS            reduce using rule 151 (empty -> .)
    OPEN_BRACKET    reduce using rule 151 (empty -> .)
    Array           reduce using rule 151 (empty -> .)
    NUMBER          reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    STRING          reduce using rule 151 (empty -> .)
    true            reduce using rule 151 (empty -> .)
    false           reduce using rule 151 (empty -> .)
    $end            reduce using rule 151 (empty -> .)
    then            reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 277
    empty                          shift and go to state 105

state 276

    (89) multelsif -> elsif expr pthen M_1 . multstmt M_1 multelsif M_1
    (14) multstmt -> . stmt newline multstmt
    (15) multstmt -> . empty
    (7) stmt -> . keydef argdecl newline multstmt keyend
    (8) stmt -> . puts OPEN_BRACKET STRING CLOSE_BRACKET
    (9) stmt -> . print OPEN_BRACKET primary CLOSE_BRACKET
    (10) stmt -> . break
    (11) stmt -> . expr
    (151) empty -> .
    (12) keydef -> . def IDENTIFIER
    (16) expr -> . if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1
    (17) expr -> . if expr1 pthen M_1 multstmt M_1 multelsif end M_1
    (18) expr -> . if expr1 pthen M_1 multstmt end M_1
    (19) expr -> . while M_1 expr1 pdo M_1 multstmt end M_1
    (20) expr -> . until M_1 expr1 pdo M_1 multstmt end M_1
    (21) expr -> . case expr1 newline multcase end M_1
    (22) expr -> . for M_1 mlhs in expr1 pdo M_1 multstmt end M_1
    (23) expr -> . expr1
    (25) expr1 -> . return IDENTIFIER
    (26) expr1 -> . return
    (27) expr1 -> . expr2
    (28) expr2 -> . arg
    (29) expr2 -> . call
    (33) arg -> . term0
    (30) call -> . function
    (34) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (35) term0 -> . mlhs EQUALS IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (36) term0 -> . term1
    (31) function -> . IDENTIFIER OPEN_BRACKET callargs CLOSE_BRACKET
    (32) function -> . IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
    (98) mlhs -> . mlhsitem
    (37) term1 -> . mlhs EQUALS mrhs
    (38) term1 -> . mlhs opasgn mrhs
    (39) term1 -> . term2
    (99) mlhsitem -> . IDENTIFIER
    (100) mlhsitem -> . arrayal
    (40) term2 -> . term3 INCL_RANGE term3
    (41) term2 -> . term3 EXCL_RANGE term3
    (42) term2 -> . term3
    (83) arrayal -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (43) term3 -> . term3 LOGICAL_OR term4
    (44) term3 -> . term4
    (125) variable -> . varname
    (126) variable -> . nil
    (127) variable -> . self
    (45) term4 -> . term5 DOUBLE_EQUALS term5
    (46) term4 -> . term5 NOT_EQUALS term5
    (47) term4 -> . term5 EQUAL_TILDE term5
    (48) term4 -> . term5 COMPARISON term5
    (49) term4 -> . term5
    (146) varname -> . GLOBAL
    (147) varname -> . AT_THE_RATE IDENTIFIER
    (148) varname -> . IDENTIFIER
    (50) term5 -> . term5 LESS term6
    (51) term5 -> . term5 LESS_EQUALS term6
    (52) term5 -> . term5 GREATER term6
    (53) term5 -> . term5 GREATER_EQUALS term6
    (54) term5 -> . term6
    (55) term6 -> . term6 BIT_XOR term7
    (56) term6 -> . term6 BIT_OR term7
    (57) term6 -> . term7
    (58) term7 -> . term7 BIT_AND term8
    (59) term7 -> . term8
    (60) term8 -> . term8 LEFT_SHIFT term9
    (61) term8 -> . term8 RIGHT_SHIFT term9
    (62) term8 -> . term9
    (63) term9 -> . term9 PLUS term10
    (64) term9 -> . term9 MINUS term10
    (65) term9 -> . term10
    (66) term10 -> . term10 MULTIPLY term11
    (67) term10 -> . term10 DIVIDE term11
    (68) term10 -> . term10 MODULO term11
    (69) term10 -> . term11
    (70) term11 -> . MINUS term11
    (71) term11 -> . term12
    (72) term12 -> . PLUS term12
    (73) term12 -> . term13
    (74) term13 -> . primary
    (75) primary -> . OPEN_BRACKET expr2 CLOSE_BRACKET
    (76) primary -> . arrayd
    (77) primary -> . arraya
    (78) primary -> . literal
    (79) primary -> . varname
    (80) arrayd -> . Array OPEN_BRACKET array_size CLOSE_BRACKET
    (84) arraya -> . variable OPEN_SQUARE array_args CLOSE_SQUARE
    (92) literal -> . NUMBER
    (93) literal -> . FLOAT
    (94) literal -> . STRING
    (95) literal -> . true
    (96) literal -> . false

    puts            shift and go to state 33
    print           shift and go to state 25
    break           shift and go to state 59
    elsif           reduce using rule 151 (empty -> .)
    else            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)
    def             shift and go to state 47
    if              shift and go to state 51
    while           shift and go to state 45
    until           shift and go to state 37
    case            shift and go to state 43
    for             shift and go to state 24
    return          shift and go to state 6
    IDENTIFIER      shift and go to state 36
    nil             shift and go to state 56
    self            shift and go to state 52
    GLOBAL          shift and go to state 30
    AT_THE_RATE     shift and go to state 21
    MINUS           shift and go to state 2
    PLUS            shift and go to state 5
    OPEN_BRACKET    shift and go to state 4
    Array           shift and go to state 61
    NUMBER          shift and go to state 50
    FLOAT           shift and go to state 60
    STRING          shift and go to state 55
    true            shift and go to state 42
    false           shift and go to state 49

    term7                          shift and go to state 12
    term6                          shift and go to state 13
    term5                          shift and go to state 14
    term4                          shift and go to state 15
    term3                          shift and go to state 16
    term2                          shift and go to state 17
    term1                          shift and go to state 18
    term0                          shift and go to state 19
    mlhs                           shift and go to state 1
    primary                        shift and go to state 31
    term9                          shift and go to state 20
    term8                          shift and go to state 41
    arg                            shift and go to state 23
    arrayal                        shift and go to state 32
    expr2                          shift and go to state 53
    term13                         shift and go to state 8
    literal                        shift and go to state 34
    expr1                          shift and go to state 54
    call                           shift and go to state 35
    varname                        shift and go to state 28
    empty                          shift and go to state 206
    function                       shift and go to state 39
    stmt                           shift and go to state 205
    multstmt                       shift and go to state 278
    mlhsitem                       shift and go to state 40
    variable                       shift and go to state 58
    expr                           shift and go to state 44
    arraya                         shift and go to state 46
    arrayd                         shift and go to state 48
    keydef                         shift and go to state 62
    term12                         shift and go to state 9
    term11                         shift and go to state 10
    term10                         shift and go to state 11

state 277

    (16) expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .

    SEMI_COLON      reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    NEWLINE         reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    puts            reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    print           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    break           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    def             reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    if              reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    while           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    until           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    case            reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    for             reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    return          reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    IDENTIFIER      reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    nil             reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    self            reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    GLOBAL          reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    AT_THE_RATE     reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    MINUS           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    PLUS            reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    OPEN_BRACKET    reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    Array           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    NUMBER          reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    FLOAT           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    STRING          reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    true            reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    false           reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    $end            reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)
    then            reduce using rule 16 (expr -> if expr1 pthen M_1 multstmt else newline M_1 multstmt end M_1 .)


state 278

    (89) multelsif -> elsif expr pthen M_1 multstmt . M_1 multelsif M_1
    (24) M_1 -> . empty
    (151) empty -> .

    elsif           reduce using rule 151 (empty -> .)
    else            reduce using rule 151 (empty -> .)
    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 279
    empty                          shift and go to state 105

state 279

    (89) multelsif -> elsif expr pthen M_1 multstmt M_1 . multelsif M_1
    (89) multelsif -> . elsif expr pthen M_1 multstmt M_1 multelsif M_1
    (90) multelsif -> . else newline multstmt
    (91) multelsif -> . empty
    (151) empty -> .

    elsif           shift and go to state 256
    else            shift and go to state 255
    end             reduce using rule 151 (empty -> .)

    multelsif                      shift and go to state 280
    empty                          shift and go to state 257

state 280

    (89) multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif . M_1
    (24) M_1 -> . empty
    (151) empty -> .

    end             reduce using rule 151 (empty -> .)

    M_1                            shift and go to state 281
    empty                          shift and go to state 105

state 281

    (89) multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1 .

    end             reduce using rule 89 (multelsif -> elsif expr pthen M_1 multstmt M_1 multelsif M_1 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 6 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 20 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 20 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 36 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACKET in state 109 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 123 resolved as shift
WARNING: shift/reduce conflict for OPEN_BRACKET in state 125 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for CLOSE_BRACKET in state 182 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 212 resolved as shift
WARNING: shift/reduce conflict for else in state 227 resolved as shift
WARNING: shift/reduce conflict for end in state 227 resolved as shift
WARNING: reduce/reduce conflict in state 122 resolved using rule (term1 -> term2)
WARNING: rejected rule (mrhs -> term2) in state 122
